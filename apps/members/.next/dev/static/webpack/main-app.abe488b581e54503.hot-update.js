"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main-app",{

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-bootstrap.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/client/app-bootstrap.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * Before starting the Next.js runtime and requiring any module, we need to make\n * sure the following scripts are executed in the correct order:\n * - Polyfills\n * - next/script with `beforeInteractive` strategy\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"appBootstrap\", ({\n    enumerable: true,\n    get: function() {\n        return appBootstrap;\n    }\n}));\nconst _assetprefix = __webpack_require__(/*! ./asset-prefix */ \"(app-pages-browser)/./node_modules/next/dist/client/asset-prefix.js\");\nconst _setattributesfromprops = __webpack_require__(/*! ./set-attributes-from-props */ \"(app-pages-browser)/./node_modules/next/dist/client/set-attributes-from-props.js\");\nconst version = \"16.1.6\";\nwindow.next = {\n    version,\n    appDir: true\n};\nfunction loadScriptsInSequence(scripts, hydrate) {\n    if (!scripts || !scripts.length) {\n        return hydrate();\n    }\n    return scripts.reduce((promise, [src, props])=>{\n        return promise.then(()=>{\n            return new Promise((resolve, reject)=>{\n                const el = document.createElement('script');\n                if (props) {\n                    (0, _setattributesfromprops.setAttributesFromProps)(el, props);\n                }\n                if (src) {\n                    el.src = src;\n                    el.onload = ()=>resolve();\n                    el.onerror = reject;\n                } else if (props) {\n                    el.innerHTML = props.children;\n                    setTimeout(resolve);\n                }\n                document.head.appendChild(el);\n            });\n        });\n    }, Promise.resolve()).catch((err)=>{\n        console.error(err);\n    // Still try to hydrate even if there's an error.\n    }).then(()=>{\n        hydrate();\n    });\n}\nfunction appBootstrap(hydrate) {\n    const assetPrefix = (0, _assetprefix.getAssetPrefix)();\n    loadScriptsInSequence(self.__next_s, ()=>{\n        // If the static shell is being debugged, skip hydration if the\n        // `__nextppronly` query is present. This is only enabled when the\n        // environment variable `__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING` is\n        // set to `1`. Otherwise the following is optimized out.\n        if (false) {}\n        hydrate(assetPrefix);\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-bootstrap.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1ib290c3RyYXAuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7Ozs7Z0RBb0RlQTs7O2VBQUFBOzs7eUNBbERlO29EQUNRO0FBRXZDLE1BQU1DLFVBQVVDLFFBQVFDO0FBRXhCRSxPQUFPQyxJQUFJLEdBQUc7SUFDWkw7SUFDQU0sUUFBUTtBQUNWO0FBRUEsU0FBU0Msc0JBQ1BDLE9BQXdELEVBQ3hEQyxPQUFtQjtJQUVuQixJQUFJLENBQUNELFdBQVcsQ0FBQ0EsUUFBUUUsTUFBTSxFQUFFO1FBQy9CLE9BQU9EO0lBQ1Q7SUFFQSxPQUFPRCxRQUNKRyxNQUFNLENBQUMsQ0FBQ0MsU0FBUyxDQUFDQyxLQUFLQyxNQUFNO1FBQzVCLE9BQU9GLFFBQVFHLElBQUksQ0FBQztZQUNsQixPQUFPLElBQUlDLFFBQWMsQ0FBQ0MsU0FBU0M7Z0JBQ2pDLE1BQU1DLEtBQUtDLFNBQVNDLGFBQWEsQ0FBQztnQkFFbEMsSUFBSVAsT0FBTztvQkFDVFEsQ0FBQUEsR0FBQUEsd0JBQUFBLHNCQUFBQSxFQUF1QkgsSUFBSUw7Z0JBQzdCO2dCQUVBLElBQUlELEtBQUs7b0JBQ1BNLEdBQUdOLEdBQUcsR0FBR0E7b0JBQ1RNLEdBQUdJLE1BQU0sR0FBRyxJQUFNTjtvQkFDbEJFLEdBQUdLLE9BQU8sR0FBR047Z0JBQ2YsT0FBTyxJQUFJSixPQUFPO29CQUNoQkssR0FBR00sU0FBUyxHQUFHWCxNQUFNWSxRQUFRO29CQUM3QkMsV0FBV1Y7Z0JBQ2I7Z0JBRUFHLFNBQVNRLElBQUksQ0FBQ0MsV0FBVyxDQUFDVjtZQUM1QjtRQUNGO0lBQ0YsR0FBR0gsUUFBUUMsT0FBTyxJQUNqQmEsS0FBSyxDQUFDLENBQUNDO1FBQ05DLFFBQVFDLEtBQUssQ0FBQ0Y7SUFDZCxpREFBaUQ7SUFDbkQsR0FDQ2hCLElBQUksQ0FBQztRQUNKTjtJQUNGO0FBQ0o7QUFFTyxTQUFTVixhQUFhVSxPQUFzQztJQUNqRSxNQUFNeUIsY0FBY0MsQ0FBQUEsR0FBQUEsYUFBQUEsY0FBQUE7SUFFcEI1QixzQkFBdUI2QixLQUFhQyxRQUFRLEVBQUU7UUFDNUMsK0RBQStEO1FBQy9ELGtFQUFrRTtRQUNsRSx1RUFBdUU7UUFDdkUsd0RBQXdEO1FBQ3hELElBQUlwQyxLQUE4RCxFQUFFLEVBV25FO1FBRURRLFFBQVF5QjtJQUNWO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yeWFucm9zenRvY3p5L0RldmVsb3BtZW50L21haW5zdHJlZXRhaS13ZWJzaXRlL3NyYy9jbGllbnQvYXBwLWJvb3RzdHJhcC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJlZm9yZSBzdGFydGluZyB0aGUgTmV4dC5qcyBydW50aW1lIGFuZCByZXF1aXJpbmcgYW55IG1vZHVsZSwgd2UgbmVlZCB0byBtYWtlXG4gKiBzdXJlIHRoZSBmb2xsb3dpbmcgc2NyaXB0cyBhcmUgZXhlY3V0ZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXI6XG4gKiAtIFBvbHlmaWxsc1xuICogLSBuZXh0L3NjcmlwdCB3aXRoIGBiZWZvcmVJbnRlcmFjdGl2ZWAgc3RyYXRlZ3lcbiAqL1xuXG5pbXBvcnQgeyBnZXRBc3NldFByZWZpeCB9IGZyb20gJy4vYXNzZXQtcHJlZml4J1xuaW1wb3J0IHsgc2V0QXR0cmlidXRlc0Zyb21Qcm9wcyB9IGZyb20gJy4vc2V0LWF0dHJpYnV0ZXMtZnJvbS1wcm9wcydcblxuY29uc3QgdmVyc2lvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9WRVJTSU9OXG5cbndpbmRvdy5uZXh0ID0ge1xuICB2ZXJzaW9uLFxuICBhcHBEaXI6IHRydWUsXG59XG5cbmZ1bmN0aW9uIGxvYWRTY3JpcHRzSW5TZXF1ZW5jZShcbiAgc2NyaXB0czogW3NyYzogc3RyaW5nLCBwcm9wczogeyBbcHJvcDogc3RyaW5nXTogYW55IH1dW10sXG4gIGh5ZHJhdGU6ICgpID0+IHZvaWRcbikge1xuICBpZiAoIXNjcmlwdHMgfHwgIXNjcmlwdHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGh5ZHJhdGUoKVxuICB9XG5cbiAgcmV0dXJuIHNjcmlwdHNcbiAgICAucmVkdWNlKChwcm9taXNlLCBbc3JjLCBwcm9wc10pID0+IHtcbiAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcblxuICAgICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgICAgc2V0QXR0cmlidXRlc0Zyb21Qcm9wcyhlbCwgcHJvcHMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgZWwuc3JjID0gc3JjXG4gICAgICAgICAgICBlbC5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKClcbiAgICAgICAgICAgIGVsLm9uZXJyb3IgPSByZWplY3RcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb3BzKSB7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBwcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZWwpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0sIFByb21pc2UucmVzb2x2ZSgpKVxuICAgIC5jYXRjaCgoZXJyOiBFcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICAvLyBTdGlsbCB0cnkgdG8gaHlkcmF0ZSBldmVuIGlmIHRoZXJlJ3MgYW4gZXJyb3IuXG4gICAgfSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICBoeWRyYXRlKClcbiAgICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwQm9vdHN0cmFwKGh5ZHJhdGU6IChhc3NldFByZWZpeDogc3RyaW5nKSA9PiB2b2lkKSB7XG4gIGNvbnN0IGFzc2V0UHJlZml4ID0gZ2V0QXNzZXRQcmVmaXgoKVxuXG4gIGxvYWRTY3JpcHRzSW5TZXF1ZW5jZSgoc2VsZiBhcyBhbnkpLl9fbmV4dF9zLCAoKSA9PiB7XG4gICAgLy8gSWYgdGhlIHN0YXRpYyBzaGVsbCBpcyBiZWluZyBkZWJ1Z2dlZCwgc2tpcCBoeWRyYXRpb24gaWYgdGhlXG4gICAgLy8gYF9fbmV4dHBwcm9ubHlgIHF1ZXJ5IGlzIHByZXNlbnQuIFRoaXMgaXMgb25seSBlbmFibGVkIHdoZW4gdGhlXG4gICAgLy8gZW52aXJvbm1lbnQgdmFyaWFibGUgYF9fTkVYVF9FWFBFUklNRU5UQUxfU1RBVElDX1NIRUxMX0RFQlVHR0lOR2AgaXNcbiAgICAvLyBzZXQgdG8gYDFgLiBPdGhlcndpc2UgdGhlIGZvbGxvd2luZyBpcyBvcHRpbWl6ZWQgb3V0LlxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfRVhQRVJJTUVOVEFMX1NUQVRJQ19TSEVMTF9ERUJVR0dJTkcgPT09ICcxJykge1xuICAgICAgY29uc3Qgc2VhcmNoID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKVxuICAgICAgaWYgKFxuICAgICAgICBzZWFyY2guZ2V0KCdfX25leHRwcHJvbmx5JykgPT09ICdmYWxsYmFjaycgfHxcbiAgICAgICAgc2VhcmNoLmdldCgnX19uZXh0cHByb25seScpID09PSAnMSdcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFNraXBwaW5nIGh5ZHJhdGlvbiBkdWUgdG8gX19uZXh0cHByb25seT0ke3NlYXJjaC5nZXQoJ19fbmV4dHBwcm9ubHknKX1gXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaHlkcmF0ZShhc3NldFByZWZpeClcbiAgfSlcbn1cbiJdLCJuYW1lcyI6WyJhcHBCb290c3RyYXAiLCJ2ZXJzaW9uIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9WRVJTSU9OIiwid2luZG93IiwibmV4dCIsImFwcERpciIsImxvYWRTY3JpcHRzSW5TZXF1ZW5jZSIsInNjcmlwdHMiLCJoeWRyYXRlIiwibGVuZ3RoIiwicmVkdWNlIiwicHJvbWlzZSIsInNyYyIsInByb3BzIiwidGhlbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZWwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGVzRnJvbVByb3BzIiwib25sb2FkIiwib25lcnJvciIsImlubmVySFRNTCIsImNoaWxkcmVuIiwic2V0VGltZW91dCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImNhdGNoIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwiYXNzZXRQcmVmaXgiLCJnZXRBc3NldFByZWZpeCIsInNlbGYiLCJfX25leHRfcyIsIl9fTkVYVF9FWFBFUklNRU5UQUxfU1RBVElDX1NIRUxMX0RFQlVHR0lORyIsInNlYXJjaCIsIlVSTFNlYXJjaFBhcmFtcyIsImxvY2F0aW9uIiwiZ2V0Iiwid2FybiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-bootstrap.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/client/app-find-source-map-url.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"findSourceMapURL\", ({\n    enumerable: true,\n    get: function() {\n        return findSourceMapURL;\n    }\n}));\nconst basePath =  false || '';\nconst pathname = `${basePath}/__nextjs_source-map`;\nconst findSourceMapURL =  true ? function findSourceMapURL(filename) {\n    if (filename === '') {\n        return null;\n    }\n    if (filename.startsWith(document.location.origin) && filename.includes('/_next/static')) {\n        // This is a request for a client chunk. This can only happen when\n        // using Turbopack. In this case, since we control how those source\n        // maps are generated, we can safely assume that the sourceMappingURL\n        // is relative to the filename, with an added `.map` extension. The\n        // browser can just request this file, and it gets served through the\n        // normal dev server, without the need to route this through\n        // the `/__nextjs_source-map` dev middleware.\n        return `${filename}.map`;\n    }\n    const url = new URL(pathname, document.location.origin);\n    url.searchParams.set('filename', filename);\n    return url.href;\n} : 0;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-find-source-map-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1maW5kLXNvdXJjZS1tYXAtdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7b0RBR2FBOzs7ZUFBQUE7OztBQUhiLE1BQU1DLFdBQVdDLE1BQWtDLElBQUk7QUFDdkQsTUFBTUcsV0FBVyxHQUFHSixTQUFTLG9CQUFvQixDQUFDO0FBRTNDLE1BQU1ELG1CQUNYRSxLQUFvQixHQUNoQixTQUFTRixpQkFBaUJPLFFBQWdCO0lBQ3hDLElBQUlBLGFBQWEsSUFBSTtRQUNuQixPQUFPO0lBQ1Q7SUFFQSxJQUNFQSxTQUFTQyxVQUFVLENBQUNDLFNBQVNDLFFBQVEsQ0FBQ0MsTUFBTSxLQUM1Q0osU0FBU0ssUUFBUSxDQUFDLGtCQUNsQjtRQUNBLGtFQUFrRTtRQUNsRSxtRUFBbUU7UUFDbkUscUVBQXFFO1FBQ3JFLG1FQUFtRTtRQUNuRSxxRUFBcUU7UUFDckUsNERBQTREO1FBQzVELDZDQUE2QztRQUM3QyxPQUFPLEdBQUdMLFNBQVMsSUFBSSxDQUFDO0lBQzFCO0lBRUEsTUFBTU0sTUFBTSxJQUFJQyxJQUFJVCxVQUFVSSxTQUFTQyxRQUFRLENBQUNDLE1BQU07SUFDdERFLElBQUlFLFlBQVksQ0FBQ0MsR0FBRyxDQUFDLFlBQVlUO0lBRWpDLE9BQU9NLElBQUlJLElBQUk7QUFDakIsSUFDQUMsQ0FBU0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yeWFucm9zenRvY3p5L0RldmVsb3BtZW50L21haW5zdHJlZXRhaS13ZWJzaXRlL3NyYy9jbGllbnQvYXBwLWZpbmQtc291cmNlLW1hcC11cmwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnXG5jb25zdCBwYXRobmFtZSA9IGAke2Jhc2VQYXRofS9fX25leHRqc19zb3VyY2UtbWFwYFxuXG5leHBvcnQgY29uc3QgZmluZFNvdXJjZU1hcFVSTCA9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnXG4gICAgPyBmdW5jdGlvbiBmaW5kU291cmNlTWFwVVJMKGZpbGVuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAgICAgaWYgKGZpbGVuYW1lID09PSAnJykge1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgZmlsZW5hbWUuc3RhcnRzV2l0aChkb2N1bWVudC5sb2NhdGlvbi5vcmlnaW4pICYmXG4gICAgICAgICAgZmlsZW5hbWUuaW5jbHVkZXMoJy9fbmV4dC9zdGF0aWMnKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgcmVxdWVzdCBmb3IgYSBjbGllbnQgY2h1bmsuIFRoaXMgY2FuIG9ubHkgaGFwcGVuIHdoZW5cbiAgICAgICAgICAvLyB1c2luZyBUdXJib3BhY2suIEluIHRoaXMgY2FzZSwgc2luY2Ugd2UgY29udHJvbCBob3cgdGhvc2Ugc291cmNlXG4gICAgICAgICAgLy8gbWFwcyBhcmUgZ2VuZXJhdGVkLCB3ZSBjYW4gc2FmZWx5IGFzc3VtZSB0aGF0IHRoZSBzb3VyY2VNYXBwaW5nVVJMXG4gICAgICAgICAgLy8gaXMgcmVsYXRpdmUgdG8gdGhlIGZpbGVuYW1lLCB3aXRoIGFuIGFkZGVkIGAubWFwYCBleHRlbnNpb24uIFRoZVxuICAgICAgICAgIC8vIGJyb3dzZXIgY2FuIGp1c3QgcmVxdWVzdCB0aGlzIGZpbGUsIGFuZCBpdCBnZXRzIHNlcnZlZCB0aHJvdWdoIHRoZVxuICAgICAgICAgIC8vIG5vcm1hbCBkZXYgc2VydmVyLCB3aXRob3V0IHRoZSBuZWVkIHRvIHJvdXRlIHRoaXMgdGhyb3VnaFxuICAgICAgICAgIC8vIHRoZSBgL19fbmV4dGpzX3NvdXJjZS1tYXBgIGRldiBtaWRkbGV3YXJlLlxuICAgICAgICAgIHJldHVybiBgJHtmaWxlbmFtZX0ubWFwYFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChwYXRobmFtZSwgZG9jdW1lbnQubG9jYXRpb24ub3JpZ2luKVxuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnZmlsZW5hbWUnLCBmaWxlbmFtZSlcblxuICAgICAgICByZXR1cm4gdXJsLmhyZWZcbiAgICAgIH1cbiAgICA6IHVuZGVmaW5lZFxuIl0sIm5hbWVzIjpbImZpbmRTb3VyY2VNYXBVUkwiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aG5hbWUiLCJOT0RFX0VOViIsImZpbGVuYW1lIiwic3RhcnRzV2l0aCIsImRvY3VtZW50IiwibG9jYXRpb24iLCJvcmlnaW4iLCJpbmNsdWRlcyIsInVybCIsIlVSTCIsInNlYXJjaFBhcmFtcyIsInNldCIsImhyZWYiLCJ1bmRlZmluZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-index.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/client/app-index.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hydrate\", ({\n    enumerable: true,\n    get: function() {\n        return hydrate;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n__webpack_require__(/*! ./app-globals */ \"(app-pages-browser)/./node_modules/next/dist/client/app-globals.js\");\nconst _client = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/client.js\"));\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _client1 = __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.browser.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _onrecoverableerror = __webpack_require__(/*! ./react-client-callbacks/on-recoverable-error */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js\");\nconst _errorboundarycallbacks = __webpack_require__(/*! ./react-client-callbacks/error-boundary-callbacks */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js\");\nconst _appcallserver = __webpack_require__(/*! ./app-call-server */ \"(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ./app-find-source-map-url */ \"(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _approuterinstance = __webpack_require__(/*! ./components/app-router-instance */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-instance.js\");\nconst _approuter = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./components/app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\"));\nconst _createinitialrouterstate = __webpack_require__(/*! ./components/router-reducer/create-initial-router-state */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _appbuildid = __webpack_require__(/*! ./app-build-id */ \"(app-pages-browser)/./node_modules/next/dist/client/app-build-id.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ./flight-data-helpers */ \"(app-pages-browser)/./node_modules/next/dist/client/flight-data-helpers.js\");\n/// <reference types=\"react-dom/experimental\" />\nconst createFromReadableStream = _client1.createFromReadableStream;\nconst createFromFetch = _client1.createFromFetch;\nconst appElement = document;\nconst encoder = new TextEncoder();\nlet initialServerDataBuffer = undefined;\nlet initialServerDataWriter = undefined;\nlet initialServerDataLoaded = false;\nlet initialServerDataFlushed = false;\nlet initialFormStateData = null;\nfunction nextServerDataCallback(seg) {\n    if (seg[0] === 0) {\n        initialServerDataBuffer = [];\n    } else if (seg[0] === 1) {\n        if (!initialServerDataBuffer) throw Object.defineProperty(new Error('Unexpected server data: missing bootstrap script.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E18\",\n            enumerable: false,\n            configurable: true\n        });\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(encoder.encode(seg[1]));\n        } else {\n            initialServerDataBuffer.push(seg[1]);\n        }\n    } else if (seg[0] === 2) {\n        initialFormStateData = seg[1];\n    } else if (seg[0] === 3) {\n        if (!initialServerDataBuffer) throw Object.defineProperty(new Error('Unexpected server data: missing bootstrap script.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E18\",\n            enumerable: false,\n            configurable: true\n        });\n        // Decode the base64 string back to binary data.\n        const binaryString = atob(seg[1]);\n        const decodedChunk = new Uint8Array(binaryString.length);\n        for(var i = 0; i < binaryString.length; i++){\n            decodedChunk[i] = binaryString.charCodeAt(i);\n        }\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(decodedChunk);\n        } else {\n            initialServerDataBuffer.push(decodedChunk);\n        }\n    }\n}\nfunction isStreamErrorOrUnfinished(ctr) {\n    // If `desiredSize` is null, it means the stream is closed or errored. If it is lower than 0, the stream is still unfinished.\n    return ctr.desiredSize === null || ctr.desiredSize < 0;\n}\n// There might be race conditions between `nextServerDataRegisterWriter` and\n// `DOMContentLoaded`. The former will be called when React starts to hydrate\n// the root, the latter will be called when the DOM is fully loaded.\n// For streaming, the former is called first due to partial hydration.\n// For non-streaming, the latter can be called first.\n// Hence, we use two variables `initialServerDataLoaded` and\n// `initialServerDataFlushed` to make sure the writer will be closed and\n// `initialServerDataBuffer` will be cleared in the right time.\nfunction nextServerDataRegisterWriter(ctr) {\n    if (initialServerDataBuffer) {\n        initialServerDataBuffer.forEach((val)=>{\n            ctr.enqueue(typeof val === 'string' ? encoder.encode(val) : val);\n        });\n        if (initialServerDataLoaded && !initialServerDataFlushed) {\n            if (isStreamErrorOrUnfinished(ctr)) {\n                ctr.error(Object.defineProperty(new Error('The connection to the page was unexpectedly closed, possibly due to the stop button being clicked, loss of Wi-Fi, or an unstable internet connection.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E117\",\n                    enumerable: false,\n                    configurable: true\n                }));\n            } else {\n                ctr.close();\n            }\n            initialServerDataFlushed = true;\n            initialServerDataBuffer = undefined;\n        }\n    }\n    initialServerDataWriter = ctr;\n}\n// When `DOMContentLoaded`, we can close all pending writers to finish hydration.\nconst DOMContentLoaded = function() {\n    if (initialServerDataWriter && !initialServerDataFlushed) {\n        initialServerDataWriter.close();\n        initialServerDataFlushed = true;\n        initialServerDataBuffer = undefined;\n    }\n    initialServerDataLoaded = true;\n};\n_c = DOMContentLoaded;\n// It's possible that the DOM is already loaded.\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', DOMContentLoaded, false);\n} else {\n    // Delayed in marco task to ensure it's executed later than hydration\n    setTimeout(DOMContentLoaded);\n}\nconst nextServerDataLoadingGlobal = self.__next_f = self.__next_f || [];\n// Consume all buffered chunks and clear the global data array right after to release memory.\n// Otherwise it will be retained indefinitely.\nnextServerDataLoadingGlobal.forEach(nextServerDataCallback);\nnextServerDataLoadingGlobal.length = 0;\n// Patch its push method so subsequent chunks are handled (but not actually pushed to the array).\nnextServerDataLoadingGlobal.push = nextServerDataCallback;\nconst readable = new ReadableStream({\n    start (controller) {\n        nextServerDataRegisterWriter(controller);\n    }\n});\nif (true) {\n    // @ts-expect-error\n    readable.name = 'hydration';\n}\nlet debugChannel;\nif (false) {}\nconst clientResumeFetch = window.__NEXT_CLIENT_RESUME;\nlet initialServerResponse;\nif (clientResumeFetch) {\n    initialServerResponse = Promise.resolve(createFromFetch(clientResumeFetch, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel\n    })).then(async (fallbackInitialRSCPayload)=>(0, _flightdatahelpers.createInitialRSCPayloadFromFallbackPrerender)(await clientResumeFetch, fallbackInitialRSCPayload));\n} else {\n    initialServerResponse = createFromReadableStream(readable, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel,\n        startTime: 0\n    });\n}\nfunction ServerRoot({ initialRSCPayload, actionQueue, webSocket, staticIndicatorState }) {\n    const router = /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuter.default, {\n        actionQueue: actionQueue,\n        globalErrorState: initialRSCPayload.G,\n        webSocket: webSocket,\n        staticIndicatorState: staticIndicatorState\n    });\n    if ( true && initialRSCPayload.m) {\n        // We provide missing slot information in a context provider only during development\n        // as we log some additional information about the missing slots in the console.\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.MissingSlotContext, {\n            value: initialRSCPayload.m,\n            children: router\n        });\n    }\n    return router;\n}\n_c1 = ServerRoot;\nconst StrictModeIfEnabled =  true ? _react.default.StrictMode : 0;\nfunction Root({ children }) {\n    if (false) {}\n    return children;\n}\n_c2 = Root;\nconst enableTransitionIndicator = false;\nfunction noDefaultTransitionIndicator() {\n    return ()=>{};\n}\nconst reactRootOptions = {\n    onDefaultTransitionIndicator: enableTransitionIndicator ? undefined : noDefaultTransitionIndicator,\n    onRecoverableError: _onrecoverableerror.onRecoverableError,\n    onCaughtError: _errorboundarycallbacks.onCaughtError,\n    onUncaughtError: _errorboundarycallbacks.onUncaughtError\n};\nasync function hydrate(instrumentationHooks, assetPrefix) {\n    let staticIndicatorState;\n    let webSocket;\n    if (true) {\n        const { createWebSocket } = __webpack_require__(/*! ./dev/hot-reloader/app/web-socket */ \"(app-pages-browser)/./node_modules/next/dist/client/dev/hot-reloader/app/web-socket.js\");\n        staticIndicatorState = {\n            pathname: null,\n            appIsrManifest: null\n        };\n        webSocket = createWebSocket(assetPrefix, staticIndicatorState);\n    }\n    const initialRSCPayload = await initialServerResponse;\n    // setAppBuildId should be called only once, during JS initialization\n    // and before any components have hydrated.\n    (0, _appbuildid.setAppBuildId)(initialRSCPayload.b);\n    const initialTimestamp = Date.now();\n    const actionQueue = (0, _approuterinstance.createMutableActionQueue)((0, _createinitialrouterstate.createInitialRouterState)({\n        navigatedAt: initialTimestamp,\n        initialFlightData: initialRSCPayload.f,\n        initialCanonicalUrlParts: initialRSCPayload.c,\n        initialRenderedSearch: initialRSCPayload.q,\n        location: window.location\n    }), instrumentationHooks);\n    const reactEl = /*#__PURE__*/ (0, _jsxruntime.jsx)(StrictModeIfEnabled, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {\n            value: {\n                appDir: true\n            },\n            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Root, {\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ServerRoot, {\n                    initialRSCPayload: initialRSCPayload,\n                    actionQueue: actionQueue,\n                    webSocket: webSocket,\n                    staticIndicatorState: staticIndicatorState\n                })\n            })\n        })\n    });\n    if (document.documentElement.id === '__next_error__') {\n        let element = reactEl;\n        // Server rendering failed, fall back to client-side rendering\n        if (true) {\n            const { RootLevelDevOverlayElement } = __webpack_require__(/*! ../next-devtools/userspace/app/client-entry */ \"(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/client-entry.js\");\n            // Note this won't cause hydration mismatch because we are doing CSR w/o hydration\n            element = /*#__PURE__*/ (0, _jsxruntime.jsx)(RootLevelDevOverlayElement, {\n                children: element\n            });\n        }\n        _client.default.createRoot(appElement, reactRootOptions).render(element);\n    } else {\n        _react.default.startTransition(()=>{\n            _client.default.hydrateRoot(appElement, reactEl, {\n                ...reactRootOptions,\n                formState: initialFormStateData\n            });\n        });\n    }\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (true) {\n        const { linkGc } = __webpack_require__(/*! ./app-link-gc */ \"(app-pages-browser)/./node_modules/next/dist/client/app-link-gc.js\");\n        linkGc();\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"DOMContentLoaded\");\n$RefreshReg$(_c1, \"ServerRoot\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OzJDQXNTc0JBOzs7ZUFBQUE7Ozs7O29CQXRTZjs2RUFDb0I7NEVBQ1Q7cUNBTVg7NkRBQzRCO2dEQUNBO29EQUk1QjsyQ0FDb0I7aURBQ007K0NBSTFCO2dGQUNlO3NEQUVtQjsyREFDTjt3Q0FDTDsrQ0FFK0I7QUFFN0QsZ0RBQWdEO0FBRWhELE1BQU1DLDJCQUNKQyxTQUFBQSx3QkFBK0I7QUFDakMsTUFBTUMsa0JBQ0pDLFNBQUFBLGVBQXNCO0FBRXhCLE1BQU1DLGFBQXFDQztBQUUzQyxNQUFNQyxVQUFVLElBQUlDO0FBRXBCLElBQUlDLDBCQUErREM7QUFDbkUsSUFBSUMsMEJBQ0ZEO0FBQ0YsSUFBSUUsMEJBQTBCO0FBQzlCLElBQUlDLDJCQUEyQjtBQUUvQixJQUFJQyx1QkFBbUM7QUF1QnZDLFNBQVNDLHVCQUF1QkMsR0FBa0I7SUFDaEQsSUFBSUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHO1FBQ2hCUCwwQkFBMEIsRUFBRTtJQUM5QixPQUFPLElBQUlPLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRztRQUN2QixJQUFJLENBQUNQLHlCQUNILE1BQU0scUJBQThELENBQTlELElBQUlRLE1BQU0sc0RBQVY7bUJBQUE7d0JBQUE7MEJBQUE7UUFBNkQ7UUFFckUsSUFBSU4seUJBQXlCO1lBQzNCQSx3QkFBd0JPLE9BQU8sQ0FBQ1gsUUFBUVksTUFBTSxDQUFDSCxHQUFHLENBQUMsRUFBRTtRQUN2RCxPQUFPO1lBQ0xQLHdCQUF3QlcsSUFBSSxDQUFDSixHQUFHLENBQUMsRUFBRTtRQUNyQztJQUNGLE9BQU8sSUFBSUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHO1FBQ3ZCRix1QkFBdUJFLEdBQUcsQ0FBQyxFQUFFO0lBQy9CLE9BQU8sSUFBSUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHO1FBQ3ZCLElBQUks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LFVBQUFBLFdBQUFBLEdBQ0UscUJBQUNDLDRCQUFBQTswQkFBNEJEOztRQUVqQztRQUVBRSxRQUFBQSxPQUFjLENBQUNDLFVBQVUsQ0FBQzVILFlBQVkyRixrQkFBa0JrQyxNQUFNLENBQUNKO0lBQ2pFLE9BQU87UUFDTDdDLE9BQUFBLE9BQUssQ0FBQ2tELGVBQWUsQ0FBQztZQUNwQkgsUUFBQUEsT0FBYyxDQUFDSSxXQUFXLENBQUMvSCxZQUFZbUgsU0FBUztnQkFDOUMsR0FBR3hCLGdCQUFnQjtnQkFDbkJxQyxXQUFXdkg7WUFDYjtRQUNGO0lBQ0Y7SUFFQSx5RUFBeUU7SUFDekUsSUFBSWlDLElBQW9CLEVBQW1CO1FBQ3pDLE1BQU0sRUFBRXVGLE1BQU0sRUFBRSxHQUNkL0UsbUJBQU9BLENBQUMseUZBQWU7UUFDekIrRTtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yeWFucm9zenRvY3p5L0RldmVsb3BtZW50L21haW5zdHJlZXRhaS13ZWJzaXRlL3NyYy9jbGllbnQvYXBwLWluZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vYXBwLWdsb2JhbHMnXG5pbXBvcnQgUmVhY3RET01DbGllbnQgZnJvbSAncmVhY3QtZG9tL2NsaWVudCdcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbi8vIFRPRE86IEV4cGxpY2l0bHkgaW1wb3J0IGZyb20gY2xpZW50LmJyb3dzZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCB7XG4gIGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSBhcyBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW1Ccm93c2VyLFxuICBjcmVhdGVGcm9tRmV0Y2ggYXMgY3JlYXRlRnJvbUZldGNoQnJvd3Nlcixcbn0gZnJvbSAncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCdcbmltcG9ydCB7IEhlYWRNYW5hZ2VyQ29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9saWIvaGVhZC1tYW5hZ2VyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBvblJlY292ZXJhYmxlRXJyb3IgfSBmcm9tICcuL3JlYWN0LWNsaWVudC1jYWxsYmFja3Mvb24tcmVjb3ZlcmFibGUtZXJyb3InXG5pbXBvcnQge1xuICBvbkNhdWdodEVycm9yLFxuICBvblVuY2F1Z2h0RXJyb3IsXG59IGZyb20gJy4vcmVhY3QtY2xpZW50LWNhbGxiYWNrcy9lcnJvci1ib3VuZGFyeS1jYWxsYmFja3MnXG5pbXBvcnQgeyBjYWxsU2VydmVyIH0gZnJvbSAnLi9hcHAtY2FsbC1zZXJ2ZXInXG5pbXBvcnQgeyBmaW5kU291cmNlTWFwVVJMIH0gZnJvbSAnLi9hcHAtZmluZC1zb3VyY2UtbWFwLXVybCdcbmltcG9ydCB7XG4gIHR5cGUgQXBwUm91dGVyQWN0aW9uUXVldWUsXG4gIGNyZWF0ZU11dGFibGVBY3Rpb25RdWV1ZSxcbn0gZnJvbSAnLi9jb21wb25lbnRzL2FwcC1yb3V0ZXItaW5zdGFuY2UnXG5pbXBvcnQgQXBwUm91dGVyIGZyb20gJy4vY29tcG9uZW50cy9hcHAtcm91dGVyJ1xuaW1wb3J0IHR5cGUgeyBJbml0aWFsUlNDUGF5bG9hZCB9IGZyb20gJy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci10eXBlcydcbmltcG9ydCB7IGNyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSB9IGZyb20gJy4vY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9jcmVhdGUtaW5pdGlhbC1yb3V0ZXItc3RhdGUnXG5pbXBvcnQgeyBNaXNzaW5nU2xvdENvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IHNldEFwcEJ1aWxkSWQgfSBmcm9tICcuL2FwcC1idWlsZC1pZCdcbmltcG9ydCB0eXBlIHsgU3RhdGljSW5kaWNhdG9yU3RhdGUgfSBmcm9tICcuL2Rldi9ob3QtcmVsb2FkZXIvYXBwL2hvdC1yZWxvYWRlci1hcHAnXG5pbXBvcnQgeyBjcmVhdGVJbml0aWFsUlNDUGF5bG9hZEZyb21GYWxsYmFja1ByZXJlbmRlciB9IGZyb20gJy4vZmxpZ2h0LWRhdGEtaGVscGVycydcblxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJyZWFjdC1kb20vZXhwZXJpbWVudGFsXCIgLz5cblxuY29uc3QgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtID1cbiAgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtQnJvd3NlciBhcyAodHlwZW9mIGltcG9ydCgncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudC5icm93c2VyJykpWydjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0nXVxuY29uc3QgY3JlYXRlRnJvbUZldGNoID1cbiAgY3JlYXRlRnJvbUZldGNoQnJvd3NlciBhcyAodHlwZW9mIGltcG9ydCgncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudC5icm93c2VyJykpWydjcmVhdGVGcm9tRmV0Y2gnXVxuXG5jb25zdCBhcHBFbGVtZW50OiBIVE1MRWxlbWVudCB8IERvY3VtZW50ID0gZG9jdW1lbnRcblxuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG5cbmxldCBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlcjogKHN0cmluZyB8IFVpbnQ4QXJyYXkpW10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbmxldCBpbml0aWFsU2VydmVyRGF0YVdyaXRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciB8IHVuZGVmaW5lZCA9XG4gIHVuZGVmaW5lZFxubGV0IGluaXRpYWxTZXJ2ZXJEYXRhTG9hZGVkID0gZmFsc2VcbmxldCBpbml0aWFsU2VydmVyRGF0YUZsdXNoZWQgPSBmYWxzZVxuXG5sZXQgaW5pdGlhbEZvcm1TdGF0ZURhdGE6IG51bGwgfCBhbnkgPSBudWxsXG5cbnR5cGUgRmxpZ2h0U2VnbWVudCA9XG4gIHwgW2lzQm9vdFN0cmFwOiAwXVxuICB8IFtpc05vdEJvb3RzdHJhcDogMSwgcmVzcG9uc2VQYXJ0aWFsOiBzdHJpbmddXG4gIHwgW2lzRm9ybVN0YXRlOiAyLCBmb3JtU3RhdGU6IGFueV1cbiAgfCBbaXNCaW5hcnk6IDMsIHJlc3BvbnNlQmFzZTY0UGFydGlhbDogc3RyaW5nXVxuXG50eXBlIE5leHRGbGlnaHQgPSBPbWl0PEFycmF5PEZsaWdodFNlZ21lbnQ+LCAncHVzaCc+ICYge1xuICBwdXNoOiAoc2VnOiBGbGlnaHRTZWdtZW50KSA9PiB2b2lkXG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgLy8gSWYgeW91J3JlIHdvcmtpbmcgaW4gYSBicm93c2VyIGVudmlyb25tZW50XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIC8qKlxuICAgICAqIHJlcXVlc3QgSUQsIGRldi1vbmx5XG4gICAgICovXG4gICAgX19uZXh0X3I/OiBzdHJpbmdcbiAgICBfX25leHRfZjogTmV4dEZsaWdodFxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHRTZXJ2ZXJEYXRhQ2FsbGJhY2soc2VnOiBGbGlnaHRTZWdtZW50KTogdm9pZCB7XG4gIGlmIChzZWdbMF0gPT09IDApIHtcbiAgICBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlciA9IFtdXG4gIH0gZWxzZSBpZiAoc2VnWzBdID09PSAxKSB7XG4gICAgaWYgKCFpbml0aWFsU2VydmVyRGF0YUJ1ZmZlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzZXJ2ZXIgZGF0YTogbWlzc2luZyBib290c3RyYXAgc2NyaXB0LicpXG5cbiAgICBpZiAoaW5pdGlhbFNlcnZlckRhdGFXcml0ZXIpIHtcbiAgICAgIGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoc2VnWzFdKSlcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIucHVzaChzZWdbMV0pXG4gICAgfVxuICB9IGVsc2UgaWYgKHNlZ1swXSA9PT0gMikge1xuICAgIGluaXRpYWxGb3JtU3RhdGVEYXRhID0gc2VnWzFdXG4gIH0gZWxzZSBpZiAoc2VnWzBdID09PSAzKSB7XG4gICAgaWYgKCFpbml0aWFsU2VydmVyRGF0YUJ1ZmZlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzZXJ2ZXIgZGF0YTogbWlzc2luZyBib290c3RyYXAgc2NyaXB0LicpXG5cbiAgICAvLyBEZWNvZGUgdGhlIGJhc2U2NCBzdHJpbmcgYmFjayB0byBiaW5hcnkgZGF0YS5cbiAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBhdG9iKHNlZ1sxXSlcbiAgICBjb25zdCBkZWNvZGVkQ2h1bmsgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWNvZGVkQ2h1bmtbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKVxuICAgIH1cblxuICAgIGlmIChpbml0aWFsU2VydmVyRGF0YVdyaXRlcikge1xuICAgICAgaW5pdGlhbFNlcnZlckRhdGFXcml0ZXIuZW5xdWV1ZShkZWNvZGVkQ2h1bmspXG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyLnB1c2goZGVjb2RlZENodW5rKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0cmVhbUVycm9yT3JVbmZpbmlzaGVkKGN0cjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcikge1xuICAvLyBJZiBgZGVzaXJlZFNpemVgIGlzIG51bGwsIGl0IG1lYW5zIHRoZSBzdHJlYW0gaXMgY2xvc2VkIG9yIGVycm9yZWQuIElmIGl0IGlzIGxvd2VyIHRoYW4gMCwgdGhlIHN0cmVhbSBpcyBzdGlsbCB1bmZpbmlzaGVkLlxuICByZXR1cm4gY3RyLmRlc2lyZWRTaXplID09PSBudWxsIHx8IGN0ci5kZXNpcmVkU2l6ZSA8IDBcbn1cblxuLy8gVGhlcmUgbWlnaHQgYmUgcmFjZSBjb25kaXRpb25zIGJldHdlZW4gYG5leHRTZXJ2ZXJEYXRhUmVnaXN0ZXJXcml0ZXJgIGFuZFxuLy8gYERPTUNvbnRlbnRMb2FkZWRgLiBUaGUgZm9ybWVyIHdpbGwgYmUgY2FsbGVkIHdoZW4gUmVhY3Qgc3RhcnRzIHRvIGh5ZHJhdGVcbi8vIHRoZSByb290LCB0aGUgbGF0dGVyIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIERPTSBpcyBmdWxseSBsb2FkZWQuXG4vLyBGb3Igc3RyZWFtaW5nLCB0aGUgZm9ybWVyIGlzIGNhbGxlZCBmaXJzdCBkdWUgdG8gcGFydGlhbCBoeWRyYXRpb24uXG4vLyBGb3Igbm9uLXN0cmVhbWluZywgdGhlIGxhdHRlciBjYW4gYmUgY2FsbGVkIGZpcnN0LlxuLy8gSGVuY2UsIHdlIHVzZSB0d28gdmFyaWFibGVzIGBpbml0aWFsU2VydmVyRGF0YUxvYWRlZGAgYW5kXG4vLyBgaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkYCB0byBtYWtlIHN1cmUgdGhlIHdyaXRlciB3aWxsIGJlIGNsb3NlZCBhbmRcbi8vIGBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlcmAgd2lsbCBiZSBjbGVhcmVkIGluIHRoZSByaWdodCB0aW1lLlxuZnVuY3Rpb24gbmV4dFNlcnZlckRhdGFSZWdpc3RlcldyaXRlcihjdHI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIpIHtcbiAgaWYgKGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyKSB7XG4gICAgaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIuZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICBjdHIuZW5xdWV1ZSh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/IGVuY29kZXIuZW5jb2RlKHZhbCkgOiB2YWwpXG4gICAgfSlcbiAgICBpZiAoaW5pdGlhbFNlcnZlckRhdGFMb2FkZWQgJiYgIWluaXRpYWxTZXJ2ZXJEYXRhRmx1c2hlZCkge1xuICAgICAgaWYgKGlzU3RyZWFtRXJyb3JPclVuZmluaXNoZWQoY3RyKSkge1xuICAgICAgICBjdHIuZXJyb3IoXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBjb25uZWN0aW9uIHRvIHRoZSBwYWdlIHdhcyB1bmV4cGVjdGVkbHkgY2xvc2VkLCBwb3NzaWJseSBkdWUgdG8gdGhlIHN0b3AgYnV0dG9uIGJlaW5nIGNsaWNrZWQsIGxvc3Mgb2YgV2ktRmksIG9yIGFuIHVuc3RhYmxlIGludGVybmV0IGNvbm5lY3Rpb24uJ1xuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3RyLmNsb3NlKClcbiAgICAgIH1cbiAgICAgIGluaXRpYWxTZXJ2ZXJEYXRhRmx1c2hlZCA9IHRydWVcbiAgICAgIGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgaW5pdGlhbFNlcnZlckRhdGFXcml0ZXIgPSBjdHJcbn1cblxuLy8gV2hlbiBgRE9NQ29udGVudExvYWRlZGAsIHdlIGNhbiBjbG9zZSBhbGwgcGVuZGluZyB3cml0ZXJzIHRvIGZpbmlzaCBoeWRyYXRpb24uXG5jb25zdCBET01Db250ZW50TG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaW5pdGlhbFNlcnZlckRhdGFXcml0ZXIgJiYgIWluaXRpYWxTZXJ2ZXJEYXRhRmx1c2hlZCkge1xuICAgIGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyLmNsb3NlKClcbiAgICBpbml0aWFsU2VydmVyRGF0YUZsdXNoZWQgPSB0cnVlXG4gICAgaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIgPSB1bmRlZmluZWRcbiAgfVxuICBpbml0aWFsU2VydmVyRGF0YUxvYWRlZCA9IHRydWVcbn1cblxuLy8gSXQncyBwb3NzaWJsZSB0aGF0IHRoZSBET00gaXMgYWxyZWFkeSBsb2FkZWQuXG5pZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBET01Db250ZW50TG9hZGVkLCBmYWxzZSlcbn0gZWxzZSB7XG4gIC8vIERlbGF5ZWQgaW4gbWFyY28gdGFzayB0byBlbnN1cmUgaXQncyBleGVjdXRlZCBsYXRlciB0aGFuIGh5ZHJhdGlvblxuICBzZXRUaW1lb3V0KERPTUNvbnRlbnRMb2FkZWQpXG59XG5cbmNvbnN0IG5leHRTZXJ2ZXJEYXRhTG9hZGluZ0dsb2JhbCA9IChzZWxmLl9fbmV4dF9mID0gc2VsZi5fX25leHRfZiB8fCBbXSlcblxuLy8gQ29uc3VtZSBhbGwgYnVmZmVyZWQgY2h1bmtzIGFuZCBjbGVhciB0aGUgZ2xvYmFsIGRhdGEgYXJyYXkgcmlnaHQgYWZ0ZXIgdG8gcmVsZWFzZSBtZW1vcnkuXG4vLyBPdGhlcndpc2UgaXQgd2lsbCBiZSByZXRhaW5lZCBpbmRlZmluaXRlbHkuXG5uZXh0U2VydmVyRGF0YUxvYWRpbmdHbG9iYWwuZm9yRWFjaChuZXh0U2VydmVyRGF0YUNhbGxiYWNrKVxubmV4dFNlcnZlckRhdGFMb2FkaW5nR2xvYmFsLmxlbmd0aCA9IDBcblxuLy8gUGF0Y2ggaXRzIHB1c2ggbWV0aG9kIHNvIHN1YnNlcXVlbnQgY2h1bmtzIGFyZSBoYW5kbGVkIChidXQgbm90IGFjdHVhbGx5IHB1c2hlZCB0byB0aGUgYXJyYXkpLlxubmV4dFNlcnZlckRhdGFMb2FkaW5nR2xvYmFsLnB1c2ggPSBuZXh0U2VydmVyRGF0YUNhbGxiYWNrXG5cbmNvbnN0IHJlYWRhYmxlID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgc3RhcnQoY29udHJvbGxlcikge1xuICAgIG5leHRTZXJ2ZXJEYXRhUmVnaXN0ZXJXcml0ZXIoY29udHJvbGxlcilcbiAgfSxcbn0pXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIHJlYWRhYmxlLm5hbWUgPSAnaHlkcmF0aW9uJ1xufVxuXG5sZXQgZGVidWdDaGFubmVsOlxuICB8IHsgcmVhZGFibGU/OiBSZWFkYWJsZVN0cmVhbTsgd3JpdGFibGU/OiBXcml0YWJsZVN0cmVhbSB9XG4gIHwgdW5kZWZpbmVkXG5cbmlmIChcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICBwcm9jZXNzLmVudi5fX05FWFRfUkVBQ1RfREVCVUdfQ0hBTk5FTCAmJlxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuKSB7XG4gIGNvbnN0IHsgY3JlYXRlRGVidWdDaGFubmVsIH0gPVxuICAgIHJlcXVpcmUoJy4vZGV2L2RlYnVnLWNoYW5uZWwnKSBhcyB0eXBlb2YgaW1wb3J0KCcuL2Rldi9kZWJ1Zy1jaGFubmVsJylcblxuICBkZWJ1Z0NoYW5uZWwgPSBjcmVhdGVEZWJ1Z0NoYW5uZWwodW5kZWZpbmVkKVxufVxuXG5jb25zdCBjbGllbnRSZXN1bWVGZXRjaDogUHJvbWlzZTxSZXNwb25zZT4gfCB1bmRlZmluZWQgPVxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIHdpbmRvdy5fX05FWFRfQ0xJRU5UX1JFU1VNRVxuXG5sZXQgaW5pdGlhbFNlcnZlclJlc3BvbnNlOiBQcm9taXNlPEluaXRpYWxSU0NQYXlsb2FkPlxuaWYgKGNsaWVudFJlc3VtZUZldGNoKSB7XG4gIGluaXRpYWxTZXJ2ZXJSZXNwb25zZSA9IFByb21pc2UucmVzb2x2ZShcbiAgICBjcmVhdGVGcm9tRmV0Y2g8SW5pdGlhbFJTQ1BheWxvYWQ+KGNsaWVudFJlc3VtZUZldGNoLCB7XG4gICAgICBjYWxsU2VydmVyLFxuICAgICAgZmluZFNvdXJjZU1hcFVSTCxcbiAgICAgIGRlYnVnQ2hhbm5lbCxcbiAgICB9KVxuICApLnRoZW4oYXN5bmMgKGZhbGxiYWNrSW5pdGlhbFJTQ1BheWxvYWQpID0+XG4gICAgY3JlYXRlSW5pdGlhbFJTQ1BheWxvYWRGcm9tRmFsbGJhY2tQcmVyZW5kZXIoXG4gICAgICBhd2FpdCBjbGllbnRSZXN1bWVGZXRjaCxcbiAgICAgIGZhbGxiYWNrSW5pdGlhbFJTQ1BheWxvYWRcbiAgICApXG4gIClcbn0gZWxzZSB7XG4gIGluaXRpYWxTZXJ2ZXJSZXNwb25zZSA9IGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbTxJbml0aWFsUlNDUGF5bG9hZD4oXG4gICAgcmVhZGFibGUsXG4gICAge1xuICAgICAgY2FsbFNlcnZlcixcbiAgICAgIGZpbmRTb3VyY2VNYXBVUkwsXG4gICAgICBkZWJ1Z0NoYW5uZWwsXG4gICAgICBzdGFydFRpbWU6IDAsXG4gICAgfVxuICApXG59XG5cbmZ1bmN0aW9uIFNlcnZlclJvb3Qoe1xuICBpbml0aWFsUlNDUGF5bG9hZCxcbiAgYWN0aW9uUXVldWUsXG4gIHdlYlNvY2tldCxcbiAgc3RhdGljSW5kaWNhdG9yU3RhdGUsXG59OiB7XG4gIGluaXRpYWxSU0NQYXlsb2FkOiBJbml0aWFsUlNDUGF5bG9hZFxuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWVcbiAgd2ViU29ja2V0OiBXZWJTb2NrZXQgfCB1bmRlZmluZWRcbiAgc3RhdGljSW5kaWNhdG9yU3RhdGU6IFN0YXRpY0luZGljYXRvclN0YXRlIHwgdW5kZWZpbmVkXG59KTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgY29uc3Qgcm91dGVyID0gKFxuICAgIDxBcHBSb3V0ZXJcbiAgICAgIGFjdGlvblF1ZXVlPXthY3Rpb25RdWV1ZX1cbiAgICAgIGdsb2JhbEVycm9yU3RhdGU9e2luaXRpYWxSU0NQYXlsb2FkLkd9XG4gICAgICB3ZWJTb2NrZXQ9e3dlYlNvY2tldH1cbiAgICAgIHN0YXRpY0luZGljYXRvclN0YXRlPXtzdGF0aWNJbmRpY2F0b3JTdGF0ZX1cbiAgICAvPlxuICApXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGluaXRpYWxSU0NQYXlsb2FkLm0pIHtcbiAgICAvLyBXZSBwcm92aWRlIG1pc3Npbmcgc2xvdCBpbmZvcm1hdGlvbiBpbiBhIGNvbnRleHQgcHJvdmlkZXIgb25seSBkdXJpbmcgZGV2ZWxvcG1lbnRcbiAgICAvLyBhcyB3ZSBsb2cgc29tZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBtaXNzaW5nIHNsb3RzIGluIHRoZSBjb25zb2xlLlxuICAgIHJldHVybiAoXG4gICAgICA8TWlzc2luZ1Nsb3RDb250ZXh0IHZhbHVlPXtpbml0aWFsUlNDUGF5bG9hZC5tfT5cbiAgICAgICAge3JvdXRlcn1cbiAgICAgIDwvTWlzc2luZ1Nsb3RDb250ZXh0PlxuICAgIClcbiAgfVxuXG4gIHJldHVybiByb3V0ZXJcbn1cblxuY29uc3QgU3RyaWN0TW9kZUlmRW5hYmxlZCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9TVFJJQ1RfTU9ERV9BUFBcbiAgPyBSZWFjdC5TdHJpY3RNb2RlXG4gIDogUmVhY3QuRnJhZ21lbnRcblxuZnVuY3Rpb24gUm9vdCh7IGNoaWxkcmVuIH06IFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPHt9Pikge1xuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RFU1RfTU9ERSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICB3aW5kb3cuX19ORVhUX0hZRFJBVEVEID0gdHJ1ZVxuICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRF9BVCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICB3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCPy4oKVxuICAgIH0sIFtdKVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbmNvbnN0IGVuYWJsZVRyYW5zaXRpb25JbmRpY2F0b3IgPSBwcm9jZXNzLmVudi5fX05FWFRfVFJBTlNJVElPTl9JTkRJQ0FUT1JcblxuZnVuY3Rpb24gbm9EZWZhdWx0VHJhbnNpdGlvbkluZGljYXRvcigpIHtcbiAgcmV0dXJuICgpID0+IHt9XG59XG5cbmNvbnN0IHJlYWN0Um9vdE9wdGlvbnM6IFJlYWN0RE9NQ2xpZW50LlJvb3RPcHRpb25zID0ge1xuICBvbkRlZmF1bHRUcmFuc2l0aW9uSW5kaWNhdG9yOiBlbmFibGVUcmFuc2l0aW9uSW5kaWNhdG9yXG4gICAgPyAvLyBUT0RPOiBDb21wb3NlIGRlZmF1bHQgd2l0aCB1c2VyLWNvbmZpZ3VyZWFibGUgKGUuZy4gbnByb2dyZXNzKVxuICAgICAgdW5kZWZpbmVkXG4gICAgOiBub0RlZmF1bHRUcmFuc2l0aW9uSW5kaWNhdG9yLFxuICBvblJlY292ZXJhYmxlRXJyb3IsXG4gIG9uQ2F1Z2h0RXJyb3IsXG4gIG9uVW5jYXVnaHRFcnJvcixcbn1cblxuZXhwb3J0IHR5cGUgQ2xpZW50SW5zdHJ1bWVudGF0aW9uSG9va3MgPSB7XG4gIG9uUm91dGVyVHJhbnNpdGlvblN0YXJ0PzogKFxuICAgIHVybDogc3RyaW5nLFxuICAgIG5hdmlnYXRpb25UeXBlOiAncHVzaCcgfCAncmVwbGFjZScgfCAndHJhdmVyc2UnXG4gICkgPT4gdm9pZFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaHlkcmF0ZShcbiAgaW5zdHJ1bWVudGF0aW9uSG9va3M6IENsaWVudEluc3RydW1lbnRhdGlvbkhvb2tzIHwgbnVsbCxcbiAgYXNzZXRQcmVmaXg6IHN0cmluZ1xuKSB7XG4gIGxldCBzdGF0aWNJbmRpY2F0b3JTdGF0ZTogU3RhdGljSW5kaWNhdG9yU3RhdGUgfCB1bmRlZmluZWRcbiAgbGV0IHdlYlNvY2tldDogV2ViU29ja2V0IHwgdW5kZWZpbmVkXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCB7IGNyZWF0ZVdlYlNvY2tldCB9ID1cbiAgICAgIHJlcXVpcmUoJy4vZGV2L2hvdC1yZWxvYWRlci9hcHAvd2ViLXNvY2tldCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4vZGV2L2hvdC1yZWxvYWRlci9hcHAvd2ViLXNvY2tldCcpXG5cbiAgICBzdGF0aWNJbmRpY2F0b3JTdGF0ZSA9IHsgcGF0aG5hbWU6IG51bGwsIGFwcElzck1hbmlmZXN0OiBudWxsIH1cbiAgICB3ZWJTb2NrZXQgPSBjcmVhdGVXZWJTb2NrZXQoYXNzZXRQcmVmaXgsIHN0YXRpY0luZGljYXRvclN0YXRlKVxuICB9XG4gIGNvbnN0IGluaXRpYWxSU0NQYXlsb2FkID0gYXdhaXQgaW5pdGlhbFNlcnZlclJlc3BvbnNlXG4gIC8vIHNldEFwcEJ1aWxkSWQgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UsIGR1cmluZyBKUyBpbml0aWFsaXphdGlvblxuICAvLyBhbmQgYmVmb3JlIGFueSBjb21wb25lbnRzIGhhdmUgaHlkcmF0ZWQuXG4gIHNldEFwcEJ1aWxkSWQoaW5pdGlhbFJTQ1BheWxvYWQuYilcblxuICBjb25zdCBpbml0aWFsVGltZXN0YW1wID0gRGF0ZS5ub3coKVxuICBjb25zdCBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWUgPSBjcmVhdGVNdXRhYmxlQWN0aW9uUXVldWUoXG4gICAgY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlKHtcbiAgICAgIG5hdmlnYXRlZEF0OiBpbml0aWFsVGltZXN0YW1wLFxuICAgICAgaW5pdGlhbEZsaWdodERhdGE6IGluaXRpYWxSU0NQYXlsb2FkLmYsXG4gICAgICBpbml0aWFsQ2Fub25pY2FsVXJsUGFydHM6IGluaXRpYWxSU0NQYXlsb2FkLmMsXG4gICAgICBpbml0aWFsUmVuZGVyZWRTZWFyY2g6IGluaXRpYWxSU0NQYXlsb2FkLnEsXG4gICAgICBsb2NhdGlvbjogd2luZG93LmxvY2F0aW9uLFxuICAgIH0pLFxuICAgIGluc3RydW1lbnRhdGlvbkhvb2tzXG4gIClcblxuICBjb25zdCByZWFjdEVsID0gKFxuICAgIDxTdHJpY3RNb2RlSWZFbmFibGVkPlxuICAgICAgPEhlYWRNYW5hZ2VyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17eyBhcHBEaXI6IHRydWUgfX0+XG4gICAgICAgIDxSb290PlxuICAgICAgICAgIDxTZXJ2ZXJSb290XG4gICAgICAgICAgICBpbml0aWFsUlNDUGF5bG9hZD17aW5pdGlhbFJTQ1BheWxvYWR9XG4gICAgICAgICAgICBhY3Rpb25RdWV1ZT17YWN0aW9uUXVldWV9XG4gICAgICAgICAgICB3ZWJTb2NrZXQ9e3dlYlNvY2tldH1cbiAgICAgICAgICAgIHN0YXRpY0luZGljYXRvclN0YXRlPXtzdGF0aWNJbmRpY2F0b3JTdGF0ZX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L1Jvb3Q+XG4gICAgICA8L0hlYWRNYW5hZ2VyQ29udGV4dC5Qcm92aWRlcj5cbiAgICA8L1N0cmljdE1vZGVJZkVuYWJsZWQ+XG4gIClcblxuICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmlkID09PSAnX19uZXh0X2Vycm9yX18nKSB7XG4gICAgbGV0IGVsZW1lbnQgPSByZWFjdEVsXG4gICAgLy8gU2VydmVyIHJlbmRlcmluZyBmYWlsZWQsIGZhbGwgYmFjayB0byBjbGllbnQtc2lkZSByZW5kZXJpbmdcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc3QgeyBSb290TGV2ZWxEZXZPdmVybGF5RWxlbWVudCB9ID1cbiAgICAgICAgcmVxdWlyZSgnLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2NsaWVudC1lbnRyeScpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9jbGllbnQtZW50cnknKVxuXG4gICAgICAvLyBOb3RlIHRoaXMgd29uJ3QgY2F1c2UgaHlkcmF0aW9uIG1pc21hdGNoIGJlY2F1c2Ugd2UgYXJlIGRvaW5nIENTUiB3L28gaHlkcmF0aW9uXG4gICAgICBlbGVtZW50ID0gKFxuICAgICAgICA8Um9vdExldmVsRGV2T3ZlcmxheUVsZW1lbnQ+e2VsZW1lbnR9PC9Sb290TGV2ZWxEZXZPdmVybGF5RWxlbWVudD5cbiAgICAgIClcbiAgICB9XG5cbiAgICBSZWFjdERPTUNsaWVudC5jcmVhdGVSb290KGFwcEVsZW1lbnQsIHJlYWN0Um9vdE9wdGlvbnMpLnJlbmRlcihlbGVtZW50KVxuICB9IGVsc2Uge1xuICAgIFJlYWN0LnN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICBSZWFjdERPTUNsaWVudC5oeWRyYXRlUm9vdChhcHBFbGVtZW50LCByZWFjdEVsLCB7XG4gICAgICAgIC4uLnJlYWN0Um9vdE9wdGlvbnMsXG4gICAgICAgIGZvcm1TdGF0ZTogaW5pdGlhbEZvcm1TdGF0ZURhdGEsXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBUT0RPLUFQUDogUmVtb3ZlIHRoaXMgbG9naWMgd2hlbiBGbG9hdCBoYXMgR0MgYnVpbHQtaW4gaW4gZGV2ZWxvcG1lbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgeyBsaW5rR2MgfSA9XG4gICAgICByZXF1aXJlKCcuL2FwcC1saW5rLWdjJykgYXMgdHlwZW9mIGltcG9ydCgnLi9hcHAtbGluay1nYycpXG4gICAgbGlua0djKClcbiAgfVxufVxuIl0sIm5hbWVzIjpbImh5ZHJhdGUiLCJjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0iLCJjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW1Ccm93c2VyIiwiY3JlYXRlRnJvbUZldGNoIiwiY3JlYXRlRnJvbUZldGNoQnJvd3NlciIsImFwcEVsZW1lbnQiLCJkb2N1bWVudCIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyIiwidW5kZWZpbmVkIiwiaW5pdGlhbFNlcnZlckRhdGFXcml0ZXIiLCJpbml0aWFsU2VydmVyRGF0YUxvYWRlZCIsImluaXRpYWxTZXJ2ZXJEYXRhRmx1c2hlZCIsImluaXRpYWxGb3JtU3RhdGVEYXRhIiwibmV4dFNlcnZlckRhdGFDYWxsYmFjayIsInNlZyIsIkVycm9yIiwiZW5xdWV1ZSIsImVuY29kZSIsInB1c2giLCJiaW5hcnlTdHJpbmciLCJhdG9iIiwiZGVjb2RlZENodW5rIiwiVWludDhBcnJheSIsImxlbmd0aCIsImkiLCJjaGFyQ29kZUF0IiwiaXNTdHJlYW1FcnJvck9yVW5maW5pc2hlZCIsImN0ciIsImRlc2lyZWRTaXplIiwibmV4dFNlcnZlckRhdGFSZWdpc3RlcldyaXRlciIsImZvckVhY2giLCJ2YWwiLCJlcnJvciIsImNsb3NlIiwiRE9NQ29udGVudExvYWRlZCIsInJlYWR5U3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwic2V0VGltZW91dCIsIm5leHRTZXJ2ZXJEYXRhTG9hZGluZ0dsb2JhbCIsInNlbGYiLCJfX25leHRfZiIsInJlYWRhYmxlIiwiUmVhZGFibGVTdHJlYW0iLCJzdGFydCIsImNvbnRyb2xsZXIiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJuYW1lIiwiZGVidWdDaGFubmVsIiwiX19ORVhUX1JFQUNUX0RFQlVHX0NIQU5ORUwiLCJ3aW5kb3ciLCJjcmVhdGVEZWJ1Z0NoYW5uZWwiLCJyZXF1aXJlIiwiY2xpZW50UmVzdW1lRmV0Y2giLCJfX05FWFRfQ0xJRU5UX1JFU1VNRSIsImluaXRpYWxTZXJ2ZXJSZXNwb25zZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2FsbFNlcnZlciIsImZpbmRTb3VyY2VNYXBVUkwiLCJ0aGVuIiwiZmFsbGJhY2tJbml0aWFsUlNDUGF5bG9hZCIsImNyZWF0ZUluaXRpYWxSU0NQYXlsb2FkRnJvbUZhbGxiYWNrUHJlcmVuZGVyIiwic3RhcnRUaW1lIiwiU2VydmVyUm9vdCIsImluaXRpYWxSU0NQYXlsb2FkIiwiYWN0aW9uUXVldWUiLCJ3ZWJTb2NrZXQiLCJzdGF0aWNJbmRpY2F0b3JTdGF0ZSIsInJvdXRlciIsIkFwcFJvdXRlciIsImdsb2JhbEVycm9yU3RhdGUiLCJHIiwibSIsIk1pc3NpbmdTbG90Q29udGV4dCIsInZhbHVlIiwiU3RyaWN0TW9kZUlmRW5hYmxlZCIsIl9fTkVYVF9TVFJJQ1RfTU9ERV9BUFAiLCJSZWFjdCIsIlN0cmljdE1vZGUiLCJGcmFnbWVudCIsIlJvb3QiLCJjaGlsZHJlbiIsIl9fTkVYVF9URVNUX01PREUiLCJ1c2VFZmZlY3QiLCJfX05FWFRfSFlEUkFURUQiLCJfX05FWFRfSFlEUkFURURfQVQiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIl9fTkVYVF9IWURSQVRFRF9DQiIsImVuYWJsZVRyYW5zaXRpb25JbmRpY2F0b3IiLCJfX05FWFRfVFJBTlNJVElPTl9JTkRJQ0FUT1IiLCJub0RlZmF1bHRUcmFuc2l0aW9uSW5kaWNhdG9yIiwicmVhY3RSb290T3B0aW9ucyIsIm9uRGVmYXVsdFRyYW5zaXRpb25JbmRpY2F0b3IiLCJvblJlY292ZXJhYmxlRXJyb3IiLCJvbkNhdWdodEVycm9yIiwib25VbmNhdWdodEVycm9yIiwiaW5zdHJ1bWVudGF0aW9uSG9va3MiLCJhc3NldFByZWZpeCIsImNyZWF0ZVdlYlNvY2tldCIsInBhdGhuYW1lIiwiYXBwSXNyTWFuaWZlc3QiLCJzZXRBcHBCdWlsZElkIiwiYiIsImluaXRpYWxUaW1lc3RhbXAiLCJEYXRlIiwiY3JlYXRlTXV0YWJsZUFjdGlvblF1ZXVlIiwiY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlIiwibmF2aWdhdGVkQXQiLCJpbml0aWFsRmxpZ2h0RGF0YSIsImYiLCJpbml0aWFsQ2Fub25pY2FsVXJsUGFydHMiLCJjIiwiaW5pdGlhbFJlbmRlcmVkU2VhcmNoIiwicSIsImxvY2F0aW9uIiwicmVhY3RFbCIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsIlByb3ZpZGVyIiwiYXBwRGlyIiwiZG9jdW1lbnRFbGVtZW50IiwiaWQiLCJlbGVtZW50IiwiUm9vdExldmVsRGV2T3ZlcmxheUVsZW1lbnQiLCJSZWFjdERPTUNsaWVudCIsImNyZWF0ZVJvb3QiLCJyZW5kZXIiLCJzdGFydFRyYW5zaXRpb24iLCJoeWRyYXRlUm9vdCIsImZvcm1TdGF0ZSIsImxpbmtHYyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-link-gc.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/app-link-gc.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"linkGc\", ({\n    enumerable: true,\n    get: function() {\n        return linkGc;\n    }\n}));\nfunction linkGc() {\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (true) {\n        const callback = (mutationList)=>{\n            for (const mutation of mutationList){\n                if (mutation.type === 'childList') {\n                    for (const node of mutation.addedNodes){\n                        if ('tagName' in node && node.tagName === 'LINK') {\n                            const link = node;\n                            if (link.dataset.precedence?.startsWith('next')) {\n                                const href = link.getAttribute('href');\n                                if (href) {\n                                    const [resource, version] = href.split('?v=', 2);\n                                    if (version) {\n                                        const currentOrigin = window.location.origin;\n                                        const allLinks = [\n                                            ...document.querySelectorAll('link[href^=\"' + resource + '\"]'),\n                                            // It's possible that the resource is a full URL or only pathname,\n                                            // so we need to remove the alternative href as well.\n                                            ...document.querySelectorAll('link[href^=\"' + (resource.startsWith(currentOrigin) ? resource.slice(currentOrigin.length) : currentOrigin + resource) + '\"]')\n                                        ];\n                                        for (const otherLink of allLinks){\n                                            if (otherLink.dataset.precedence?.startsWith('next')) {\n                                                const otherHref = otherLink.getAttribute('href');\n                                                if (otherHref) {\n                                                    const [, otherVersion] = otherHref.split('?v=', 2);\n                                                    if (!otherVersion || +otherVersion < +version) {\n                                                        // Delay the removal of the stylesheet to avoid FOUC\n                                                        // caused by `@font-face` rules, as they seem to be\n                                                        // a couple of ticks delayed between the old and new\n                                                        // styles being swapped even if the font is cached.\n                                                        setTimeout(()=>{\n                                                            otherLink.remove();\n                                                        }, 5);\n                                                        const preloadLink = document.querySelector(`link[rel=\"preload\"][as=\"style\"][href=\"${otherHref}\"]`);\n                                                        if (preloadLink) {\n                                                            preloadLink.remove();\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        // Create an observer instance linked to the callback function\n        const observer = new MutationObserver(callback);\n        observer.observe(document.head, {\n            childList: true\n        });\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-link-gc.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1saW5rLWdjLmpzIiwibWFwcGluZ3MiOiI7Ozs7MENBQWdCQTs7O2VBQUFBOzs7QUFBVCxTQUFTQTtJQUNkLHlFQUF5RTtJQUN6RSxJQUFJQyxJQUFvQixFQUFtQjtRQUN6QyxNQUFNRyxXQUFXLENBQUNDO1lBQ2hCLEtBQUssTUFBTUMsWUFBWUQsYUFBYztnQkFDbkMsSUFBSUMsU0FBU0MsSUFBSSxLQUFLLGFBQWE7b0JBQ2pDLEtBQUssTUFBTUMsUUFBUUYsU0FBU0csVUFBVSxDQUFFO3dCQUN0QyxJQUNFLGFBQWFELFFBQ1pBLEtBQXlCRSxPQUFPLEtBQUssUUFDdEM7NEJBQ0EsTUFBTUMsT0FBT0g7NEJBQ2IsSUFBSUcsS0FBS0MsT0FBTyxDQUFDQyxVQUFVLEVBQUVDLFdBQVcsU0FBUztnQ0FDL0MsTUFBTUMsT0FBT0osS0FBS0ssWUFBWSxDQUFDO2dDQUMvQixJQUFJRCxNQUFNO29DQUNSLE1BQU0sQ0FBQ0UsVUFBVUMsUUFBUSxHQUFHSCxLQUFLSSxLQUFLLENBQUMsT0FBTztvQ0FDOUMsSUFBSUQsU0FBUzt3Q0FDWCxNQUFNRSxnQkFBZ0JDLE9BQU9DLFFBQVEsQ0FBQ0MsTUFBTTt3Q0FDNUMsTUFBTUMsV0FBVzsrQ0FDWkMsU0FBU0MsZ0JBQWdCLENBQzFCLGlCQUFpQlQsV0FBVzs0Q0FFOUIsa0VBQWtFOzRDQUNsRSxxREFBcUQ7K0NBQ2xEUSxTQUFTQyxnQkFBZ0IsQ0FDMUIsaUJBQ0dULENBQUFBLFNBQVNILFVBQVUsQ0FBQ00saUJBQ2pCSCxTQUFTVSxLQUFLLENBQUNQLGNBQWNRLE1BQU0sSUFDbkNSLGdCQUFnQkgsUUFBQUEsQ0FBTyxHQUMzQjt5Q0FFTDt3Q0FFRCxLQUFLLE1BQU1ZLGFBQWFMLFNBQVU7NENBQ2hDLElBQUlLLFVBQVVqQixPQUFPLENBQUNDLFVBQVUsRUFBRUMsV0FBVyxTQUFTO2dEQUNwRCxNQUFNZ0IsWUFBWUQsVUFBVWIsWUFBWSxDQUFDO2dEQUN6QyxJQUFJYyxXQUFXO29EQUNiLE1BQU0sR0FBR0MsYUFBYSxHQUFHRCxVQUFVWCxLQUFLLENBQUMsT0FBTztvREFDaEQsSUFBSSxDQUFDWSxnQkFBZ0IsQ0FBQ0EsZUFBZSxDQUFDYixTQUFTO3dEQUM3QyxvREFBb0Q7d0RBQ3BELG1EQUFtRDt3REFDbkQsb0RBQW9EO3dEQUNwRCxtREFBbUQ7d0RBQ25EYyxXQUFXOzREQUNUSCxVQUFVSSxNQUFNO3dEQUNsQixHQUFHO3dEQUNILE1BQU1DLGNBQWNULFNBQVNVLGFBQWEsQ0FDeEMsQ0FBQyxzQ0FBc0MsRUFBRUwsVUFBVSxFQUFFLENBQUM7d0RBRXhELElBQUlJLGFBQWE7NERBQ2ZBLFlBQVlELE1BQU07d0RBQ3BCO29EQUNGO2dEQUNGOzRDQUNGO3dDQUNGO29DQUNGO2dDQUNGOzRCQUNGO3dCQUNGO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLDhEQUE4RDtRQUM5RCxNQUFNRyxXQUFXLElBQUlDLGlCQUFpQmpDO1FBQ3RDZ0MsU0FBU0UsT0FBTyxDQUFDYixTQUFTYyxJQUFJLEVBQUU7WUFDOUJDLFdBQVc7UUFDYjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yeWFucm9zenRvY3p5L0RldmVsb3BtZW50L21haW5zdHJlZXRhaS13ZWJzaXRlL3NyYy9jbGllbnQvYXBwLWxpbmstZ2MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGxpbmtHYygpIHtcbiAgLy8gVE9ETy1BUFA6IFJlbW92ZSB0aGlzIGxvZ2ljIHdoZW4gRmxvYXQgaGFzIEdDIGJ1aWx0LWluIGluIGRldmVsb3BtZW50LlxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gKG11dGF0aW9uTGlzdDogTXV0YXRpb25SZWNvcmRbXSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbkxpc3QpIHtcbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG11dGF0aW9uLmFkZGVkTm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgJ3RhZ05hbWUnIGluIG5vZGUgJiZcbiAgICAgICAgICAgICAgKG5vZGUgYXMgSFRNTExpbmtFbGVtZW50KS50YWdOYW1lID09PSAnTElOSydcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb25zdCBsaW5rID0gbm9kZSBhcyBIVE1MTGlua0VsZW1lbnRcbiAgICAgICAgICAgICAgaWYgKGxpbmsuZGF0YXNldC5wcmVjZWRlbmNlPy5zdGFydHNXaXRoKCduZXh0JykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBocmVmID0gbGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKVxuICAgICAgICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBbcmVzb3VyY2UsIHZlcnNpb25dID0gaHJlZi5zcGxpdCgnP3Y9JywgMilcbiAgICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRPcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbExpbmtzID0gW1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlua1tocmVmXj1cIicgKyByZXNvdXJjZSArICdcIl0nXG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHJlc291cmNlIGlzIGEgZnVsbCBVUkwgb3Igb25seSBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgYWx0ZXJuYXRpdmUgaHJlZiBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgICAgICAgIC4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlua1tocmVmXj1cIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzb3VyY2Uuc3RhcnRzV2l0aChjdXJyZW50T3JpZ2luKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzb3VyY2Uuc2xpY2UoY3VycmVudE9yaWdpbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50T3JpZ2luICsgcmVzb3VyY2UpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiXSdcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBdIGFzIEhUTUxMaW5rRWxlbWVudFtdXG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBvdGhlckxpbmsgb2YgYWxsTGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJMaW5rLmRhdGFzZXQucHJlY2VkZW5jZT8uc3RhcnRzV2l0aCgnbmV4dCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckhyZWYgPSBvdGhlckxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgWywgb3RoZXJWZXJzaW9uXSA9IG90aGVySHJlZi5zcGxpdCgnP3Y9JywgMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlclZlcnNpb24gfHwgK290aGVyVmVyc2lvbiA8ICt2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsYXkgdGhlIHJlbW92YWwgb2YgdGhlIHN0eWxlc2hlZXQgdG8gYXZvaWQgRk9VQ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhdXNlZCBieSBgQGZvbnQtZmFjZWAgcnVsZXMsIGFzIHRoZXkgc2VlbSB0byBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgY291cGxlIG9mIHRpY2tzIGRlbGF5ZWQgYmV0d2VlbiB0aGUgb2xkIGFuZCBuZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXMgYmVpbmcgc3dhcHBlZCBldmVuIGlmIHRoZSBmb250IGlzIGNhY2hlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyTGluay5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlbG9hZExpbmsgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGxpbmtbcmVsPVwicHJlbG9hZFwiXVthcz1cInN0eWxlXCJdW2hyZWY9XCIke290aGVySHJlZn1cIl1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVsb2FkTGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlbG9hZExpbmsucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgbGlua2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5oZWFkLCB7XG4gICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgfSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbImxpbmtHYyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImNhbGxiYWNrIiwibXV0YXRpb25MaXN0IiwibXV0YXRpb24iLCJ0eXBlIiwibm9kZSIsImFkZGVkTm9kZXMiLCJ0YWdOYW1lIiwibGluayIsImRhdGFzZXQiLCJwcmVjZWRlbmNlIiwic3RhcnRzV2l0aCIsImhyZWYiLCJnZXRBdHRyaWJ1dGUiLCJyZXNvdXJjZSIsInZlcnNpb24iLCJzcGxpdCIsImN1cnJlbnRPcmlnaW4iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImFsbExpbmtzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwic2xpY2UiLCJsZW5ndGgiLCJvdGhlckxpbmsiLCJvdGhlckhyZWYiLCJvdGhlclZlcnNpb24iLCJzZXRUaW1lb3V0IiwicmVtb3ZlIiwicHJlbG9hZExpbmsiLCJxdWVyeVNlbGVjdG9yIiwib2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSIsImhlYWQiLCJjaGlsZExpc3QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-link-gc.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/app-router-instance.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router-instance.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createMutableActionQueue: function() {\n        return createMutableActionQueue;\n    },\n    dispatchNavigateAction: function() {\n        return dispatchNavigateAction;\n    },\n    dispatchTraverseAction: function() {\n        return dispatchTraverseAction;\n    },\n    getCurrentAppRouterState: function() {\n        return getCurrentAppRouterState;\n    },\n    publicAppRouterInstance: function() {\n        return publicAppRouterInstance;\n    }\n});\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _routerreducer = __webpack_require__(/*! ./router-reducer/router-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer.js\");\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _isthenable = __webpack_require__(/*! ../../shared/lib/is-thenable */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/is-thenable.js\");\nconst _types = __webpack_require__(/*! ./segment-cache/types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache/types.js\");\nconst _prefetch = __webpack_require__(/*! ./segment-cache/prefetch */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache/prefetch.js\");\nconst _useactionqueue = __webpack_require__(/*! ./use-action-queue */ \"(app-pages-browser)/./node_modules/next/dist/client/components/use-action-queue.js\");\nconst _addbasepath = __webpack_require__(/*! ../add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _approuterutils = __webpack_require__(/*! ./app-router-utils */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-utils.js\");\nconst _links = __webpack_require__(/*! ./links */ \"(app-pages-browser)/./node_modules/next/dist/client/components/links.js\");\nfunction runRemainingActions(actionQueue, setState) {\n    if (actionQueue.pending !== null) {\n        actionQueue.pending = actionQueue.pending.next;\n        if (actionQueue.pending !== null) {\n            runAction({\n                actionQueue,\n                action: actionQueue.pending,\n                setState\n            });\n        }\n    } else {\n        // Check for refresh when pending is already null\n        // This handles the case where a discarded server action completes\n        // after the navigation has already finished and the queue is empty\n        if (actionQueue.needsRefresh) {\n            actionQueue.needsRefresh = false;\n            actionQueue.dispatch({\n                type: _routerreducertypes.ACTION_REFRESH\n            }, setState);\n        }\n    }\n}\nasync function runAction({ actionQueue, action, setState }) {\n    const prevState = actionQueue.state;\n    actionQueue.pending = action;\n    const payload = action.payload;\n    const actionResult = actionQueue.action(prevState, payload);\n    function handleResult(nextState) {\n        // if we discarded this action, the state should also be discarded\n        if (action.discarded) {\n            // Check if the discarded server action revalidated data\n            if (action.payload.type === _routerreducertypes.ACTION_SERVER_ACTION && action.payload.didRevalidate) {\n                // The server action was discarded but it revalidated data,\n                // mark that we need to refresh after all actions complete\n                actionQueue.needsRefresh = true;\n            }\n            // Still need to run remaining actions even for discarded actions\n            // to potentially trigger the refresh\n            runRemainingActions(actionQueue, setState);\n            return;\n        }\n        actionQueue.state = nextState;\n        runRemainingActions(actionQueue, setState);\n        action.resolve(nextState);\n    }\n    // if the action is a promise, set up a callback to resolve it\n    if ((0, _isthenable.isThenable)(actionResult)) {\n        actionResult.then(handleResult, (err)=>{\n            runRemainingActions(actionQueue, setState);\n            action.reject(err);\n        });\n    } else {\n        handleResult(actionResult);\n    }\n}\nfunction dispatchAction(actionQueue, payload, setState) {\n    let resolvers = {\n        resolve: setState,\n        reject: ()=>{}\n    };\n    // most of the action types are async with the exception of restore\n    // it's important that restore is handled quickly since it's fired on the popstate event\n    // and we don't want to add any delay on a back/forward nav\n    // this only creates a promise for the async actions\n    if (payload.type !== _routerreducertypes.ACTION_RESTORE) {\n        // Create the promise and assign the resolvers to the object.\n        const deferredPromise = new Promise((resolve, reject)=>{\n            resolvers = {\n                resolve,\n                reject\n            };\n        });\n        (0, _react.startTransition)(()=>{\n            // we immediately notify React of the pending promise -- the resolver is attached to the action node\n            // and will be called when the associated action promise resolves\n            setState(deferredPromise);\n        });\n    }\n    const newAction = {\n        payload,\n        next: null,\n        resolve: resolvers.resolve,\n        reject: resolvers.reject\n    };\n    // Check if the queue is empty\n    if (actionQueue.pending === null) {\n        // The queue is empty, so add the action and start it immediately\n        // Mark this action as the last in the queue\n        actionQueue.last = newAction;\n        runAction({\n            actionQueue,\n            action: newAction,\n            setState\n        });\n    } else if (payload.type === _routerreducertypes.ACTION_NAVIGATE || payload.type === _routerreducertypes.ACTION_RESTORE) {\n        // Navigations (including back/forward) take priority over any pending actions.\n        // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n        actionQueue.pending.discarded = true;\n        // The rest of the current queue should still execute after this navigation.\n        // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n        newAction.next = actionQueue.pending.next;\n        runAction({\n            actionQueue,\n            action: newAction,\n            setState\n        });\n    } else {\n        // The queue is not empty, so add the action to the end of the queue\n        // It will be started by runRemainingActions after the previous action finishes\n        if (actionQueue.last !== null) {\n            actionQueue.last.next = newAction;\n        }\n        actionQueue.last = newAction;\n    }\n}\nlet globalActionQueue = null;\nfunction createMutableActionQueue(initialState, instrumentationHooks) {\n    const actionQueue = {\n        state: initialState,\n        dispatch: (payload, setState)=>dispatchAction(actionQueue, payload, setState),\n        action: async (state, action)=>{\n            const result = (0, _routerreducer.reducer)(state, action);\n            return result;\n        },\n        pending: null,\n        last: null,\n        onRouterTransitionStart: instrumentationHooks !== null && typeof instrumentationHooks.onRouterTransitionStart === 'function' ? instrumentationHooks.onRouterTransitionStart : null\n    };\n    if (true) {\n        // The action queue is lazily created on hydration, but after that point\n        // it doesn't change. So we can store it in a global rather than pass\n        // it around everywhere via props/context.\n        if (globalActionQueue !== null) {\n            throw Object.defineProperty(new Error('Internal Next.js Error: createMutableActionQueue was called more ' + 'than once'), \"__NEXT_ERROR_CODE\", {\n                value: \"E624\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        globalActionQueue = actionQueue;\n    }\n    return actionQueue;\n}\nfunction getCurrentAppRouterState() {\n    return globalActionQueue !== null ? globalActionQueue.state : null;\n}\nfunction getAppRouterActionQueue() {\n    if (globalActionQueue === null) {\n        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E668\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return globalActionQueue;\n}\nfunction getProfilingHookForOnNavigationStart() {\n    if (globalActionQueue !== null) {\n        return globalActionQueue.onRouterTransitionStart;\n    }\n    return null;\n}\nfunction dispatchNavigateAction(href, navigateType, shouldScroll, linkInstanceRef) {\n    // TODO: This stuff could just go into the reducer. Leaving as-is for now\n    // since we're about to rewrite all the router reducer stuff anyway.\n    const url = new URL((0, _addbasepath.addBasePath)(href), location.href);\n    if (false) {}\n    (0, _links.setLinkForCurrentNavigation)(linkInstanceRef);\n    const onRouterTransitionStart = getProfilingHookForOnNavigationStart();\n    if (onRouterTransitionStart !== null) {\n        onRouterTransitionStart(href, navigateType);\n    }\n    (0, _useactionqueue.dispatchAppRouterAction)({\n        type: _routerreducertypes.ACTION_NAVIGATE,\n        url,\n        isExternalUrl: (0, _approuterutils.isExternalURL)(url),\n        locationSearch: location.search,\n        shouldScroll,\n        navigateType\n    });\n}\nfunction dispatchTraverseAction(href, historyState) {\n    const onRouterTransitionStart = getProfilingHookForOnNavigationStart();\n    if (onRouterTransitionStart !== null) {\n        onRouterTransitionStart(href, 'traverse');\n    }\n    (0, _useactionqueue.dispatchAppRouterAction)({\n        type: _routerreducertypes.ACTION_RESTORE,\n        url: new URL(href),\n        historyState\n    });\n}\nconst publicAppRouterInstance = {\n    back: ()=>window.history.back(),\n    forward: ()=>window.history.forward(),\n    prefetch: // data in the router reducer state; it writes into a global mutable\n    // cache. So we don't need to dispatch an action.\n    (href, options)=>{\n        const actionQueue = getAppRouterActionQueue();\n        const prefetchKind = options?.kind ?? _routerreducertypes.PrefetchKind.AUTO;\n        // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n        // This will be possible when we update its API to not take a PrefetchKind.\n        let fetchStrategy;\n        switch(prefetchKind){\n            case _routerreducertypes.PrefetchKind.AUTO:\n                {\n                    // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n                    fetchStrategy = _types.FetchStrategy.PPR;\n                    break;\n                }\n            case _routerreducertypes.PrefetchKind.FULL:\n                {\n                    fetchStrategy = _types.FetchStrategy.Full;\n                    break;\n                }\n            default:\n                {\n                    prefetchKind;\n                    // Despite typescript thinking that this can't happen,\n                    // we might get an unexpected value from user code.\n                    // We don't know what they want, but we know they want a prefetch,\n                    // so use the default.\n                    fetchStrategy = _types.FetchStrategy.PPR;\n                }\n        }\n        (0, _prefetch.prefetch)(href, actionQueue.state.nextUrl, actionQueue.state.tree, fetchStrategy, options?.onInvalidate ?? null);\n    },\n    replace: (href, options)=>{\n        (0, _react.startTransition)(()=>{\n            dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null);\n        });\n    },\n    push: (href, options)=>{\n        (0, _react.startTransition)(()=>{\n            dispatchNavigateAction(href, 'push', options?.scroll ?? true, null);\n        });\n    },\n    refresh: ()=>{\n        (0, _react.startTransition)(()=>{\n            (0, _useactionqueue.dispatchAppRouterAction)({\n                type: _routerreducertypes.ACTION_REFRESH\n            });\n        });\n    },\n    hmrRefresh: ()=>{\n        if (false) {} else {\n            (0, _react.startTransition)(()=>{\n                (0, _useactionqueue.dispatchAppRouterAction)({\n                    type: _routerreducertypes.ACTION_HMR_REFRESH\n                });\n            });\n        }\n    }\n};\n// Exists for debugging purposes. Don't use in application code.\nif ( true && window.next) {\n    window.next.router = publicAppRouterInstance;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router-instance.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1pbnN0YW5jZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFtTmdCQSx3QkFBd0I7ZUFBeEJBOztJQTBEQUMsc0JBQXNCO2VBQXRCQTs7SUE4QkFDLHNCQUFzQjtlQUF0QkE7O0lBbERBQyx3QkFBd0I7ZUFBeEJBOztJQXNFSEMsdUJBQXVCO2VBQXZCQTs7O2dEQW5UTjsyQ0FDaUI7bUNBQ1E7d0NBQ0w7bUNBSXBCO3NDQUM4Qzs0Q0FDYjt5Q0FDWjs0Q0FDRTttQ0FNaUM7QUFpQy9ELFNBQVNDLG9CQUNQQyxXQUFpQyxFQUNqQ0MsUUFBOEI7SUFFOUIsSUFBSUQsWUFBWUUsT0FBTyxLQUFLLE1BQU07UUFDaENGLFlBQVlFLE9BQU8sR0FBR0YsWUFBWUUsT0FBTyxDQUFDQyxJQUFJO1FBQzlDLElBQUlILFlBQVlFLE9BQU8sS0FBSyxNQUFNO1lBQ2hDRSxVQUFVO2dCQUNSSjtnQkFDQUssUUFBUUwsWUFBWUUsT0FBTztnQkFDM0JEO1lBQ0Y7UUFDRjtJQUNGLE9BQU87UUFDTCxpREFBaUQ7UUFDakQsa0VBQWtFO1FBQ2xFLG1FQUFtRTtRQUNuRSxJQUFJRCxZQUFZTSxZQUFZLEVBQUU7WUFDNUJOLFlBQVlNLFlBQVksR0FBRztZQUMzQk4sWUFBWU8sUUFBUSxDQUFDO2dCQUFFQyxNQUFNQyxvQkFBQUEsY0FBYztZQUFDLEdBQUdSO1FBQ2pEO0lBQ0Y7QUFDRjtBQUVBLGVBQWVHLFVBQVUsRUFDdkJKLFdBQVcsRUFDWEssTUFBTSxFQUNOSixRQUFRLEVBS1Q7SUFDQyxNQUFNUyxZQUFZVixZQUFZVyxLQUFLO0lBRW5DWCxZQUFZRSxPQUFPLEdBQUdHO0lBRXRCLE1BQU1PLFVBQVVQLE9BQU9PLE9BQU87SUFDOUIsTUFBTUMsZUFBZWIsWUFBWUssTUFBTSxDQUFDSyxXQUFXRTtJQUVuRCxTQUFTRSxhQUFhQyxTQUF5QjtRQUM3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QUNDLEdBQUc7Z0JBQ25DO1FBQ0Y7UUFFQUcsQ0FBQUEsR0FBQUEsVUFBQUEsUUFBd0IsRUFDdEJqQyxNQUNBM0MsWUFBWVcsS0FBSyxDQUFDa0UsT0FBTyxFQUN6QjdFLFlBQVlXLEtBQUssQ0FBQ21FLElBQUksRUFDdEJQLGVBQ0FMLFNBQVNhLGdCQUFnQjtJQUU3QjtJQUNGQyxTQUFTLENBQUNyQyxNQUFjdUI7UUFDdEJyQyxDQUFBQSxHQUFBQSxPQUFBQSxlQUFBQSxFQUFnQjtZQUNkbEMsdUJBQXVCZ0QsTUFBTSxXQUFXdUIsU0FBU2UsVUFBVSxNQUFNO1FBQ25FO0lBQ0Y7SUFDQUMsTUFBTSxDQUFDdkMsTUFBY3VCO1FBQ25CckMsQ0FBQUEsR0FBQUEsT0FBQUEsZUFBQUEsRUFBZ0I7WUFDZGxDLHVCQUF1QmdELE1BQU0sUUFBUXVCLFNBQVNlLFVBQVUsTUFBTTtRQUNoRTtJQUNGO0lBQ0FFLFNBQVM7UUFDUHRELENBQUFBLEdBQUFBLE9BQUFBLGVBQUFBLEVBQWdCO1lBQ2QyQixDQUFBQSxHQUFBQSxnQkFBQUEsdUJBQUFBLEVBQXdCO2dCQUN0QmhELE1BQU1DLG9CQUFBQSxjQUFjO1lBQ3RCO1FBQ0Y7SUFDRjtJQUNBMkUsWUFBWTtRQUNWLElBQUlqQyxLQUFvQixFQUFvQixFQUkzQyxNQUFNO1lBQ0x0QixDQUFBQSxHQUFBQSxPQUFBQSxlQUFlLEVBQUM7Z0JBQ2QyQixDQUFBQSxHQUFBQSxnQkFBQUEsdUJBQUFBLEVBQXdCO29CQUN0QmhELE1BQU04RSxvQkFBQUEsa0JBQWtCO2dCQUMxQjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsZ0VBQWdFO0FBQ2hFLElBQUksS0FBNkIsSUFBSS9DLE9BQU9wQyxJQUFJLEVBQUU7SUFDaERvQyxPQUFPcEMsSUFBSSxDQUFDb0YsTUFBTSxHQUFHekY7QUFDdkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yeWFucm9zenRvY3p5L0RldmVsb3BtZW50L3NyYy9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLWluc3RhbmNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIHR5cGUgQXBwUm91dGVyU3RhdGUsXG4gIHR5cGUgUmVkdWNlckFjdGlvbnMsXG4gIHR5cGUgUmVkdWNlclN0YXRlLFxuICBBQ1RJT05fUkVGUkVTSCxcbiAgQUNUSU9OX1NFUlZFUl9BQ1RJT04sXG4gIEFDVElPTl9OQVZJR0FURSxcbiAgQUNUSU9OX1JFU1RPUkUsXG4gIHR5cGUgTmF2aWdhdGVBY3Rpb24sXG4gIEFDVElPTl9ITVJfUkVGUkVTSCxcbiAgUHJlZmV0Y2hLaW5kLFxuICB0eXBlIEFwcEhpc3RvcnlTdGF0ZSxcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IHJlZHVjZXIgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyJ1xuaW1wb3J0IHsgc3RhcnRUcmFuc2l0aW9uIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBpc1RoZW5hYmxlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9pcy10aGVuYWJsZSdcbmltcG9ydCB7XG4gIEZldGNoU3RyYXRlZ3ksXG4gIHR5cGUgUHJlZmV0Y2hUYXNrRmV0Y2hTdHJhdGVneSxcbn0gZnJvbSAnLi9zZWdtZW50LWNhY2hlL3R5cGVzJ1xuaW1wb3J0IHsgcHJlZmV0Y2ggYXMgcHJlZmV0Y2hXaXRoU2VnbWVudENhY2hlIH0gZnJvbSAnLi9zZWdtZW50LWNhY2hlL3ByZWZldGNoJ1xuaW1wb3J0IHsgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24gfSBmcm9tICcuL3VzZS1hY3Rpb24tcXVldWUnXG5pbXBvcnQgeyBhZGRCYXNlUGF0aCB9IGZyb20gJy4uL2FkZC1iYXNlLXBhdGgnXG5pbXBvcnQgeyBpc0V4dGVybmFsVVJMIH0gZnJvbSAnLi9hcHAtcm91dGVyLXV0aWxzJ1xuaW1wb3J0IHR5cGUge1xuICBBcHBSb3V0ZXJJbnN0YW5jZSxcbiAgTmF2aWdhdGVPcHRpb25zLFxuICBQcmVmZXRjaE9wdGlvbnMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgc2V0TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uLCB0eXBlIExpbmtJbnN0YW5jZSB9IGZyb20gJy4vbGlua3MnXG5pbXBvcnQgdHlwZSB7IENsaWVudEluc3RydW1lbnRhdGlvbkhvb2tzIH0gZnJvbSAnLi4vYXBwLWluZGV4J1xuaW1wb3J0IHR5cGUgeyBHbG9iYWxFcnJvckNvbXBvbmVudCB9IGZyb20gJy4vYnVpbHRpbi9nbG9iYWwtZXJyb3InXG5cbmV4cG9ydCB0eXBlIERpc3BhdGNoU3RhdGVQcm9taXNlID0gUmVhY3QuRGlzcGF0Y2g8UmVkdWNlclN0YXRlPlxuXG5leHBvcnQgdHlwZSBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSA9IHtcbiAgc3RhdGU6IEFwcFJvdXRlclN0YXRlXG4gIGRpc3BhdGNoOiAocGF5bG9hZDogUmVkdWNlckFjdGlvbnMsIHNldFN0YXRlOiBEaXNwYXRjaFN0YXRlUHJvbWlzZSkgPT4gdm9pZFxuICBhY3Rpb246IChzdGF0ZTogQXBwUm91dGVyU3RhdGUsIGFjdGlvbjogUmVkdWNlckFjdGlvbnMpID0+IFJlZHVjZXJTdGF0ZVxuXG4gIG9uUm91dGVyVHJhbnNpdGlvblN0YXJ0OlxuICAgIHwgKCh1cmw6IHN0cmluZywgdHlwZTogJ3B1c2gnIHwgJ3JlcGxhY2UnIHwgJ3RyYXZlcnNlJykgPT4gdm9pZClcbiAgICB8IG51bGxcblxuICBwZW5kaW5nOiBBY3Rpb25RdWV1ZU5vZGUgfCBudWxsXG4gIG5lZWRzUmVmcmVzaD86IGJvb2xlYW5cbiAgbGFzdDogQWN0aW9uUXVldWVOb2RlIHwgbnVsbFxufVxuXG5leHBvcnQgdHlwZSBHbG9iYWxFcnJvclN0YXRlID0gW1xuICBHbG9iYWxFcnJvcjogR2xvYmFsRXJyb3JDb21wb25lbnQsXG4gIHN0eWxlczogUmVhY3QuUmVhY3ROb2RlLFxuXVxuXG5leHBvcnQgdHlwZSBBY3Rpb25RdWV1ZU5vZGUgPSB7XG4gIHBheWxvYWQ6IFJlZHVjZXJBY3Rpb25zXG4gIG5leHQ6IEFjdGlvblF1ZXVlTm9kZSB8IG51bGxcbiAgcmVzb2x2ZTogKHZhbHVlOiBSZWR1Y2VyU3RhdGUpID0+IHZvaWRcbiAgcmVqZWN0OiAoZXJyOiBFcnJvcikgPT4gdm9pZFxuICBkaXNjYXJkZWQ/OiBib29sZWFuXG59XG5cbmZ1bmN0aW9uIHJ1blJlbWFpbmluZ0FjdGlvbnMoXG4gIGFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSxcbiAgc2V0U3RhdGU6IERpc3BhdGNoU3RhdGVQcm9taXNlXG4pIHtcbiAgaWYgKGFjdGlvblF1ZXVlLnBlbmRpbmcgIT09IG51bGwpIHtcbiAgICBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gYWN0aW9uUXVldWUucGVuZGluZy5uZXh0XG4gICAgaWYgKGFjdGlvblF1ZXVlLnBlbmRpbmcgIT09IG51bGwpIHtcbiAgICAgIHJ1bkFjdGlvbih7XG4gICAgICAgIGFjdGlvblF1ZXVlLFxuICAgICAgICBhY3Rpb246IGFjdGlvblF1ZXVlLnBlbmRpbmcsXG4gICAgICAgIHNldFN0YXRlLFxuICAgICAgfSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2hlY2sgZm9yIHJlZnJlc2ggd2hlbiBwZW5kaW5nIGlzIGFscmVhZHkgbnVsbFxuICAgIC8vIFRoaXMgaGFuZGxlcyB0aGUgY2FzZSB3aGVyZSBhIGRpc2NhcmRlZCBzZXJ2ZXIgYWN0aW9uIGNvbXBsZXRlc1xuICAgIC8vIGFmdGVyIHRoZSBuYXZpZ2F0aW9uIGhhcyBhbHJlYWR5IGZpbmlzaGVkIGFuZCB0aGUgcXVldWUgaXMgZW1wdHlcbiAgICBpZiAoYWN0aW9uUXVldWUubmVlZHNSZWZyZXNoKSB7XG4gICAgICBhY3Rpb25RdWV1ZS5uZWVkc1JlZnJlc2ggPSBmYWxzZVxuICAgICAgYWN0aW9uUXVldWUuZGlzcGF0Y2goeyB0eXBlOiBBQ1RJT05fUkVGUkVTSCB9LCBzZXRTdGF0ZSlcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuQWN0aW9uKHtcbiAgYWN0aW9uUXVldWUsXG4gIGFjdGlvbixcbiAgc2V0U3RhdGUsXG59OiB7XG4gIGFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZVxuICBhY3Rpb246IEFjdGlvblF1ZXVlTm9kZVxuICBzZXRTdGF0ZTogRGlzcGF0Y2hTdGF0ZVByb21pc2Vcbn0pIHtcbiAgY29uc3QgcHJldlN0YXRlID0gYWN0aW9uUXVldWUuc3RhdGVcblxuICBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gYWN0aW9uXG5cbiAgY29uc3QgcGF5bG9hZCA9IGFjdGlvbi5wYXlsb2FkXG4gIGNvbnN0IGFjdGlvblJlc3VsdCA9IGFjdGlvblF1ZXVlLmFjdGlvbihwcmV2U3RhdGUsIHBheWxvYWQpXG5cbiAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0KG5leHRTdGF0ZTogQXBwUm91dGVyU3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBkaXNjYXJkZWQgdGhpcyBhY3Rpb24sIHRoZSBzdGF0ZSBzaG91bGQgYWxzbyBiZSBkaXNjYXJkZWRcbiAgICBpZiAoYWN0aW9uLmRpc2NhcmRlZCkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGRpc2NhcmRlZCBzZXJ2ZXIgYWN0aW9uIHJldmFsaWRhdGVkIGRhdGFcbiAgICAgIGlmIChcbiAgICAgICAgYWN0aW9uLnBheWxvYWQudHlwZSA9PT0gQUNUSU9OX1NFUlZFUl9BQ1RJT04gJiZcbiAgICAgICAgYWN0aW9uLnBheWxvYWQuZGlkUmV2YWxpZGF0ZVxuICAgICAgKSB7XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgYWN0aW9uIHdhcyBkaXNjYXJkZWQgYnV0IGl0IHJldmFsaWRhdGVkIGRhdGEsXG4gICAgICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIHRvIHJlZnJlc2ggYWZ0ZXIgYWxsIGFjdGlvbnMgY29tcGxldGVcbiAgICAgICAgYWN0aW9uUXVldWUubmVlZHNSZWZyZXNoID0gdHJ1ZVxuICAgICAgfVxuICAgICAgLy8gU3RpbGwgbmVlZCB0byBydW4gcmVtYWluaW5nIGFjdGlvbnMgZXZlbiBmb3IgZGlzY2FyZGVkIGFjdGlvbnNcbiAgICAgIC8vIHRvIHBvdGVudGlhbGx5IHRyaWdnZXIgdGhlIHJlZnJlc2hcbiAgICAgIHJ1blJlbWFpbmluZ0FjdGlvbnMoYWN0aW9uUXVldWUsIHNldFN0YXRlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYWN0aW9uUXVldWUuc3RhdGUgPSBuZXh0U3RhdGVcblxuICAgIHJ1blJlbWFpbmluZ0FjdGlvbnMoYWN0aW9uUXVldWUsIHNldFN0YXRlKVxuICAgIGFjdGlvbi5yZXNvbHZlKG5leHRTdGF0ZSlcbiAgfVxuXG4gIC8vIGlmIHRoZSBhY3Rpb24gaXMgYSBwcm9taXNlLCBzZXQgdXAgYSBjYWxsYmFjayB0byByZXNvbHZlIGl0XG4gIGlmIChpc1RoZW5hYmxlKGFjdGlvblJlc3VsdCkpIHtcbiAgICBhY3Rpb25SZXN1bHQudGhlbihoYW5kbGVSZXN1bHQsIChlcnIpID0+IHtcbiAgICAgIHJ1blJlbWFpbmluZ0FjdGlvbnMoYWN0aW9uUXVldWUsIHNldFN0YXRlKVxuICAgICAgYWN0aW9uLnJlamVjdChlcnIpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVSZXN1bHQoYWN0aW9uUmVzdWx0KVxuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uKFxuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWUsXG4gIHBheWxvYWQ6IFJlZHVjZXJBY3Rpb25zLFxuICBzZXRTdGF0ZTogRGlzcGF0Y2hTdGF0ZVByb21pc2Vcbikge1xuICBsZXQgcmVzb2x2ZXJzOiB7XG4gICAgcmVzb2x2ZTogKHZhbHVlOiBSZWR1Y2VyU3RhdGUpID0+IHZvaWRcbiAgICByZWplY3Q6IChyZWFzb246IGFueSkgPT4gdm9pZFxuICB9ID0geyByZXNvbHZlOiBzZXRTdGF0ZSwgcmVqZWN0OiAoKSA9PiB7fSB9XG5cbiAgLy8gbW9zdCBvZiB0aGUgYWN0aW9uIHR5cGVzIGFyZSBhc3luYyB3aXRoIHRoZSBleGNlcHRpb24gb2YgcmVzdG9yZVxuICAvLyBpdCdzIGltcG9ydGFudCB0aGF0IHJlc3RvcmUgaXMgaGFuZGxlZCBxdWlja2x5IHNpbmNlIGl0J3MgZmlyZWQgb24gdGhlIHBvcHN0YXRlIGV2ZW50XG4gIC8vIGFuZCB3ZSBkb24ndCB3YW50IHRvIGFkZCBhbnkgZGVsYXkgb24gYSBiYWNrL2ZvcndhcmQgbmF2XG4gIC8vIHRoaXMgb25seSBjcmVhdGVzIGEgcHJvbWlzZSBmb3IgdGhlIGFzeW5jIGFjdGlvbnNcbiAgaWYgKHBheWxvYWQudHlwZSAhPT0gQUNUSU9OX1JFU1RPUkUpIHtcbiAgICAvLyBDcmVhdGUgdGhlIHByb21pc2UgYW5kIGFzc2lnbiB0aGUgcmVzb2x2ZXJzIHRvIHRoZSBvYmplY3QuXG4gICAgY29uc3QgZGVmZXJyZWRQcm9taXNlID0gbmV3IFByb21pc2U8QXBwUm91dGVyU3RhdGU+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlc29sdmVycyA9IHsgcmVzb2x2ZSwgcmVqZWN0IH1cbiAgICB9KVxuXG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIC8vIHdlIGltbWVkaWF0ZWx5IG5vdGlmeSBSZWFjdCBvZiB0aGUgcGVuZGluZyBwcm9taXNlIC0tIHRoZSByZXNvbHZlciBpcyBhdHRhY2hlZCB0byB0aGUgYWN0aW9uIG5vZGVcbiAgICAgIC8vIGFuZCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBhc3NvY2lhdGVkIGFjdGlvbiBwcm9taXNlIHJlc29sdmVzXG4gICAgICBzZXRTdGF0ZShkZWZlcnJlZFByb21pc2UpXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IG5ld0FjdGlvbjogQWN0aW9uUXVldWVOb2RlID0ge1xuICAgIHBheWxvYWQsXG4gICAgbmV4dDogbnVsbCxcbiAgICByZXNvbHZlOiByZXNvbHZlcnMucmVzb2x2ZSxcbiAgICByZWplY3Q6IHJlc29sdmVycy5yZWplY3QsXG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGUgcXVldWUgaXMgZW1wdHlcbiAgaWYgKGFjdGlvblF1ZXVlLnBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAvLyBUaGUgcXVldWUgaXMgZW1wdHksIHNvIGFkZCB0aGUgYWN0aW9uIGFuZCBzdGFydCBpdCBpbW1lZGlhdGVseVxuICAgIC8vIE1hcmsgdGhpcyBhY3Rpb24gYXMgdGhlIGxhc3QgaW4gdGhlIHF1ZXVlXG4gICAgYWN0aW9uUXVldWUubGFzdCA9IG5ld0FjdGlvblxuXG4gICAgcnVuQWN0aW9uKHtcbiAgICAgIGFjdGlvblF1ZXVlLFxuICAgICAgYWN0aW9uOiBuZXdBY3Rpb24sXG4gICAgICBzZXRTdGF0ZSxcbiAgICB9KVxuICB9IGVsc2UgaWYgKFxuICAgIHBheWxvYWQudHlwZSA9PT0gQUNUSU9OX05BVklHQVRFIHx8XG4gICAgcGF5bG9hZC50eXBlID09PSBBQ1RJT05fUkVTVE9SRVxuICApIHtcbiAgICAvLyBOYXZpZ2F0aW9ucyAoaW5jbHVkaW5nIGJhY2svZm9yd2FyZCkgdGFrZSBwcmlvcml0eSBvdmVyIGFueSBwZW5kaW5nIGFjdGlvbnMuXG4gICAgLy8gTWFyayB0aGUgcGVuZGluZyBhY3Rpb24gYXMgZGlzY2FyZGVkIChzbyB0aGUgc3RhdGUgaXMgbmV2ZXIgYXBwbGllZCkgYW5kIHN0YXJ0IHRoZSBuYXZpZ2F0aW9uIGFjdGlvbiBpbW1lZGlhdGVseS5cbiAgICBhY3Rpb25RdWV1ZS5wZW5kaW5nLmRpc2NhcmRlZCA9IHRydWVcblxuICAgIC8vIFRoZSByZXN0IG9mIHRoZSBjdXJyZW50IHF1ZXVlIHNob3VsZCBzdGlsbCBleGVjdXRlIGFmdGVyIHRoaXMgbmF2aWdhdGlvbi5cbiAgICAvLyAoTm90ZSB0aGF0IGl0IGNhbid0IGNvbnRhaW4gYW55IGVhcmxpZXIgbmF2aWdhdGlvbnMsIGJlY2F1c2Ugd2UgYWx3YXlzIHB1dCB0aG9zZSBpbnRvIGBhY3Rpb25RdWV1ZS5wZW5kaW5nYCBieSBjYWxsaW5nIGBydW5BY3Rpb25gKVxuICAgIG5ld0FjdGlvbi5uZXh0ID0gYWN0aW9uUXVldWUucGVuZGluZy5uZXh0XG5cbiAgICBydW5BY3Rpb24oe1xuICAgICAgYWN0aW9uUXVldWUsXG4gICAgICBhY3Rpb246IG5ld0FjdGlvbixcbiAgICAgIHNldFN0YXRlLFxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIHF1ZXVlIGlzIG5vdCBlbXB0eSwgc28gYWRkIHRoZSBhY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcbiAgICAvLyBJdCB3aWxsIGJlIHN0YXJ0ZWQgYnkgcnVuUmVtYWluaW5nQWN0aW9ucyBhZnRlciB0aGUgcHJldmlvdXMgYWN0aW9uIGZpbmlzaGVzXG4gICAgaWYgKGFjdGlvblF1ZXVlLmxhc3QgIT09IG51bGwpIHtcbiAgICAgIGFjdGlvblF1ZXVlLmxhc3QubmV4dCA9IG5ld0FjdGlvblxuICAgIH1cbiAgICBhY3Rpb25RdWV1ZS5sYXN0ID0gbmV3QWN0aW9uXG4gIH1cbn1cblxubGV0IGdsb2JhbEFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSB8IG51bGwgPSBudWxsXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNdXRhYmxlQWN0aW9uUXVldWUoXG4gIGluaXRpYWxTdGF0ZTogQXBwUm91dGVyU3RhdGUsXG4gIGluc3RydW1lbnRhdGlvbkhvb2tzOiBDbGllbnRJbnN0cnVtZW50YXRpb25Ib29rcyB8IG51bGxcbik6IEFwcFJvdXRlckFjdGlvblF1ZXVlIHtcbiAgY29uc3QgYWN0aW9uUXVldWU6IEFwcFJvdXRlckFjdGlvblF1ZXVlID0ge1xuICAgIHN0YXRlOiBpbml0aWFsU3RhdGUsXG4gICAgZGlzcGF0Y2g6IChwYXlsb2FkOiBSZWR1Y2VyQWN0aW9ucywgc2V0U3RhdGU6IERpc3BhdGNoU3RhdGVQcm9taXNlKSA9PlxuICAgICAgZGlzcGF0Y2hBY3Rpb24oYWN0aW9uUXVldWUsIHBheWxvYWQsIHNldFN0YXRlKSxcbiAgICBhY3Rpb246IGFzeW5jIChzdGF0ZTogQXBwUm91dGVyU3RhdGUsIGFjdGlvbjogUmVkdWNlckFjdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZHVjZXIoc3RhdGUsIGFjdGlvbilcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9LFxuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgbGFzdDogbnVsbCxcbiAgICBvblJvdXRlclRyYW5zaXRpb25TdGFydDpcbiAgICAgIGluc3RydW1lbnRhdGlvbkhvb2tzICE9PSBudWxsICYmXG4gICAgICB0eXBlb2YgaW5zdHJ1bWVudGF0aW9uSG9va3Mub25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyAvLyBUaGlzIHByb2ZpbGluZyBob29rIHdpbGwgYmUgY2FsbGVkIGF0IHRoZSBzdGFydCBvZiBldmVyeSBuYXZpZ2F0aW9uLlxuICAgICAgICAgIGluc3RydW1lbnRhdGlvbkhvb2tzLm9uUm91dGVyVHJhbnNpdGlvblN0YXJ0XG4gICAgICAgIDogbnVsbCxcbiAgfVxuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFRoZSBhY3Rpb24gcXVldWUgaXMgbGF6aWx5IGNyZWF0ZWQgb24gaHlkcmF0aW9uLCBidXQgYWZ0ZXIgdGhhdCBwb2ludFxuICAgIC8vIGl0IGRvZXNuJ3QgY2hhbmdlLiBTbyB3ZSBjYW4gc3RvcmUgaXQgaW4gYSBnbG9iYWwgcmF0aGVyIHRoYW4gcGFzc1xuICAgIC8vIGl0IGFyb3VuZCBldmVyeXdoZXJlIHZpYSBwcm9wcy9jb250ZXh0LlxuICAgIGlmIChnbG9iYWxBY3Rpb25RdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSW50ZXJuYWwgTmV4dC5qcyBFcnJvcjogY3JlYXRlTXV0YWJsZUFjdGlvblF1ZXVlIHdhcyBjYWxsZWQgbW9yZSAnICtcbiAgICAgICAgICAndGhhbiBvbmNlJ1xuICAgICAgKVxuICAgIH1cbiAgICBnbG9iYWxBY3Rpb25RdWV1ZSA9IGFjdGlvblF1ZXVlXG4gIH1cblxuICByZXR1cm4gYWN0aW9uUXVldWVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRBcHBSb3V0ZXJTdGF0ZSgpOiBBcHBSb3V0ZXJTdGF0ZSB8IG51bGwge1xuICByZXR1cm4gZ2xvYmFsQWN0aW9uUXVldWUgIT09IG51bGwgPyBnbG9iYWxBY3Rpb25RdWV1ZS5zdGF0ZSA6IG51bGxcbn1cblxuZnVuY3Rpb24gZ2V0QXBwUm91dGVyQWN0aW9uUXVldWUoKTogQXBwUm91dGVyQWN0aW9uUXVldWUge1xuICBpZiAoZ2xvYmFsQWN0aW9uUXVldWUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW50ZXJuYWwgTmV4dC5qcyBlcnJvcjogUm91dGVyIGFjdGlvbiBkaXNwYXRjaGVkIGJlZm9yZSBpbml0aWFsaXphdGlvbi4nXG4gICAgKVxuICB9XG4gIHJldHVybiBnbG9iYWxBY3Rpb25RdWV1ZVxufVxuXG5mdW5jdGlvbiBnZXRQcm9maWxpbmdIb29rRm9yT25OYXZpZ2F0aW9uU3RhcnQoKSB7XG4gIGlmIChnbG9iYWxBY3Rpb25RdWV1ZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnbG9iYWxBY3Rpb25RdWV1ZS5vblJvdXRlclRyYW5zaXRpb25TdGFydFxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwYXRjaE5hdmlnYXRlQWN0aW9uKFxuICBocmVmOiBzdHJpbmcsXG4gIG5hdmlnYXRlVHlwZTogTmF2aWdhdGVBY3Rpb25bJ25hdmlnYXRlVHlwZSddLFxuICBzaG91bGRTY3JvbGw6IGJvb2xlYW4sXG4gIGxpbmtJbnN0YW5jZVJlZjogTGlua0luc3RhbmNlIHwgbnVsbFxuKTogdm9pZCB7XG4gIC8vIFRPRE86IFRoaXMgc3R1ZmYgY291bGQganVzdCBnbyBpbnRvIHRoZSByZWR1Y2VyLiBMZWF2aW5nIGFzLWlzIGZvciBub3dcbiAgLy8gc2luY2Ugd2UncmUgYWJvdXQgdG8gcmV3cml0ZSBhbGwgdGhlIHJvdXRlciByZWR1Y2VyIHN0dWZmIGFueXdheS5cbiAgY29uc3QgdXJsID0gbmV3IFVSTChhZGRCYXNlUGF0aChocmVmKSwgbG9jYXRpb24uaHJlZilcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9BUFBfTkFWX0ZBSUxfSEFORExJTkcpIHtcbiAgICB3aW5kb3cubmV4dC5fX3BlbmRpbmdVcmwgPSB1cmxcbiAgfVxuXG4gIHNldExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbihsaW5rSW5zdGFuY2VSZWYpXG5cbiAgY29uc3Qgb25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQgPSBnZXRQcm9maWxpbmdIb29rRm9yT25OYXZpZ2F0aW9uU3RhcnQoKVxuICBpZiAob25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQgIT09IG51bGwpIHtcbiAgICBvblJvdXRlclRyYW5zaXRpb25TdGFydChocmVmLCBuYXZpZ2F0ZVR5cGUpXG4gIH1cblxuICBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbih7XG4gICAgdHlwZTogQUNUSU9OX05BVklHQVRFLFxuICAgIHVybCxcbiAgICBpc0V4dGVybmFsVXJsOiBpc0V4dGVybmFsVVJMKHVybCksXG4gICAgbG9jYXRpb25TZWFyY2g6IGxvY2F0aW9uLnNlYXJjaCxcbiAgICBzaG91bGRTY3JvbGwsXG4gICAgbmF2aWdhdGVUeXBlLFxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzcGF0Y2hUcmF2ZXJzZUFjdGlvbihcbiAgaHJlZjogc3RyaW5nLFxuICBoaXN0b3J5U3RhdGU6IEFwcEhpc3RvcnlTdGF0ZSB8IHVuZGVmaW5lZFxuKSB7XG4gIGNvbnN0IG9uUm91dGVyVHJhbnNpdGlvblN0YXJ0ID0gZ2V0UHJvZmlsaW5nSG9va0Zvck9uTmF2aWdhdGlvblN0YXJ0KClcbiAgaWYgKG9uUm91dGVyVHJhbnNpdGlvblN0YXJ0ICE9PSBudWxsKSB7XG4gICAgb25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQoaHJlZiwgJ3RyYXZlcnNlJylcbiAgfVxuICBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbih7XG4gICAgdHlwZTogQUNUSU9OX1JFU1RPUkUsXG4gICAgdXJsOiBuZXcgVVJMKGhyZWYpLFxuICAgIGhpc3RvcnlTdGF0ZSxcbiAgfSlcbn1cblxuLyoqXG4gKiBUaGUgYXBwIHJvdXRlciB0aGF0IGlzIGV4cG9zZWQgdGhyb3VnaCBgdXNlUm91dGVyYC4gVGhlc2UgYXJlIHB1YmxpYyBBUElcbiAqIG1ldGhvZHMuIEludGVybmFsIE5leHQuanMgY29kZSBzaG91bGQgY2FsbCB0aGUgbG93ZXIgbGV2ZWwgbWV0aG9kcyBkaXJlY3RseVxuICogKGFsdGhvdWdoIHRoZXJlJ3MgbG90cyBvZiBleGlzdGluZyBjb2RlIHRoYXQgZG9lc24ndCBkbyB0aGF0KS5cbiAqL1xuZXhwb3J0IGNvbnN0IHB1YmxpY0FwcFJvdXRlckluc3RhbmNlOiBBcHBSb3V0ZXJJbnN0YW5jZSA9IHtcbiAgYmFjazogKCkgPT4gd2luZG93Lmhpc3RvcnkuYmFjaygpLFxuICBmb3J3YXJkOiAoKSA9PiB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCksXG4gIHByZWZldGNoOlxuICAgIC8vIFVubGlrZSB0aGUgb2xkIGltcGxlbWVudGF0aW9uLCB0aGUgU2VnbWVudCBDYWNoZSBkb2Vzbid0IHN0b3JlIGl0c1xuICAgIC8vIGRhdGEgaW4gdGhlIHJvdXRlciByZWR1Y2VyIHN0YXRlOyBpdCB3cml0ZXMgaW50byBhIGdsb2JhbCBtdXRhYmxlXG4gICAgLy8gY2FjaGUuIFNvIHdlIGRvbid0IG5lZWQgdG8gZGlzcGF0Y2ggYW4gYWN0aW9uLlxuICAgIChocmVmOiBzdHJpbmcsIG9wdGlvbnM/OiBQcmVmZXRjaE9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGFjdGlvblF1ZXVlID0gZ2V0QXBwUm91dGVyQWN0aW9uUXVldWUoKVxuICAgICAgY29uc3QgcHJlZmV0Y2hLaW5kID0gb3B0aW9ucz8ua2luZCA/PyBQcmVmZXRjaEtpbmQuQVVUT1xuXG4gICAgICAvLyBXZSBkb24ndCBjdXJyZW50bHkgb2ZmZXIgYSB3YXkgdG8gaXNzdWUgYSBydW50aW1lIHByZWZldGNoIHZpYSBgcm91dGVyLnByZWZldGNoKClgLlxuICAgICAgLy8gVGhpcyB3aWxsIGJlIHBvc3NpYmxlIHdoZW4gd2UgdXBkYXRlIGl0cyBBUEkgdG8gbm90IHRha2UgYSBQcmVmZXRjaEtpbmQuXG4gICAgICBsZXQgZmV0Y2hTdHJhdGVneTogUHJlZmV0Y2hUYXNrRmV0Y2hTdHJhdGVneVxuICAgICAgc3dpdGNoIChwcmVmZXRjaEtpbmQpIHtcbiAgICAgICAgY2FzZSBQcmVmZXRjaEtpbmQuQVVUTzoge1xuICAgICAgICAgIC8vIFdlIGRlZmF1bHQgdG8gUFBSLiBXZSdsbCBkaXNjb3ZlciB3aGV0aGVyIG9yIG5vdCB0aGUgcm91dGUgc3VwcG9ydHMgaXQgd2l0aCB0aGUgaW5pdGlhbCBwcmVmZXRjaC5cbiAgICAgICAgICBmZXRjaFN0cmF0ZWd5ID0gRmV0Y2hTdHJhdGVneS5QUFJcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgUHJlZmV0Y2hLaW5kLkZVTEw6IHtcbiAgICAgICAgICBmZXRjaFN0cmF0ZWd5ID0gRmV0Y2hTdHJhdGVneS5GdWxsXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgcHJlZmV0Y2hLaW5kIHNhdGlzZmllcyBuZXZlclxuICAgICAgICAgIC8vIERlc3BpdGUgdHlwZXNjcmlwdCB0aGlua2luZyB0aGF0IHRoaXMgY2FuJ3QgaGFwcGVuLFxuICAgICAgICAgIC8vIHdlIG1pZ2h0IGdldCBhbiB1bmV4cGVjdGVkIHZhbHVlIGZyb20gdXNlciBjb2RlLlxuICAgICAgICAgIC8vIFdlIGRvbid0IGtub3cgd2hhdCB0aGV5IHdhbnQsIGJ1dCB3ZSBrbm93IHRoZXkgd2FudCBhIHByZWZldGNoLFxuICAgICAgICAgIC8vIHNvIHVzZSB0aGUgZGVmYXVsdC5cbiAgICAgICAgICBmZXRjaFN0cmF0ZWd5ID0gRmV0Y2hTdHJhdGVneS5QUFJcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmVmZXRjaFdpdGhTZWdtZW50Q2FjaGUoXG4gICAgICAgIGhyZWYsXG4gICAgICAgIGFjdGlvblF1ZXVlLnN0YXRlLm5leHRVcmwsXG4gICAgICAgIGFjdGlvblF1ZXVlLnN0YXRlLnRyZWUsXG4gICAgICAgIGZldGNoU3RyYXRlZ3ksXG4gICAgICAgIG9wdGlvbnM/Lm9uSW52YWxpZGF0ZSA/PyBudWxsXG4gICAgICApXG4gICAgfSxcbiAgcmVwbGFjZTogKGhyZWY6IHN0cmluZywgb3B0aW9ucz86IE5hdmlnYXRlT3B0aW9ucykgPT4ge1xuICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICBkaXNwYXRjaE5hdmlnYXRlQWN0aW9uKGhyZWYsICdyZXBsYWNlJywgb3B0aW9ucz8uc2Nyb2xsID8/IHRydWUsIG51bGwpXG4gICAgfSlcbiAgfSxcbiAgcHVzaDogKGhyZWY6IHN0cmluZywgb3B0aW9ucz86IE5hdmlnYXRlT3B0aW9ucykgPT4ge1xuICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICBkaXNwYXRjaE5hdmlnYXRlQWN0aW9uKGhyZWYsICdwdXNoJywgb3B0aW9ucz8uc2Nyb2xsID8/IHRydWUsIG51bGwpXG4gICAgfSlcbiAgfSxcbiAgcmVmcmVzaDogKCkgPT4ge1xuICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbih7XG4gICAgICAgIHR5cGU6IEFDVElPTl9SRUZSRVNILFxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuICBobXJSZWZyZXNoOiAoKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdobXJSZWZyZXNoIGNhbiBvbmx5IGJlIHVzZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZS4gUGxlYXNlIHVzZSByZWZyZXNoIGluc3RlYWQuJ1xuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbih7XG4gICAgICAgICAgdHlwZTogQUNUSU9OX0hNUl9SRUZSRVNILFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG59XG5cbi8vIEV4aXN0cyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLiBEb24ndCB1c2UgaW4gYXBwbGljYXRpb24gY29kZS5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmV4dCkge1xuICB3aW5kb3cubmV4dC5yb3V0ZXIgPSBwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZU11dGFibGVBY3Rpb25RdWV1ZSIsImRpc3BhdGNoTmF2aWdhdGVBY3Rpb24iLCJkaXNwYXRjaFRyYXZlcnNlQWN0aW9uIiwiZ2V0Q3VycmVudEFwcFJvdXRlclN0YXRlIiwicHVibGljQXBwUm91dGVySW5zdGFuY2UiLCJydW5SZW1haW5pbmdBY3Rpb25zIiwiYWN0aW9uUXVldWUiLCJzZXRTdGF0ZSIsInBlbmRpbmciLCJuZXh0IiwicnVuQWN0aW9uIiwiYWN0aW9uIiwibmVlZHNSZWZyZXNoIiwiZGlzcGF0Y2giLCJ0eXBlIiwiQUNUSU9OX1JFRlJFU0giLCJwcmV2U3RhdGUiLCJzdGF0ZSIsInBheWxvYWQiLCJhY3Rpb25SZXN1bHQiLCJoYW5kbGVSZXN1bHQiLCJuZXh0U3RhdGUiLCJkaXNjYXJkZWQiLCJBQ1RJT05fU0VSVkVSX0FDVElPTiIsImRpZFJldmFsaWRhdGUiLCJyZXNvbHZlIiwiaXNUaGVuYWJsZSIsInRoZW4iLCJlcnIiLCJyZWplY3QiLCJkaXNwYXRjaEFjdGlvbiIsInJlc29sdmVycyIsIkFDVElPTl9SRVNUT1JFIiwiZGVmZXJyZWRQcm9taXNlIiwiUHJvbWlzZSIsInN0YXJ0VHJhbnNpdGlvbiIsIm5ld0FjdGlvbiIsImxhc3QiLCJBQ1RJT05fTkFWSUdBVEUiLCJnbG9iYWxBY3Rpb25RdWV1ZSIsImluaXRpYWxTdGF0ZSIsImluc3RydW1lbnRhdGlvbkhvb2tzIiwicmVzdWx0IiwicmVkdWNlciIsIm9uUm91dGVyVHJhbnNpdGlvblN0YXJ0Iiwid2luZG93IiwiRXJyb3IiLCJnZXRBcHBSb3V0ZXJBY3Rpb25RdWV1ZSIsImdldFByb2ZpbGluZ0hvb2tGb3JPbk5hdmlnYXRpb25TdGFydCIsImhyZWYiLCJuYXZpZ2F0ZVR5cGUiLCJzaG91bGRTY3JvbGwiLCJsaW5rSW5zdGFuY2VSZWYiLCJ1cmwiLCJVUkwiLCJhZGRCYXNlUGF0aCIsImxvY2F0aW9uIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9BUFBfTkFWX0ZBSUxfSEFORExJTkciLCJfX3BlbmRpbmdVcmwiLCJzZXRMaW5rRm9yQ3VycmVudE5hdmlnYXRpb24iLCJkaXNwYXRjaEFwcFJvdXRlckFjdGlvbiIsImlzRXh0ZXJuYWxVcmwiLCJpc0V4dGVybmFsVVJMIiwibG9jYXRpb25TZWFyY2giLCJzZWFyY2giLCJoaXN0b3J5U3RhdGUiLCJiYWNrIiwiaGlzdG9yeSIsImZvcndhcmQiLCJwcmVmZXRjaCIsIm9wdGlvbnMiLCJwcmVmZXRjaEtpbmQiLCJraW5kIiwiUHJlZmV0Y2hLaW5kIiwiQVVUTyIsImZldGNoU3RyYXRlZ3kiLCJGZXRjaFN0cmF0ZWd5IiwiUFBSIiwiRlVMTCIsIkZ1bGwiLCJwcmVmZXRjaFdpdGhTZWdtZW50Q2FjaGUiLCJuZXh0VXJsIiwidHJlZSIsIm9uSW52YWxpZGF0ZSIsInJlcGxhY2UiLCJzY3JvbGwiLCJwdXNoIiwicmVmcmVzaCIsImhtclJlZnJlc2giLCJOT0RFX0VOViIsIkFDVElPTl9ITVJfUkVGUkVTSCIsInJvdXRlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router-instance.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/app-router-utils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router-utils.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createPrefetchURL: function() {\n        return createPrefetchURL;\n    },\n    isExternalURL: function() {\n        return isExternalURL;\n    }\n});\nconst _isbot = __webpack_require__(/*! ../../shared/lib/router/utils/is-bot */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nconst _addbasepath = __webpack_require__(/*! ../add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nfunction isExternalURL(url) {\n    return url.origin !== window.location.origin;\n}\nfunction createPrefetchURL(href) {\n    // Don't prefetch for bots as they don't navigate.\n    if ((0, _isbot.isBot)(window.navigator.userAgent)) {\n        return null;\n    }\n    let url;\n    try {\n        url = new URL((0, _addbasepath.addBasePath)(href), window.location.href);\n    } catch (_) {\n        // TODO: Does this need to throw or can we just console.error instead? Does\n        // anyone rely on this throwing? (Seems unlikely.)\n        throw Object.defineProperty(new Error(`Cannot prefetch '${href}' because it cannot be converted to a URL.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E234\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Don't prefetch during development (improves compilation performance)\n    if (true) {\n        return null;\n    }\n    // External urls can't be prefetched in the same way.\n    if (isExternalURL(url)) {\n        return null;\n    }\n    return url;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router-utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci11dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFjZ0JBLGlCQUFpQjtlQUFqQkE7O0lBWEFDLGFBQWE7ZUFBYkE7OzttQ0FITTt5Q0FDTTtBQUVyQixTQUFTQSxjQUFjQyxHQUFRO0lBQ3BDLE9BQU9BLElBQUlDLE1BQU0sS0FBS0MsT0FBT0MsUUFBUSxDQUFDRixNQUFNO0FBQzlDO0FBU08sU0FBU0gsa0JBQWtCTSxJQUFZO0lBQzVDLGtEQUFrRDtJQUNsRCxJQUFJQyxDQUFBQSxHQUFBQSxPQUFBQSxLQUFLLEVBQUNILE9BQU9JLFNBQVMsQ0FBQ0MsU0FBUyxHQUFHO1FBQ3JDLE9BQU87SUFDVDtJQUVBLElBQUlQO0lBQ0osSUFBSTtRQUNGQSxNQUFNLElBQUlRLElBQUlDLENBQUFBLEdBQUFBLGFBQUFBLFdBQUFBLEVBQVlMLE9BQU9GLE9BQU9DLFFBQVEsQ0FBQ0MsSUFBSTtJQUN2RCxFQUFFLE9BQU9NLEdBQUc7UUFDViwyRUFBMkU7UUFDM0Usa0RBQWtEO1FBQ2xELE1BQU0scUJBRUwsQ0FGSyxJQUFJQyxNQUNSLENBQUMsaUJBQWlCLEVBQUVQLEtBQUssMENBQTBDLENBQUMsR0FEaEU7bUJBQUE7d0JBQUE7MEJBQUE7UUFFTjtJQUNGO0lBRUEsdUVBQXVFO0lBQ3ZFLElBQUlRLElBQW9CLEVBQW9CO1FBQzFDLE9BQU87SUFDVDtJQUVBLHFEQUFxRDtJQUNyRCxJQUFJYixjQUFjQyxNQUFNO1FBQ3RCLE9BQU87SUFDVDtJQUVBLE9BQU9BO0FBQ1QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yeWFucm9zenRvY3p5L0RldmVsb3BtZW50L3NyYy9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLXV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzQm90IH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtYm90J1xuaW1wb3J0IHsgYWRkQmFzZVBhdGggfSBmcm9tICcuLi9hZGQtYmFzZS1wYXRoJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlcm5hbFVSTCh1cmw6IFVSTCkge1xuICByZXR1cm4gdXJsLm9yaWdpbiAhPT0gd2luZG93LmxvY2F0aW9uLm9yaWdpblxufVxuXG4vKipcbiAqIEdpdmVuIGEgbGluayBocmVmLCBjb25zdHJ1Y3RzIHRoZSBVUkwgdGhhdCBzaG91bGQgYmUgcHJlZmV0Y2hlZC4gUmV0dXJucyBudWxsXG4gKiBpbiBjYXNlcyB3aGVyZSBwcmVmZXRjaGluZyBzaG91bGQgYmUgZGlzYWJsZWQsIGxpa2UgZXh0ZXJuYWwgVVJMcywgb3JcbiAqIGR1cmluZyBkZXZlbG9wbWVudC5cbiAqIEBwYXJhbSBocmVmIFRoZSBocmVmIHBhc3NlZCB0byA8TGluaz4sIHJvdXRlci5wcmVmZXRjaCgpLCBvciBzaW1pbGFyXG4gKiBAcmV0dXJucyBBIFVSTCBvYmplY3QgdG8gcHJlZmV0Y2gsIG9yIG51bGwgaWYgcHJlZmV0Y2hpbmcgc2hvdWxkIGJlIGRpc2FibGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcmVmZXRjaFVSTChocmVmOiBzdHJpbmcpOiBVUkwgfCBudWxsIHtcbiAgLy8gRG9uJ3QgcHJlZmV0Y2ggZm9yIGJvdHMgYXMgdGhleSBkb24ndCBuYXZpZ2F0ZS5cbiAgaWYgKGlzQm90KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBsZXQgdXJsOiBVUkxcbiAgdHJ5IHtcbiAgICB1cmwgPSBuZXcgVVJMKGFkZEJhc2VQYXRoKGhyZWYpLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIFRPRE86IERvZXMgdGhpcyBuZWVkIHRvIHRocm93IG9yIGNhbiB3ZSBqdXN0IGNvbnNvbGUuZXJyb3IgaW5zdGVhZD8gRG9lc1xuICAgIC8vIGFueW9uZSByZWx5IG9uIHRoaXMgdGhyb3dpbmc/IChTZWVtcyB1bmxpa2VseS4pXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBwcmVmZXRjaCAnJHtocmVmfScgYmVjYXVzZSBpdCBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgVVJMLmBcbiAgICApXG4gIH1cblxuICAvLyBEb24ndCBwcmVmZXRjaCBkdXJpbmcgZGV2ZWxvcG1lbnQgKGltcHJvdmVzIGNvbXBpbGF0aW9uIHBlcmZvcm1hbmNlKVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gRXh0ZXJuYWwgdXJscyBjYW4ndCBiZSBwcmVmZXRjaGVkIGluIHRoZSBzYW1lIHdheS5cbiAgaWYgKGlzRXh0ZXJuYWxVUkwodXJsKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlUHJlZmV0Y2hVUkwiLCJpc0V4dGVybmFsVVJMIiwidXJsIiwib3JpZ2luIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiaXNCb3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJVUkwiLCJhZGRCYXNlUGF0aCIsIl8iLCJFcnJvciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router-utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return AppRouter;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _createhreffromurl = __webpack_require__(/*! ./router-reducer/create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../../shared/lib/hooks-client-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _useactionqueue = __webpack_require__(/*! ./use-action-queue */ \"(app-pages-browser)/./node_modules/next/dist/client/components/use-action-queue.js\");\nconst _approuterannouncer = __webpack_require__(/*! ./app-router-announcer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-announcer.js\");\nconst _redirectboundary = __webpack_require__(/*! ./redirect-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js\");\nconst _findheadincache = __webpack_require__(/*! ./router-reducer/reducers/find-head-in-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\");\nconst _unresolvedthenable = __webpack_require__(/*! ./unresolved-thenable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/unresolved-thenable.js\");\nconst _removebasepath = __webpack_require__(/*! ../remove-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nconst _computechangedpath = __webpack_require__(/*! ./router-reducer/compute-changed-path */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nconst _navfailurehandler = __webpack_require__(/*! ./nav-failure-handler */ \"(app-pages-browser)/./node_modules/next/dist/client/components/nav-failure-handler.js\");\nconst _approuterinstance = __webpack_require__(/*! ./app-router-instance */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-instance.js\");\nconst _redirect = __webpack_require__(/*! ./redirect */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect.js\");\nconst _redirecterror = __webpack_require__(/*! ./redirect-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-error.js\");\nconst _links = __webpack_require__(/*! ./links */ \"(app-pages-browser)/./node_modules/next/dist/client/components/links.js\");\nconst _rooterrorboundary = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./errors/root-error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/errors/root-error-boundary.js\"));\nconst _globalerror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./builtin/global-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/builtin/global-error.js\"));\nconst _boundarycomponents = __webpack_require__(/*! ../../lib/framework/boundary-components */ \"(app-pages-browser)/./node_modules/next/dist/lib/framework/boundary-components.js\");\nconst _deploymentid = __webpack_require__(/*! ../../shared/lib/deployment-id */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/deployment-id.js\");\nconst globalMutable = {};\nfunction HistoryUpdater({ appRouterState }) {\n    (0, _react.useInsertionEffect)(()=>{\n        if (false) {}\n        const { tree, pushRef, canonicalUrl, renderedSearch } = appRouterState;\n        const appHistoryState = {\n            tree,\n            renderedSearch\n        };\n        // TODO: Use Navigation API if available\n        const historyState = {\n            ...pushRef.preserveCustomHistoryState ? window.history.state : {},\n            // Identifier is shortened intentionally.\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            // __N is used to identify if the history entry can be handled by the old router.\n            __NA: true,\n            __PRIVATE_NEXTJS_INTERNALS_TREE: appHistoryState\n        };\n        if (pushRef.pendingPush && // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n        // This mirrors the browser behavior for normal navigation.\n        (0, _createhreffromurl.createHrefFromUrl)(new URL(window.location.href)) !== canonicalUrl) {\n            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n            pushRef.pendingPush = false;\n            window.history.pushState(historyState, '', canonicalUrl);\n        } else {\n            window.history.replaceState(historyState, '', canonicalUrl);\n        }\n    }, [\n        appRouterState\n    ]);\n    (0, _react.useEffect)(()=>{\n        // The Next-Url and the base tree may affect the result of a prefetch\n        // task. Re-prefetch all visible links with the updated values. In most\n        // cases, this will not result in any new network requests, only if\n        // the prefetch result actually varies on one of these inputs.\n        (0, _links.pingVisibleLinks)(appRouterState.nextUrl, appRouterState.tree);\n    }, [\n        appRouterState.nextUrl,\n        appRouterState.tree\n    ]);\n    return null;\n}\n_c = HistoryUpdater;\nfunction copyNextJsInternalHistoryState(data) {\n    if (data == null) data = {};\n    const currentState = window.history.state;\n    const __NA = currentState?.__NA;\n    if (__NA) {\n        data.__NA = __NA;\n    }\n    const __PRIVATE_NEXTJS_INTERNALS_TREE = currentState?.__PRIVATE_NEXTJS_INTERNALS_TREE;\n    if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n        data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE;\n    }\n    return data;\n}\nfunction Head({ headCacheNode }) {\n    // If this segment has a `prefetchHead`, it's the statically prefetched data.\n    // We should use that on initial render instead of `head`. Then we'll switch\n    // to `head` when the dynamic response streams in.\n    const head = headCacheNode !== null ? headCacheNode.head : null;\n    const prefetchHead = headCacheNode !== null ? headCacheNode.prefetchHead : null;\n    // If no prefetch data is available, then we go straight to rendering `head`.\n    const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head;\n    // We use `useDeferredValue` to handle switching between the prefetched and\n    // final values. The second argument is returned on initial render, then it\n    // re-renders with the first argument.\n    return (0, _react.useDeferredValue)(head, resolvedPrefetchRsc);\n}\n_c1 = Head;\n/**\n * The global router that wraps the application components.\n */ function Router({ actionQueue, globalError, webSocket, staticIndicatorState }) {\n    const state = (0, _useactionqueue.useActionQueue)(actionQueue);\n    const { canonicalUrl } = state;\n    // Add memoized pathname/query for useSearchParams and usePathname.\n    const { searchParams, pathname } = (0, _react.useMemo)(()=>{\n        const url = new URL(canonicalUrl,  false ? 0 : window.location.href);\n        return {\n            // This is turned into a readonly class in `useSearchParams`\n            searchParams: url.searchParams,\n            pathname: (0, _hasbasepath.hasBasePath)(url.pathname) ? (0, _removebasepath.removeBasePath)(url.pathname) : url.pathname\n        };\n    }, [\n        canonicalUrl\n    ]);\n    if (true) {\n        const { cache, tree } = state;\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, _react.useEffect)(()=>{\n            // Add `window.nd` for debugging purposes.\n            // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n            // @ts-ignore this is for debugging\n            window.nd = {\n                router: _approuterinstance.publicAppRouterInstance,\n                cache,\n                tree\n            };\n        }, [\n            cache,\n            tree\n        ]);\n    }\n    (0, _react.useEffect)(()=>{\n        // If the app is restored from bfcache, it's possible that\n        // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n        // would trigger the mpa navigation logic again from the lines below.\n        // This will restore the router to the initial state in the event that the app is restored from bfcache.\n        function handlePageShow(event) {\n            if (!event.persisted || !window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE) {\n                return;\n            }\n            // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n            // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n            // of the last MPA navigation.\n            globalMutable.pendingMpaPath = undefined;\n            (0, _useactionqueue.dispatchAppRouterAction)({\n                type: _routerreducertypes.ACTION_RESTORE,\n                url: new URL(window.location.href),\n                historyState: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n            });\n        }\n        window.addEventListener('pageshow', handlePageShow);\n        return ()=>{\n            window.removeEventListener('pageshow', handlePageShow);\n        };\n    }, []);\n    (0, _react.useEffect)(()=>{\n        // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n        // are caught and handled by the router.\n        function handleUnhandledRedirect(event) {\n            const error = 'reason' in event ? event.reason : event.error;\n            if ((0, _redirecterror.isRedirectError)(error)) {\n                event.preventDefault();\n                const url = (0, _redirect.getURLFromRedirectError)(error);\n                const redirectType = (0, _redirect.getRedirectTypeFromError)(error);\n                // TODO: This should access the router methods directly, rather than\n                // go through the public interface.\n                if (redirectType === _redirecterror.RedirectType.push) {\n                    _approuterinstance.publicAppRouterInstance.push(url, {});\n                } else {\n                    _approuterinstance.publicAppRouterInstance.replace(url, {});\n                }\n            }\n        }\n        window.addEventListener('error', handleUnhandledRedirect);\n        window.addEventListener('unhandledrejection', handleUnhandledRedirect);\n        return ()=>{\n            window.removeEventListener('error', handleUnhandledRedirect);\n            window.removeEventListener('unhandledrejection', handleUnhandledRedirect);\n        };\n    }, []);\n    // When mpaNavigation flag is set do a hard navigation to the new url.\n    // Infinitely suspend because we don't actually want to rerender any child\n    // components with the new URL and any entangled state updates shouldn't\n    // commit either (eg: useTransition isPending should stay true until the page\n    // unloads).\n    //\n    // This is a side effect in render. Don't try this at home, kids. It's\n    // probably safe because we know this is a singleton component and it's never\n    // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n    // but that's... fine?)\n    const { pushRef } = state;\n    if (pushRef.mpaNavigation) {\n        // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n        if (globalMutable.pendingMpaPath !== canonicalUrl) {\n            const location = window.location;\n            if (pushRef.pendingPush) {\n                location.assign(canonicalUrl);\n            } else {\n                location.replace(canonicalUrl);\n            }\n            globalMutable.pendingMpaPath = canonicalUrl;\n        }\n        // TODO-APP: Should we listen to navigateerror here to catch failed\n        // navigations somehow? And should we call window.stop() if a SPA navigation\n        // should interrupt an MPA one?\n        // NOTE: This is intentionally using `throw` instead of `use` because we're\n        // inside an externally mutable condition (pushRef.mpaNavigation), which\n        // violates the rules of hooks.\n        throw _unresolvedthenable.unresolvedThenable;\n    }\n    (0, _react.useEffect)(()=>{\n        const originalPushState = window.history.pushState.bind(window.history);\n        const originalReplaceState = window.history.replaceState.bind(window.history);\n        // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n        const applyUrlFromHistoryPushReplace = (url)=>{\n            const href = window.location.href;\n            const appHistoryState = window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE;\n            (0, _react.startTransition)(()=>{\n                (0, _useactionqueue.dispatchAppRouterAction)({\n                    type: _routerreducertypes.ACTION_RESTORE,\n                    url: new URL(url ?? href, href),\n                    historyState: appHistoryState\n                });\n            });\n        };\n        /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.pushState = function pushState(data, _unused, url) {\n            // TODO: Warn when Navigation API is available (navigation.navigate() should be used)\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if (data?.__NA || data?._N) {\n                return originalPushState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalPushState(data, _unused, url);\n        };\n        /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.replaceState = function replaceState(data, _unused, url) {\n            // TODO: Warn when Navigation API is available (navigation.navigate() should be used)\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if (data?.__NA || data?._N) {\n                return originalReplaceState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalReplaceState(data, _unused, url);\n        };\n        /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */ const onPopState = (event)=>{\n            if (!event.state) {\n                // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n                return;\n            }\n            // This case happens when the history entry was pushed by the `pages` router.\n            if (!event.state.__NA) {\n                window.location.reload();\n                return;\n            }\n            // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n            // Without startTransition works if the cache is there for this path\n            (0, _react.startTransition)(()=>{\n                (0, _approuterinstance.dispatchTraverseAction)(window.location.href, event.state.__PRIVATE_NEXTJS_INTERNALS_TREE);\n            });\n        };\n        // Register popstate event to call onPopstate.\n        window.addEventListener('popstate', onPopState);\n        return ()=>{\n            window.history.pushState = originalPushState;\n            window.history.replaceState = originalReplaceState;\n            window.removeEventListener('popstate', onPopState);\n        };\n    }, []);\n    const { cache, tree, nextUrl, focusAndScrollRef, previousNextUrl } = state;\n    const matchingHead = (0, _react.useMemo)(()=>{\n        return (0, _findheadincache.findHeadInCache)(cache, tree[1]);\n    }, [\n        cache,\n        tree\n    ]);\n    // Add memoized pathParams for useParams.\n    const pathParams = (0, _react.useMemo)(()=>{\n        return (0, _computechangedpath.getSelectedParams)(tree);\n    }, [\n        tree\n    ]);\n    // Create instrumented promises for navigation hooks (dev-only)\n    // These are specially instrumented promises to show in the Suspense DevTools\n    // Promises are cached outside of render to survive suspense retries.\n    let instrumentedNavigationPromises = null;\n    if (true) {\n        const { createRootNavigationPromises } = __webpack_require__(/*! ./navigation-devtools */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation-devtools.js\");\n        instrumentedNavigationPromises = createRootNavigationPromises(tree, pathname, searchParams, pathParams);\n    }\n    const layoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            parentTree: tree,\n            parentCacheNode: cache,\n            parentSegmentPath: null,\n            parentParams: {},\n            // This is the <Activity> \"name\" that shows up in the Suspense DevTools.\n            // It represents the root of the app.\n            debugNameContext: '/',\n            // Root node always has `url`\n            // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n            url: canonicalUrl,\n            // Root segment is always active\n            isActive: true\n        };\n    }, [\n        tree,\n        cache,\n        canonicalUrl\n    ]);\n    const globalLayoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            tree,\n            focusAndScrollRef,\n            nextUrl,\n            previousNextUrl\n        };\n    }, [\n        tree,\n        focusAndScrollRef,\n        nextUrl,\n        previousNextUrl\n    ]);\n    let head;\n    if (matchingHead !== null) {\n        // The head is wrapped in an extra component so we can use\n        // `useDeferredValue` to swap between the prefetched and final versions of\n        // the head. (This is what LayoutRouter does for segment data, too.)\n        //\n        // The `key` is used to remount the component whenever the head moves to\n        // a different segment.\n        const [headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead;\n        head = /*#__PURE__*/ (0, _jsxruntime.jsx)(Head, {\n            headCacheNode: headCacheNode\n        },  false ? 0 : headKey);\n    } else {\n        head = null;\n    }\n    let content = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {\n        children: [\n            head,\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_boundarycomponents.RootLayoutBoundary, {\n                children: cache.rsc\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuterannouncer.AppRouterAnnouncer, {\n                tree: tree\n            })\n        ]\n    });\n    if (true) {\n        // In development, we apply few error boundaries and hot-reloader:\n        // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n        // - HotReloader:\n        //  - hot-reload the app when the code changes\n        //  - render dev overlay\n        //  - catch runtime errors and display global-error when necessary\n        if (true) {\n            const { DevRootHTTPAccessFallbackBoundary } = __webpack_require__(/*! ./dev-root-http-access-fallback-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/dev-root-http-access-fallback-boundary.js\");\n            content = /*#__PURE__*/ (0, _jsxruntime.jsx)(DevRootHTTPAccessFallbackBoundary, {\n                children: content\n            });\n        }\n        const HotReloader = (__webpack_require__(/*! ../dev/hot-reloader/app/hot-reloader-app */ \"(app-pages-browser)/./node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js\")[\"default\"]);\n        content = /*#__PURE__*/ (0, _jsxruntime.jsx)(HotReloader, {\n            globalError: globalError,\n            webSocket: webSocket,\n            staticIndicatorState: staticIndicatorState,\n            children: content\n        });\n    } else {}\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(HistoryUpdater, {\n                appRouterState: state\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(RuntimeStyles, {}),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.NavigationPromisesContext.Provider, {\n                value: instrumentedNavigationPromises,\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {\n                    value: pathParams,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathnameContext.Provider, {\n                        value: pathname,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {\n                            value: searchParams,\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.GlobalLayoutRouterContext.Provider, {\n                                value: globalLayoutRouterContext,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {\n                                    value: _approuterinstance.publicAppRouterInstance,\n                                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {\n                                        value: layoutRouterContext,\n                                        children: content\n                                    })\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        ]\n    });\n}\n_c2 = Router;\nfunction AppRouter({ actionQueue, globalErrorState, webSocket, staticIndicatorState }) {\n    (0, _navfailurehandler.useNavFailureHandler)();\n    const router = /*#__PURE__*/ (0, _jsxruntime.jsx)(Router, {\n        actionQueue: actionQueue,\n        globalError: globalErrorState,\n        webSocket: webSocket,\n        staticIndicatorState: staticIndicatorState\n    });\n    // At the very top level, use the default GlobalError component as the final fallback.\n    // When the app router itself fails, which means the framework itself fails, we show the default error.\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_rooterrorboundary.default, {\n        errorComponent: _globalerror.default,\n        children: router\n    });\n}\n_c3 = AppRouter;\nconst runtimeStyles = new Set();\nlet runtimeStyleChanged = new Set();\nglobalThis._N_E_STYLE_LOAD = function(href) {\n    let len = runtimeStyles.size;\n    runtimeStyles.add(href);\n    if (runtimeStyles.size !== len) {\n        runtimeStyleChanged.forEach((cb)=>cb());\n    }\n    // TODO figure out how to get a promise here\n    // But maybe it's not necessary as react would block rendering until it's loaded\n    return Promise.resolve();\n};\nfunction RuntimeStyles() {\n    _s();\n    const [, forceUpdate] = _react.default.useState(0);\n    const renderedStylesSize = runtimeStyles.size;\n    (0, _react.useEffect)(()=>{\n        const changed = ()=>forceUpdate((c)=>c + 1);\n        runtimeStyleChanged.add(changed);\n        if (renderedStylesSize !== runtimeStyles.size) {\n            changed();\n        }\n        return ()=>{\n            runtimeStyleChanged.delete(changed);\n        };\n    }, [\n        renderedStylesSize,\n        forceUpdate\n    ]);\n    const dplId = (0, _deploymentid.getDeploymentIdQueryOrEmptyString)();\n    return [\n        ...runtimeStyles\n    ].map((href, i)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"stylesheet\",\n            href: `${href}${dplId}`,\n            // @ts-ignore\n            precedence: \"next\"\n        }, i));\n}\n_s(RuntimeStyles, \"Eht7Kgdrrgt5B4LSklQ7qDPo8Aw=\");\n_c4 = RuntimeStyles;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router.js.map\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"HistoryUpdater\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Router\");\n$RefreshReg$(_c3, \"AppRouter\");\n$RefreshReg$(_c4, \"RuntimeStyles\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7MkNBeWlCQTs7O2VBQXdCQTs7Ozs7OzZFQW5pQmpCOzJEQUtBO2dEQUV3QjsrQ0FLRzs2REFPM0I7NENBQ2lEO2dEQUNyQjs4Q0FDRjs2Q0FDRDtnREFDRzs0Q0FDSjt5Q0FDSDtnREFDTTsrQ0FDRzsrQ0FNOUI7c0NBQzJEOzJDQUNwQjttQ0FDYjt3RkFDSDtrRkFDQztnREFDSTswQ0FFZTtBQUVsRCxNQUFNQyxnQkFFRixDQUFDO0FBRUwsd0JBQXdCLEVBQ3RCRSxjQUFjLEVBR2Y7SUFDQ0MsQ0FBQUEsR0FBQUEsT0FBQUEsa0JBQUFBLEVBQW1CO1FBQ2pCLElBQUlDLEtBQXdDLEVBQUUsRUFJN0M7UUFFRCxNQUFNLEVBQUVPLElBQUksRUFBRUMsT0FBTyxFQUFFQyxZQUFZLEVBQUVDLGNBQWMsRUFBRSxHQUFHWjtRQUV4RCxNQUFNYSxrQkFBbUM7WUFDdkNKO1lBQ0FHO1FBQ0Y7UUFFQSx3Q0FBd0M7UUFDeEMsTUFBTUUsZUFBZTtZQUNuQixHQUFJSixRQUFRSywwQkFBMEIsR0FBR1YsT0FBT1csT0FBTyxDQUFDQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO1lBQ2xFLHlDQUF5QztZQUN6QyxrRkFBa0Y7WUFDbEYsaUZBQWlGO1lBQ2pGQyxNQUFNO1lBQ05DLGlDQUFpQ047UUFDbkM7UUFDQSxJQUNFSCxRQUFRVSxXQUFXLElBQ25CLCtGQUErRjtRQUMvRiwyREFBMkQ7UUFDM0RDLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0IsSUFBSUMsSUFBSWpCLE9BQU9rQixRQUFRLENBQUNDLElBQUksT0FBT2IsY0FDckQ7WUFDQSxxSkFBcUo7WUFDckpELFFBQVFVLFdBQVcsR0FBRztZQUN0QmYsT0FBT1csT0FBTyxDQUFDUyxTQUFTLENBQUNYLGNBQWMsSUFBSUg7UUFDN0MsT0FBTztZQUNM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WUFDTGQsb0JBQW9CZ0IsTUFBTSxDQUFDRjtRQUM3QjtJQUNGLEdBQUc7UUFBQ0Q7UUFBb0JIO0tBQVk7SUFFcEMsTUFBTU8sUUFBUUMsQ0FBQUEsR0FBQUEsY0FBQUEsaUNBQUFBO0lBQ2QsT0FBTztXQUFJcEI7S0FBYyxDQUFDcUIsR0FBRyxDQUFDLENBQUNqSSxNQUFNa0ksSUFBQUEsV0FBQUEsR0FDbkMscUJBQUNDLFFBQUFBO1lBRUNDLEtBQUk7WUFDSnBJLE1BQU0sR0FBR0EsT0FBTytILE9BQU87WUFDdkIsYUFBYTtZQUNiTSxZQUFXO1dBSk5IO0FBVVg7O01BM0JTbkMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yeWFucm9zenRvY3p5L0RldmVsb3BtZW50L3NyYy9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHtcbiAgdXNlRWZmZWN0LFxuICB1c2VNZW1vLFxuICBzdGFydFRyYW5zaXRpb24sXG4gIHVzZUluc2VydGlvbkVmZmVjdCxcbiAgdXNlRGVmZXJyZWRWYWx1ZSxcbn0gZnJvbSAncmVhY3QnXG5pbXBvcnQge1xuICBBcHBSb3V0ZXJDb250ZXh0LFxuICBMYXlvdXRSb3V0ZXJDb250ZXh0LFxuICBHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0LFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLXR5cGVzJ1xuaW1wb3J0IHsgQUNUSU9OX1JFU1RPUkUgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHR5cGUge1xuICBBcHBIaXN0b3J5U3RhdGUsXG4gIEFwcFJvdXRlclN0YXRlLFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHtcbiAgU2VhcmNoUGFyYW1zQ29udGV4dCxcbiAgUGF0aG5hbWVDb250ZXh0LFxuICBQYXRoUGFyYW1zQ29udGV4dCxcbiAgTmF2aWdhdGlvblByb21pc2VzQ29udGV4dCxcbiAgdHlwZSBOYXZpZ2F0aW9uUHJvbWlzZXMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbiwgdXNlQWN0aW9uUXVldWUgfSBmcm9tICcuL3VzZS1hY3Rpb24tcXVldWUnXG5pbXBvcnQgeyBBcHBSb3V0ZXJBbm5vdW5jZXIgfSBmcm9tICcuL2FwcC1yb3V0ZXItYW5ub3VuY2VyJ1xuaW1wb3J0IHsgUmVkaXJlY3RCb3VuZGFyeSB9IGZyb20gJy4vcmVkaXJlY3QtYm91bmRhcnknXG5pbXBvcnQgeyBmaW5kSGVhZEluQ2FjaGUgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2ZpbmQtaGVhZC1pbi1jYWNoZSdcbmltcG9ydCB7IHVucmVzb2x2ZWRUaGVuYWJsZSB9IGZyb20gJy4vdW5yZXNvbHZlZC10aGVuYWJsZSdcbmltcG9ydCB7IHJlbW92ZUJhc2VQYXRoIH0gZnJvbSAnLi4vcmVtb3ZlLWJhc2UtcGF0aCdcbmltcG9ydCB7IGhhc0Jhc2VQYXRoIH0gZnJvbSAnLi4vaGFzLWJhc2UtcGF0aCdcbmltcG9ydCB7IGdldFNlbGVjdGVkUGFyYW1zIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9jb21wdXRlLWNoYW5nZWQtcGF0aCdcbmltcG9ydCB7IHVzZU5hdkZhaWx1cmVIYW5kbGVyIH0gZnJvbSAnLi9uYXYtZmFpbHVyZS1oYW5kbGVyJ1xuaW1wb3J0IHtcbiAgZGlzcGF0Y2hUcmF2ZXJzZUFjdGlvbixcbiAgcHVibGljQXBwUm91dGVySW5zdGFuY2UsXG4gIHR5cGUgQXBwUm91dGVyQWN0aW9uUXVldWUsXG4gIHR5cGUgR2xvYmFsRXJyb3JTdGF0ZSxcbn0gZnJvbSAnLi9hcHAtcm91dGVyLWluc3RhbmNlJ1xuaW1wb3J0IHsgZ2V0UmVkaXJlY3RUeXBlRnJvbUVycm9yLCBnZXRVUkxGcm9tUmVkaXJlY3RFcnJvciB9IGZyb20gJy4vcmVkaXJlY3QnXG5pbXBvcnQgeyBpc1JlZGlyZWN0RXJyb3IsIFJlZGlyZWN0VHlwZSB9IGZyb20gJy4vcmVkaXJlY3QtZXJyb3InXG5pbXBvcnQgeyBwaW5nVmlzaWJsZUxpbmtzIH0gZnJvbSAnLi9saW5rcydcbmltcG9ydCBSb290RXJyb3JCb3VuZGFyeSBmcm9tICcuL2Vycm9ycy9yb290LWVycm9yLWJvdW5kYXJ5J1xuaW1wb3J0IERlZmF1bHRHbG9iYWxFcnJvciBmcm9tICcuL2J1aWx0aW4vZ2xvYmFsLWVycm9yJ1xuaW1wb3J0IHsgUm9vdExheW91dEJvdW5kYXJ5IH0gZnJvbSAnLi4vLi4vbGliL2ZyYW1ld29yay9ib3VuZGFyeS1jb21wb25lbnRzJ1xuaW1wb3J0IHR5cGUgeyBTdGF0aWNJbmRpY2F0b3JTdGF0ZSB9IGZyb20gJy4uL2Rldi9ob3QtcmVsb2FkZXIvYXBwL2hvdC1yZWxvYWRlci1hcHAnXG5pbXBvcnQgeyBnZXREZXBsb3ltZW50SWRRdWVyeU9yRW1wdHlTdHJpbmcgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2RlcGxveW1lbnQtaWQnXG5cbmNvbnN0IGdsb2JhbE11dGFibGU6IHtcbiAgcGVuZGluZ01wYVBhdGg/OiBzdHJpbmdcbn0gPSB7fVxuXG5mdW5jdGlvbiBIaXN0b3J5VXBkYXRlcih7XG4gIGFwcFJvdXRlclN0YXRlLFxufToge1xuICBhcHBSb3V0ZXJTdGF0ZTogQXBwUm91dGVyU3RhdGVcbn0pIHtcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0FQUF9OQVZfRkFJTF9IQU5ETElORykge1xuICAgICAgLy8gY2xlYXIgcGVuZGluZyBVUkwgYXMgbmF2aWdhdGlvbiBpcyBubyBsb25nZXJcbiAgICAgIC8vIGluIGZsaWdodFxuICAgICAgd2luZG93Lm5leHQuX19wZW5kaW5nVXJsID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgY29uc3QgeyB0cmVlLCBwdXNoUmVmLCBjYW5vbmljYWxVcmwsIHJlbmRlcmVkU2VhcmNoIH0gPSBhcHBSb3V0ZXJTdGF0ZVxuXG4gICAgY29uc3QgYXBwSGlzdG9yeVN0YXRlOiBBcHBIaXN0b3J5U3RhdGUgPSB7XG4gICAgICB0cmVlLFxuICAgICAgcmVuZGVyZWRTZWFyY2gsXG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIE5hdmlnYXRpb24gQVBJIGlmIGF2YWlsYWJsZVxuICAgIGNvbnN0IGhpc3RvcnlTdGF0ZSA9IHtcbiAgICAgIC4uLihwdXNoUmVmLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlID8gd2luZG93Lmhpc3Rvcnkuc3RhdGUgOiB7fSksXG4gICAgICAvLyBJZGVudGlmaWVyIGlzIHNob3J0ZW5lZCBpbnRlbnRpb25hbGx5LlxuICAgICAgLy8gX19OQSBpcyB1c2VkIHRvIGlkZW50aWZ5IGlmIHRoZSBoaXN0b3J5IGVudHJ5IGNhbiBiZSBoYW5kbGVkIGJ5IHRoZSBhcHAtcm91dGVyLlxuICAgICAgLy8gX19OIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIG9sZCByb3V0ZXIuXG4gICAgICBfX05BOiB0cnVlLFxuICAgICAgX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRTogYXBwSGlzdG9yeVN0YXRlLFxuICAgIH1cbiAgICBpZiAoXG4gICAgICBwdXNoUmVmLnBlbmRpbmdQdXNoICYmXG4gICAgICAvLyBTa2lwIHB1c2hpbmcgYW4gYWRkaXRpb25hbCBoaXN0b3J5IGVudHJ5IGlmIHRoZSBjYW5vbmljYWxVcmwgaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgdXJsLlxuICAgICAgLy8gVGhpcyBtaXJyb3JzIHRoZSBicm93c2VyIGJlaGF2aW9yIGZvciBub3JtYWwgbmF2aWdhdGlvbi5cbiAgICAgIGNyZWF0ZUhyZWZGcm9tVXJsKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpKSAhPT0gY2Fub25pY2FsVXJsXG4gICAgKSB7XG4gICAgICAvLyBUaGlzIGludGVudGlvbmFsbHkgbXV0YXRlcyBSZWFjdCBzdGF0ZSwgcHVzaFJlZiBpcyBvdmVyd3JpdHRlbiB0byBlbnN1cmUgYWRkaXRpb25hbCBwdXNoL3JlcGxhY2UgY2FsbHMgZG8gbm90IHRyaWdnZXIgYW4gYWRkaXRpb25hbCBoaXN0b3J5IGVudHJ5LlxuICAgICAgcHVzaFJlZi5wZW5kaW5nUHVzaCA9IGZhbHNlXG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgY2Fub25pY2FsVXJsKVxuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgY2Fub25pY2FsVXJsKVxuICAgIH1cbiAgfSwgW2FwcFJvdXRlclN0YXRlXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFRoZSBOZXh0LVVybCBhbmQgdGhlIGJhc2UgdHJlZSBtYXkgYWZmZWN0IHRoZSByZXN1bHQgb2YgYSBwcmVmZXRjaFxuICAgIC8vIHRhc2suIFJlLXByZWZldGNoIGFsbCB2aXNpYmxlIGxpbmtzIHdpdGggdGhlIHVwZGF0ZWQgdmFsdWVzLiBJbiBtb3N0XG4gICAgLy8gY2FzZXMsIHRoaXMgd2lsbCBub3QgcmVzdWx0IGluIGFueSBuZXcgbmV0d29yayByZXF1ZXN0cywgb25seSBpZlxuICAgIC8vIHRoZSBwcmVmZXRjaCByZXN1bHQgYWN0dWFsbHkgdmFyaWVzIG9uIG9uZSBvZiB0aGVzZSBpbnB1dHMuXG4gICAgcGluZ1Zpc2libGVMaW5rcyhhcHBSb3V0ZXJTdGF0ZS5uZXh0VXJsLCBhcHBSb3V0ZXJTdGF0ZS50cmVlKVxuICB9LCBbYXBwUm91dGVyU3RhdGUubmV4dFVybCwgYXBwUm91dGVyU3RhdGUudHJlZV0pXG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gY29weU5leHRKc0ludGVybmFsSGlzdG9yeVN0YXRlKGRhdGE6IGFueSkge1xuICBpZiAoZGF0YSA9PSBudWxsKSBkYXRhID0ge31cbiAgY29uc3QgY3VycmVudFN0YXRlID0gd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgY29uc3QgX19OQSA9IGN1cnJlbnRTdGF0ZT8uX19OQVxuICBpZiAoX19OQSkge1xuICAgIGRhdGEuX19OQSA9IF9fTkFcbiAgfVxuICBjb25zdCBfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFID1cbiAgICBjdXJyZW50U3RhdGU/Ll9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUVcbiAgaWYgKF9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUUpIHtcbiAgICBkYXRhLl9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUUgPSBfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFXG4gIH1cblxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBIZWFkKHtcbiAgaGVhZENhY2hlTm9kZSxcbn06IHtcbiAgaGVhZENhY2hlTm9kZTogQ2FjaGVOb2RlIHwgbnVsbFxufSk6IFJlYWN0LlJlYWN0Tm9kZSB7XG4gIC8vIElmIHRoaXMgc2VnbWVudCBoYXMgYSBgcHJlZmV0Y2hIZWFkYCwgaXQncyB0aGUgc3RhdGljYWxseSBwcmVmZXRjaGVkIGRhdGEuXG4gIC8vIFdlIHNob3VsZCB1c2UgdGhhdCBvbiBpbml0aWFsIHJlbmRlciBpbnN0ZWFkIG9mIGBoZWFkYC4gVGhlbiB3ZSdsbCBzd2l0Y2hcbiAgLy8gdG8gYGhlYWRgIHdoZW4gdGhlIGR5bmFtaWMgcmVzcG9uc2Ugc3RyZWFtcyBpbi5cbiAgY29uc3QgaGVhZCA9IGhlYWRDYWNoZU5vZGUgIT09IG51bGwgPyBoZWFkQ2FjaGVOb2RlLmhlYWQgOiBudWxsXG4gIGNvbnN0IHByZWZldGNoSGVhZCA9XG4gICAgaGVhZENhY2hlTm9kZSAhPT0gbnVsbCA/IGhlYWRDYWNoZU5vZGUucHJlZmV0Y2hIZWFkIDogbnVsbFxuXG4gIC8vIElmIG5vIHByZWZldGNoIGRhdGEgaXMgYXZhaWxhYmxlLCB0aGVuIHdlIGdvIHN0cmFpZ2h0IHRvIHJlbmRlcmluZyBgaGVhZGAuXG4gIGNvbnN0IHJlc29sdmVkUHJlZmV0Y2hSc2MgPSBwcmVmZXRjaEhlYWQgIT09IG51bGwgPyBwcmVmZXRjaEhlYWQgOiBoZWFkXG5cbiAgLy8gV2UgdXNlIGB1c2VEZWZlcnJlZFZhbHVlYCB0byBoYW5kbGUgc3dpdGNoaW5nIGJldHdlZW4gdGhlIHByZWZldGNoZWQgYW5kXG4gIC8vIGZpbmFsIHZhbHVlcy4gVGhlIHNlY29uZCBhcmd1bWVudCBpcyByZXR1cm5lZCBvbiBpbml0aWFsIHJlbmRlciwgdGhlbiBpdFxuICAvLyByZS1yZW5kZXJzIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50LlxuICByZXR1cm4gdXNlRGVmZXJyZWRWYWx1ZShoZWFkLCByZXNvbHZlZFByZWZldGNoUnNjKVxufVxuXG4vKipcbiAqIFRoZSBnbG9iYWwgcm91dGVyIHRoYXQgd3JhcHMgdGhlIGFwcGxpY2F0aW9uIGNvbXBvbmVudHMuXG4gKi9cbmZ1bmN0aW9uIFJvdXRlcih7XG4gIGFjdGlvblF1ZXVlLFxuICBnbG9iYWxFcnJvcixcbiAgd2ViU29ja2V0LFxuICBzdGF0aWNJbmRpY2F0b3JTdGF0ZSxcbn06IHtcbiAgYWN0aW9uUXVldWU6IEFwcFJvdXRlckFjdGlvblF1ZXVlXG4gIGdsb2JhbEVycm9yOiBHbG9iYWxFcnJvclN0YXRlXG4gIHdlYlNvY2tldDogV2ViU29ja2V0IHwgdW5kZWZpbmVkXG4gIHN0YXRpY0luZGljYXRvclN0YXRlOiBTdGF0aWNJbmRpY2F0b3JTdGF0ZSB8IHVuZGVmaW5lZFxufSkge1xuICBjb25zdCBzdGF0ZSA9IHVzZUFjdGlvblF1ZXVlKGFjdGlvblF1ZXVlKVxuICBjb25zdCB7IGNhbm9uaWNhbFVybCB9ID0gc3RhdGVcbiAgLy8gQWRkIG1lbW9pemVkIHBhdGhuYW1lL3F1ZXJ5IGZvciB1c2VTZWFyY2hQYXJhbXMgYW5kIHVzZVBhdGhuYW1lLlxuICBjb25zdCB7IHNlYXJjaFBhcmFtcywgcGF0aG5hbWUgfSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoXG4gICAgICBjYW5vbmljYWxVcmwsXG4gICAgICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICdodHRwOi8vbicgOiB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgIClcblxuICAgIHJldHVybiB7XG4gICAgICAvLyBUaGlzIGlzIHR1cm5lZCBpbnRvIGEgcmVhZG9ubHkgY2xhc3MgaW4gYHVzZVNlYXJjaFBhcmFtc2BcbiAgICAgIHNlYXJjaFBhcmFtczogdXJsLnNlYXJjaFBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBoYXNCYXNlUGF0aCh1cmwucGF0aG5hbWUpXG4gICAgICAgID8gcmVtb3ZlQmFzZVBhdGgodXJsLnBhdGhuYW1lKVxuICAgICAgICA6IHVybC5wYXRobmFtZSxcbiAgICB9XG4gIH0sIFtjYW5vbmljYWxVcmxdKVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgeyBjYWNoZSwgdHJlZSB9ID0gc3RhdGVcblxuICAgIC8vIFRoaXMgaG9vayBpcyBpbiBhIGNvbmRpdGlvbmFsIGJ1dCB0aGF0IGlzIG9rIGJlY2F1c2UgYHByb2Nlc3MuZW52Lk5PREVfRU5WYCBuZXZlciBjaGFuZ2VzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIC8vIEFkZCBgd2luZG93Lm5kYCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICAgICAgLy8gVGhpcyBpcyBub3QgbWVhbnQgZm9yIHVzZSBpbiBhcHBsaWNhdGlvbnMgYXMgY29uY3VycmVudCByZW5kZXJpbmcgd2lsbCBhZmZlY3QgdGhlIGNhY2hlL3RyZWUvcm91dGVyLlxuICAgICAgLy8gQHRzLWlnbm9yZSB0aGlzIGlzIGZvciBkZWJ1Z2dpbmdcbiAgICAgIHdpbmRvdy5uZCA9IHtcbiAgICAgICAgcm91dGVyOiBwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZSxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIHRyZWUsXG4gICAgICB9XG4gICAgfSwgW2NhY2hlLCB0cmVlXSlcbiAgfVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gSWYgdGhlIGFwcCBpcyByZXN0b3JlZCBmcm9tIGJmY2FjaGUsIGl0J3MgcG9zc2libGUgdGhhdFxuICAgIC8vIHB1c2hSZWYubXBhTmF2aWdhdGlvbiBpcyB0cnVlLCB3aGljaCB3b3VsZCBtZWFuIHRoYXQgYW55IHJlLXJlbmRlciBvZiB0aGlzIGNvbXBvbmVudFxuICAgIC8vIHdvdWxkIHRyaWdnZXIgdGhlIG1wYSBuYXZpZ2F0aW9uIGxvZ2ljIGFnYWluIGZyb20gdGhlIGxpbmVzIGJlbG93LlxuICAgIC8vIFRoaXMgd2lsbCByZXN0b3JlIHRoZSByb3V0ZXIgdG8gdGhlIGluaXRpYWwgc3RhdGUgaW4gdGhlIGV2ZW50IHRoYXQgdGhlIGFwcCBpcyByZXN0b3JlZCBmcm9tIGJmY2FjaGUuXG4gICAgZnVuY3Rpb24gaGFuZGxlUGFnZVNob3coZXZlbnQ6IFBhZ2VUcmFuc2l0aW9uRXZlbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIWV2ZW50LnBlcnNpc3RlZCB8fFxuICAgICAgICAhd2luZG93Lmhpc3Rvcnkuc3RhdGU/Ll9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUVcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgdGhlIHBlbmRpbmdNcGFQYXRoIHZhbHVlIHNvIHRoYXQgYSBzdWJzZXF1ZW50IE1QQSBuYXZpZ2F0aW9uIHRvIHRoZSBzYW1lIFVSTCBjYW4gYmUgdHJpZ2dlcmVkLlxuICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBpZiB0aGUgYnJvd3NlciByZXN0b3JlZCBmcm9tIGJmY2FjaGUsIHRoZSBwZW5kaW5nTXBhUGF0aCB3b3VsZCBzdGlsbCBiZSBzZXQgdG8gdGhlIHZhbHVlXG4gICAgICAvLyBvZiB0aGUgbGFzdCBNUEEgbmF2aWdhdGlvbi5cbiAgICAgIGdsb2JhbE11dGFibGUucGVuZGluZ01wYVBhdGggPSB1bmRlZmluZWRcblxuICAgICAgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oe1xuICAgICAgICB0eXBlOiBBQ1RJT05fUkVTVE9SRSxcbiAgICAgICAgdXJsOiBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSxcbiAgICAgICAgaGlzdG9yeVN0YXRlOiB3aW5kb3cuaGlzdG9yeS5zdGF0ZS5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZXNob3cnLCBoYW5kbGVQYWdlU2hvdylcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFnZXNob3cnLCBoYW5kbGVQYWdlU2hvdylcbiAgICB9XG4gIH0sIFtdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gRW5zdXJlIHRoYXQgYW55IHJlZGlyZWN0IGVycm9ycyB0aGF0IGJ1YmJsZSB1cCBvdXRzaWRlIG9mIHRoZSBSZWRpcmVjdEJvdW5kYXJ5XG4gICAgLy8gYXJlIGNhdWdodCBhbmQgaGFuZGxlZCBieSB0aGUgcm91dGVyLlxuICAgIGZ1bmN0aW9uIGhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0KFxuICAgICAgZXZlbnQ6IEVycm9yRXZlbnQgfCBQcm9taXNlUmVqZWN0aW9uRXZlbnRcbiAgICApIHtcbiAgICAgIGNvbnN0IGVycm9yID0gJ3JlYXNvbicgaW4gZXZlbnQgPyBldmVudC5yZWFzb24gOiBldmVudC5lcnJvclxuICAgICAgaWYgKGlzUmVkaXJlY3RFcnJvcihlcnJvcikpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICBjb25zdCB1cmwgPSBnZXRVUkxGcm9tUmVkaXJlY3RFcnJvcihlcnJvcilcbiAgICAgICAgY29uc3QgcmVkaXJlY3RUeXBlID0gZ2V0UmVkaXJlY3RUeXBlRnJvbUVycm9yKGVycm9yKVxuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBhY2Nlc3MgdGhlIHJvdXRlciBtZXRob2RzIGRpcmVjdGx5LCByYXRoZXIgdGhhblxuICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICAgICAgICBpZiAocmVkaXJlY3RUeXBlID09PSBSZWRpcmVjdFR5cGUucHVzaCkge1xuICAgICAgICAgIHB1YmxpY0FwcFJvdXRlckluc3RhbmNlLnB1c2godXJsLCB7fSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZS5yZXBsYWNlKHVybCwge30pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIGhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0KVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0KVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIGhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0KVxuICAgIH1cbiAgfSwgW10pXG5cbiAgLy8gV2hlbiBtcGFOYXZpZ2F0aW9uIGZsYWcgaXMgc2V0IGRvIGEgaGFyZCBuYXZpZ2F0aW9uIHRvIHRoZSBuZXcgdXJsLlxuICAvLyBJbmZpbml0ZWx5IHN1c3BlbmQgYmVjYXVzZSB3ZSBkb24ndCBhY3R1YWxseSB3YW50IHRvIHJlcmVuZGVyIGFueSBjaGlsZFxuICAvLyBjb21wb25lbnRzIHdpdGggdGhlIG5ldyBVUkwgYW5kIGFueSBlbnRhbmdsZWQgc3RhdGUgdXBkYXRlcyBzaG91bGRuJ3RcbiAgLy8gY29tbWl0IGVpdGhlciAoZWc6IHVzZVRyYW5zaXRpb24gaXNQZW5kaW5nIHNob3VsZCBzdGF5IHRydWUgdW50aWwgdGhlIHBhZ2VcbiAgLy8gdW5sb2FkcykuXG4gIC8vXG4gIC8vIFRoaXMgaXMgYSBzaWRlIGVmZmVjdCBpbiByZW5kZXIuIERvbid0IHRyeSB0aGlzIGF0IGhvbWUsIGtpZHMuIEl0J3NcbiAgLy8gcHJvYmFibHkgc2FmZSBiZWNhdXNlIHdlIGtub3cgdGhpcyBpcyBhIHNpbmdsZXRvbiBjb21wb25lbnQgYW5kIGl0J3MgbmV2ZXJcbiAgLy8gaW4gPE9mZnNjcmVlbj4uIEF0IGxlYXN0IEkgaG9wZSBzby4gKEl0IHdpbGwgcnVuIHR3aWNlIGluIGRldiBzdHJpY3QgbW9kZSxcbiAgLy8gYnV0IHRoYXQncy4uLiBmaW5lPylcbiAgY29uc3QgeyBwdXNoUmVmIH0gPSBzdGF0ZVxuICBpZiAocHVzaFJlZi5tcGFOYXZpZ2F0aW9uKSB7XG4gICAgLy8gaWYgdGhlcmUncyBhIHJlLXJlbmRlciwgd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGFub3RoZXIgcmVkaXJlY3QgaWYgb25lIGlzIGFscmVhZHkgaW4gZmxpZ2h0IHRvIHRoZSBzYW1lIFVSTFxuICAgIGlmIChnbG9iYWxNdXRhYmxlLnBlbmRpbmdNcGFQYXRoICE9PSBjYW5vbmljYWxVcmwpIHtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uXG4gICAgICBpZiAocHVzaFJlZi5wZW5kaW5nUHVzaCkge1xuICAgICAgICBsb2NhdGlvbi5hc3NpZ24oY2Fub25pY2FsVXJsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShjYW5vbmljYWxVcmwpXG4gICAgICB9XG5cbiAgICAgIGdsb2JhbE11dGFibGUucGVuZGluZ01wYVBhdGggPSBjYW5vbmljYWxVcmxcbiAgICB9XG4gICAgLy8gVE9ETy1BUFA6IFNob3VsZCB3ZSBsaXN0ZW4gdG8gbmF2aWdhdGVlcnJvciBoZXJlIHRvIGNhdGNoIGZhaWxlZFxuICAgIC8vIG5hdmlnYXRpb25zIHNvbWVob3c/IEFuZCBzaG91bGQgd2UgY2FsbCB3aW5kb3cuc3RvcCgpIGlmIGEgU1BBIG5hdmlnYXRpb25cbiAgICAvLyBzaG91bGQgaW50ZXJydXB0IGFuIE1QQSBvbmU/XG4gICAgLy8gTk9URTogVGhpcyBpcyBpbnRlbnRpb25hbGx5IHVzaW5nIGB0aHJvd2AgaW5zdGVhZCBvZiBgdXNlYCBiZWNhdXNlIHdlJ3JlXG4gICAgLy8gaW5zaWRlIGFuIGV4dGVybmFsbHkgbXV0YWJsZSBjb25kaXRpb24gKHB1c2hSZWYubXBhTmF2aWdhdGlvbiksIHdoaWNoXG4gICAgLy8gdmlvbGF0ZXMgdGhlIHJ1bGVzIG9mIGhvb2tzLlxuICAgIHRocm93IHVucmVzb2x2ZWRUaGVuYWJsZVxuICB9XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbFB1c2hTdGF0ZSA9IHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZS5iaW5kKHdpbmRvdy5oaXN0b3J5KVxuICAgIGNvbnN0IG9yaWdpbmFsUmVwbGFjZVN0YXRlID0gd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlLmJpbmQoXG4gICAgICB3aW5kb3cuaGlzdG9yeVxuICAgIClcblxuICAgIC8vIEVuc3VyZSB0aGUgY2Fub25pY2FsIFVSTCBpbiB0aGUgTmV4dC5qcyBSb3V0ZXIgaXMgdXBkYXRlZCB3aGVuIHRoZSBVUkwgaXMgY2hhbmdlZCBzbyB0aGF0IGB1c2VQYXRobmFtZWAgYW5kIGB1c2VTZWFyY2hQYXJhbXNgIGhvbGQgdGhlIHB1c2hlZCB2YWx1ZXMuXG4gICAgY29uc3QgYXBwbHlVcmxGcm9tSGlzdG9yeVB1c2hSZXBsYWNlID0gKFxuICAgICAgdXJsOiBzdHJpbmcgfCBVUkwgfCBudWxsIHwgdW5kZWZpbmVkXG4gICAgKSA9PiB7XG4gICAgICBjb25zdCBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICAgIGNvbnN0IGFwcEhpc3RvcnlTdGF0ZTogQXBwSGlzdG9yeVN0YXRlIHwgdW5kZWZpbmVkID1cbiAgICAgICAgd2luZG93Lmhpc3Rvcnkuc3RhdGU/Ll9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUVcblxuICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oe1xuICAgICAgICAgIHR5cGU6IEFDVElPTl9SRVNUT1JFLFxuICAgICAgICAgIHVybDogbmV3IFVSTCh1cmwgPz8gaHJlZiwgaHJlZiksXG4gICAgICAgICAgaGlzdG9yeVN0YXRlOiBhcHBIaXN0b3J5U3RhdGUsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdGNoIHB1c2hTdGF0ZSB0byBlbnN1cmUgZXh0ZXJuYWwgY2hhbmdlcyB0byB0aGUgaGlzdG9yeSBhcmUgcmVmbGVjdGVkIGluIHRoZSBOZXh0LmpzIFJvdXRlci5cbiAgICAgKiBFbnN1cmVzIE5leHQuanMgaW50ZXJuYWwgaGlzdG9yeSBzdGF0ZSBpcyBjb3BpZWQgdG8gdGhlIG5ldyBoaXN0b3J5IGVudHJ5LlxuICAgICAqIEVuc3VyZXMgdXNlUGF0aG5hbWUgYW5kIHVzZVNlYXJjaFBhcmFtcyBob2xkIHRoZSBuZXdseSBwcm92aWRlZCB1cmwuXG4gICAgICovXG4gICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID0gZnVuY3Rpb24gcHVzaFN0YXRlKFxuICAgICAgZGF0YTogYW55LFxuICAgICAgX3VudXNlZDogc3RyaW5nLFxuICAgICAgdXJsPzogc3RyaW5nIHwgVVJMIHwgbnVsbFxuICAgICk6IHZvaWQge1xuICAgICAgLy8gVE9ETzogV2FybiB3aGVuIE5hdmlnYXRpb24gQVBJIGlzIGF2YWlsYWJsZSAobmF2aWdhdGlvbi5uYXZpZ2F0ZSgpIHNob3VsZCBiZSB1c2VkKVxuICAgICAgLy8gQXZvaWQgYSBsb29wIHdoZW4gTmV4dC5qcyBpbnRlcm5hbHMgdHJpZ2dlciBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlXG4gICAgICBpZiAoZGF0YT8uX19OQSB8fCBkYXRhPy5fTikge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxQdXNoU3RhdGUoZGF0YSwgX3VudXNlZCwgdXJsKVxuICAgICAgfVxuXG4gICAgICBkYXRhID0gY29weU5leHRKc0ludGVybmFsSGlzdG9yeVN0YXRlKGRhdGEpXG5cbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgYXBwbHlVcmxGcm9tSGlzdG9yeVB1c2hSZXBsYWNlKHVybClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9yaWdpbmFsUHVzaFN0YXRlKGRhdGEsIF91bnVzZWQsIHVybClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXRjaCByZXBsYWNlU3RhdGUgdG8gZW5zdXJlIGV4dGVybmFsIGNoYW5nZXMgdG8gdGhlIGhpc3RvcnkgYXJlIHJlZmxlY3RlZCBpbiB0aGUgTmV4dC5qcyBSb3V0ZXIuXG4gICAgICogRW5zdXJlcyBOZXh0LmpzIGludGVybmFsIGhpc3Rvcnkgc3RhdGUgaXMgY29waWVkIHRvIHRoZSBuZXcgaGlzdG9yeSBlbnRyeS5cbiAgICAgKiBFbnN1cmVzIHVzZVBhdGhuYW1lIGFuZCB1c2VTZWFyY2hQYXJhbXMgaG9sZCB0aGUgbmV3bHkgcHJvdmlkZWQgdXJsLlxuICAgICAqL1xuICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShcbiAgICAgIGRhdGE6IGFueSxcbiAgICAgIF91bnVzZWQ6IHN0cmluZyxcbiAgICAgIHVybD86IHN0cmluZyB8IFVSTCB8IG51bGxcbiAgICApOiB2b2lkIHtcbiAgICAgIC8vIFRPRE86IFdhcm4gd2hlbiBOYXZpZ2F0aW9uIEFQSSBpcyBhdmFpbGFibGUgKG5hdmlnYXRpb24ubmF2aWdhdGUoKSBzaG91bGQgYmUgdXNlZClcbiAgICAgIC8vIEF2b2lkIGEgbG9vcCB3aGVuIE5leHQuanMgaW50ZXJuYWxzIHRyaWdnZXIgcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZVxuICAgICAgaWYgKGRhdGE/Ll9fTkEgfHwgZGF0YT8uX04pIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVwbGFjZVN0YXRlKGRhdGEsIF91bnVzZWQsIHVybClcbiAgICAgIH1cbiAgICAgIGRhdGEgPSBjb3B5TmV4dEpzSW50ZXJuYWxIaXN0b3J5U3RhdGUoZGF0YSlcblxuICAgICAgaWYgKHVybCkge1xuICAgICAgICBhcHBseVVybEZyb21IaXN0b3J5UHVzaFJlcGxhY2UodXJsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsUmVwbGFjZVN0YXRlKGRhdGEsIF91bnVzZWQsIHVybClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcG9wc3RhdGUgZXZlbnQsIHRoaXMgaXMgdXNlZCB0byBoYW5kbGUgYmFjay9mb3J3YXJkIGluIHRoZSBicm93c2VyLlxuICAgICAqIEJ5IGRlZmF1bHQgZGlzcGF0Y2hlcyBBQ1RJT05fUkVTVE9SRSwgaG93ZXZlciBpZiB0aGUgaGlzdG9yeSBlbnRyeSB3YXMgbm90IHB1c2hlZC9yZXBsYWNlZCBieSBhcHAtcm91dGVyIGl0IHdpbGwgcmVsb2FkIHRoZSBwYWdlLlxuICAgICAqIFRoYXQgY2FzZSBjYW4gaGFwcGVuIHdoZW4gdGhlIG9sZCByb3V0ZXIgaW5qZWN0ZWQgdGhlIGhpc3RvcnkgZW50cnkuXG4gICAgICovXG4gICAgY29uc3Qgb25Qb3BTdGF0ZSA9IChldmVudDogUG9wU3RhdGVFdmVudCkgPT4ge1xuICAgICAgaWYgKCFldmVudC5zdGF0ZSkge1xuICAgICAgICAvLyBUT0RPLUFQUDogdGhpcyBjYXNlIG9ubHkgaGFwcGVucyB3aGVuIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUgd2FzIGNhbGxlZCBvdXRzaWRlIG9mIE5leHQuanMuIEl0IHNob3VsZCBwcm9iYWJseSByZWxvYWQgdGhlIHBhZ2UgaW4gdGhpcyBjYXNlLlxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBjYXNlIGhhcHBlbnMgd2hlbiB0aGUgaGlzdG9yeSBlbnRyeSB3YXMgcHVzaGVkIGJ5IHRoZSBgcGFnZXNgIHJvdXRlci5cbiAgICAgIGlmICghZXZlbnQuc3RhdGUuX19OQSkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE8tQVBQOiBJZGVhbGx5IHRoZSBiYWNrIGJ1dHRvbiBzaG91bGQgbm90IHVzZSBzdGFydFRyYW5zaXRpb24gYXMgaXQgc2hvdWxkIGFwcGx5IHRoZSB1cGRhdGVzIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIFdpdGhvdXQgc3RhcnRUcmFuc2l0aW9uIHdvcmtzIGlmIHRoZSBjYWNoZSBpcyB0aGVyZSBmb3IgdGhpcyBwYXRoXG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaFRyYXZlcnNlQWN0aW9uKFxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgIGV2ZW50LnN0YXRlLl9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUVcbiAgICAgICAgKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBwb3BzdGF0ZSBldmVudCB0byBjYWxsIG9uUG9wc3RhdGUuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSlcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID0gb3JpZ2luYWxQdXNoU3RhdGVcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSA9IG9yaWdpbmFsUmVwbGFjZVN0YXRlXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgY29uc3QgeyBjYWNoZSwgdHJlZSwgbmV4dFVybCwgZm9jdXNBbmRTY3JvbGxSZWYsIHByZXZpb3VzTmV4dFVybCB9ID0gc3RhdGVcblxuICBjb25zdCBtYXRjaGluZ0hlYWQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gZmluZEhlYWRJbkNhY2hlKGNhY2hlLCB0cmVlWzFdKVxuICB9LCBbY2FjaGUsIHRyZWVdKVxuXG4gIC8vIEFkZCBtZW1vaXplZCBwYXRoUGFyYW1zIGZvciB1c2VQYXJhbXMuXG4gIGNvbnN0IHBhdGhQYXJhbXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gZ2V0U2VsZWN0ZWRQYXJhbXModHJlZSlcbiAgfSwgW3RyZWVdKVxuXG4gIC8vIENyZWF0ZSBpbnN0cnVtZW50ZWQgcHJvbWlzZXMgZm9yIG5hdmlnYXRpb24gaG9va3MgKGRldi1vbmx5KVxuICAvLyBUaGVzZSBhcmUgc3BlY2lhbGx5IGluc3RydW1lbnRlZCBwcm9taXNlcyB0byBzaG93IGluIHRoZSBTdXNwZW5zZSBEZXZUb29sc1xuICAvLyBQcm9taXNlcyBhcmUgY2FjaGVkIG91dHNpZGUgb2YgcmVuZGVyIHRvIHN1cnZpdmUgc3VzcGVuc2UgcmV0cmllcy5cbiAgbGV0IGluc3RydW1lbnRlZE5hdmlnYXRpb25Qcm9taXNlczogTmF2aWdhdGlvblByb21pc2VzIHwgbnVsbCA9IG51bGxcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCB7IGNyZWF0ZVJvb3ROYXZpZ2F0aW9uUHJvbWlzZXMgfSA9XG4gICAgICByZXF1aXJlKCcuL25hdmlnYXRpb24tZGV2dG9vbHMnKSBhcyB0eXBlb2YgaW1wb3J0KCcuL25hdmlnYXRpb24tZGV2dG9vbHMnKVxuXG4gICAgaW5zdHJ1bWVudGVkTmF2aWdhdGlvblByb21pc2VzID0gY3JlYXRlUm9vdE5hdmlnYXRpb25Qcm9taXNlcyhcbiAgICAgIHRyZWUsXG4gICAgICBwYXRobmFtZSxcbiAgICAgIHNlYXJjaFBhcmFtcyxcbiAgICAgIHBhdGhQYXJhbXNcbiAgICApXG4gIH1cblxuICBjb25zdCBsYXlvdXRSb3V0ZXJDb250ZXh0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudFRyZWU6IHRyZWUsXG4gICAgICBwYXJlbnRDYWNoZU5vZGU6IGNhY2hlLFxuICAgICAgcGFyZW50U2VnbWVudFBhdGg6IG51bGwsXG4gICAgICBwYXJlbnRQYXJhbXM6IHt9LFxuICAgICAgLy8gVGhpcyBpcyB0aGUgPEFjdGl2aXR5PiBcIm5hbWVcIiB0aGF0IHNob3dzIHVwIGluIHRoZSBTdXNwZW5zZSBEZXZUb29scy5cbiAgICAgIC8vIEl0IHJlcHJlc2VudHMgdGhlIHJvb3Qgb2YgdGhlIGFwcC5cbiAgICAgIGRlYnVnTmFtZUNvbnRleHQ6ICcvJyxcbiAgICAgIC8vIFJvb3Qgbm9kZSBhbHdheXMgaGFzIGB1cmxgXG4gICAgICAvLyBQcm92aWRlZCBpbiBBcHBUcmVlQ29udGV4dCB0byBlbnN1cmUgaXQgY2FuIGJlIG92ZXJ3cml0dGVuIGluIGxheW91dC1yb3V0ZXJcbiAgICAgIHVybDogY2Fub25pY2FsVXJsLFxuICAgICAgLy8gUm9vdCBzZWdtZW50IGlzIGFsd2F5cyBhY3RpdmVcbiAgICAgIGlzQWN0aXZlOiB0cnVlLFxuICAgIH1cbiAgfSwgW3RyZWUsIGNhY2hlLCBjYW5vbmljYWxVcmxdKVxuXG4gIGNvbnN0IGdsb2JhbExheW91dFJvdXRlckNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJlZSxcbiAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgbmV4dFVybCxcbiAgICAgIHByZXZpb3VzTmV4dFVybCxcbiAgICB9XG4gIH0sIFt0cmVlLCBmb2N1c0FuZFNjcm9sbFJlZiwgbmV4dFVybCwgcHJldmlvdXNOZXh0VXJsXSlcblxuICBsZXQgaGVhZFxuICBpZiAobWF0Y2hpbmdIZWFkICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIGhlYWQgaXMgd3JhcHBlZCBpbiBhbiBleHRyYSBjb21wb25lbnQgc28gd2UgY2FuIHVzZVxuICAgIC8vIGB1c2VEZWZlcnJlZFZhbHVlYCB0byBzd2FwIGJldHdlZW4gdGhlIHByZWZldGNoZWQgYW5kIGZpbmFsIHZlcnNpb25zIG9mXG4gICAgLy8gdGhlIGhlYWQuIChUaGlzIGlzIHdoYXQgTGF5b3V0Um91dGVyIGRvZXMgZm9yIHNlZ21lbnQgZGF0YSwgdG9vLilcbiAgICAvL1xuICAgIC8vIFRoZSBga2V5YCBpcyB1c2VkIHRvIHJlbW91bnQgdGhlIGNvbXBvbmVudCB3aGVuZXZlciB0aGUgaGVhZCBtb3ZlcyB0b1xuICAgIC8vIGEgZGlmZmVyZW50IHNlZ21lbnQuXG4gICAgY29uc3QgW2hlYWRDYWNoZU5vZGUsIGhlYWRLZXksIGhlYWRLZXlXaXRob3V0U2VhcmNoUGFyYW1zXSA9IG1hdGNoaW5nSGVhZFxuXG4gICAgaGVhZCA9IChcbiAgICAgIDxIZWFkXG4gICAgICAgIGtleT17XG4gICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBQUFI6IG9taXQgc2VhcmNoIHBhcmFtcyBmcm9tIHRoZSBrZXkgdG8gbWF0Y2ggcHJlcmVuZGVyZWQga2V5c1xuICAgICAgICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gaGVhZEtleVdpdGhvdXRTZWFyY2hQYXJhbXMgOiBoZWFkS2V5XG4gICAgICAgIH1cbiAgICAgICAgaGVhZENhY2hlTm9kZT17aGVhZENhY2hlTm9kZX1cbiAgICAgIC8+XG4gICAgKVxuICB9IGVsc2Uge1xuICAgIGhlYWQgPSBudWxsXG4gIH1cblxuICBsZXQgY29udGVudCA9IChcbiAgICA8UmVkaXJlY3RCb3VuZGFyeT5cbiAgICAgIHtoZWFkfVxuICAgICAgey8qIFJvb3RMYXlvdXRCb3VuZGFyeSBlbmFibGVzIGRldGVjdGlvbiBvZiBTdXNwZW5zZSBib3VuZGFyaWVzIGFyb3VuZCB0aGUgcm9vdCBsYXlvdXQuXG4gICAgICAgICAgV2hlbiB1c2VycyB3cmFwIHRoZWlyIGxheW91dCBpbiA8U3VzcGVuc2U+LCB0aGlzIGNyZWF0ZXMgdGhlIGNvbXBvbmVudCBzdGFjayBwYXR0ZXJuXG4gICAgICAgICAgXCJTdXNwZW5zZSAtPiBSb290TGF5b3V0Qm91bmRhcnlcIiB3aGljaCBkeW5hbWljLXJlbmRlcmluZy50cyB1c2VzIHRvIGFsbG93IGR5bmFtaWMgcmVuZGVyaW5nLiAqL31cbiAgICAgIDxSb290TGF5b3V0Qm91bmRhcnk+e2NhY2hlLnJzY308L1Jvb3RMYXlvdXRCb3VuZGFyeT5cbiAgICAgIDxBcHBSb3V0ZXJBbm5vdW5jZXIgdHJlZT17dHJlZX0gLz5cbiAgICA8L1JlZGlyZWN0Qm91bmRhcnk+XG4gIClcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIEluIGRldmVsb3BtZW50LCB3ZSBhcHBseSBmZXcgZXJyb3IgYm91bmRhcmllcyBhbmQgaG90LXJlbG9hZGVyOlxuICAgIC8vIC0gRGV2Um9vdEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5OiBhdm9pZCB1c2luZyBuYXZpZ2F0aW9uIEFQSSBsaWtlIG5vdEZvdW5kKCkgaW4gcm9vdCBsYXlvdXRcbiAgICAvLyAtIEhvdFJlbG9hZGVyOlxuICAgIC8vICAtIGhvdC1yZWxvYWQgdGhlIGFwcCB3aGVuIHRoZSBjb2RlIGNoYW5nZXNcbiAgICAvLyAgLSByZW5kZXIgZGV2IG92ZXJsYXlcbiAgICAvLyAgLSBjYXRjaCBydW50aW1lIGVycm9ycyBhbmQgZGlzcGxheSBnbG9iYWwtZXJyb3Igd2hlbiBuZWNlc3NhcnlcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHsgRGV2Um9vdEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5IH0gPVxuICAgICAgICByZXF1aXJlKCcuL2Rldi1yb290LWh0dHAtYWNjZXNzLWZhbGxiYWNrLWJvdW5kYXJ5JykgYXMgdHlwZW9mIGltcG9ydCgnLi9kZXYtcm9vdC1odHRwLWFjY2Vzcy1mYWxsYmFjay1ib3VuZGFyeScpXG4gICAgICBjb250ZW50ID0gKFxuICAgICAgICA8RGV2Um9vdEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5PlxuICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICA8L0RldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeT5cbiAgICAgIClcbiAgICB9XG4gICAgY29uc3QgSG90UmVsb2FkZXI6IHR5cGVvZiBpbXBvcnQoJy4uL2Rldi9ob3QtcmVsb2FkZXIvYXBwL2hvdC1yZWxvYWRlci1hcHAnKS5kZWZhdWx0ID1cbiAgICAgIChcbiAgICAgICAgcmVxdWlyZSgnLi4vZGV2L2hvdC1yZWxvYWRlci9hcHAvaG90LXJlbG9hZGVyLWFwcCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL2Rldi9ob3QtcmVsb2FkZXIvYXBwL2hvdC1yZWxvYWRlci1hcHAnKVxuICAgICAgKS5kZWZhdWx0XG5cbiAgICBjb250ZW50ID0gKFxuICAgICAgPEhvdFJlbG9hZGVyXG4gICAgICAgIGdsb2JhbEVycm9yPXtnbG9iYWxFcnJvcn1cbiAgICAgICAgd2ViU29ja2V0PXt3ZWJTb2NrZXR9XG4gICAgICAgIHN0YXRpY0luZGljYXRvclN0YXRlPXtzdGF0aWNJbmRpY2F0b3JTdGF0ZX1cbiAgICAgID5cbiAgICAgICAge2NvbnRlbnR9XG4gICAgICA8L0hvdFJlbG9hZGVyPlxuICAgIClcbiAgfSBlbHNlIHtcbiAgICBjb250ZW50ID0gKFxuICAgICAgPFJvb3RFcnJvckJvdW5kYXJ5XG4gICAgICAgIGVycm9yQ29tcG9uZW50PXtnbG9iYWxFcnJvclswXX1cbiAgICAgICAgZXJyb3JTdHlsZXM9e2dsb2JhbEVycm9yWzFdfVxuICAgICAgPlxuICAgICAgICB7Y29udGVudH1cbiAgICAgIDwvUm9vdEVycm9yQm91bmRhcnk+XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPEhpc3RvcnlVcGRhdGVyIGFwcFJvdXRlclN0YXRlPXtzdGF0ZX0gLz5cbiAgICAgIDxSdW50aW1lU3R5bGVzIC8+XG4gICAgICA8TmF2aWdhdGlvblByb21pc2VzQ29udGV4dC5Qcm92aWRlclxuICAgICAgICB2YWx1ZT17aW5zdHJ1bWVudGVkTmF2aWdhdGlvblByb21pc2VzfVxuICAgICAgPlxuICAgICAgICA8UGF0aFBhcmFtc0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3BhdGhQYXJhbXN9PlxuICAgICAgICAgIDxQYXRobmFtZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3BhdGhuYW1lfT5cbiAgICAgICAgICAgIDxTZWFyY2hQYXJhbXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtzZWFyY2hQYXJhbXN9PlxuICAgICAgICAgICAgICA8R2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlclxuICAgICAgICAgICAgICAgIHZhbHVlPXtnbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgey8qIFRPRE86IFdlIHNob3VsZCBiZSBhYmxlIHRvIHJlbW92ZSB0aGlzIGNvbnRleHQuIHVzZVJvdXRlclxuICAgICAgICAgICAgICAgICAgICBzaG91bGQgaW1wb3J0IGZyb20gYXBwLXJvdXRlci1pbnN0YW5jZSBpbnN0ZWFkLiBJdCdzIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgbmVjZXNzYXJ5IGJlY2F1c2UgdXNlUm91dGVyIGlzIHNoYXJlZCBiZXR3ZWVuIFBhZ2VzIGFuZFxuICAgICAgICAgICAgICAgICAgICBBcHAgUm91dGVyLiBXZSBzaG91bGQgZm9yayB0aGF0IG1vZHVsZSwgdGhlbiByZW1vdmUgdGhpc1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0IHByb3ZpZGVyLiAqL31cbiAgICAgICAgICAgICAgICA8QXBwUm91dGVyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17cHVibGljQXBwUm91dGVySW5zdGFuY2V9PlxuICAgICAgICAgICAgICAgICAgPExheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2xheW91dFJvdXRlckNvbnRleHR9PlxuICAgICAgICAgICAgICAgICAgICB7Y29udGVudH1cbiAgICAgICAgICAgICAgICAgIDwvTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICAgICAgICA8L0FwcFJvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgICAgIDwvR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICAgIDwvU2VhcmNoUGFyYW1zQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICA8L1BhdGhuYW1lQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC9QYXRoUGFyYW1zQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgIDwvTmF2aWdhdGlvblByb21pc2VzQ29udGV4dC5Qcm92aWRlcj5cbiAgICA8Lz5cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBcHBSb3V0ZXIoe1xuICBhY3Rpb25RdWV1ZSxcbiAgZ2xvYmFsRXJyb3JTdGF0ZSxcbiAgd2ViU29ja2V0LFxuICBzdGF0aWNJbmRpY2F0b3JTdGF0ZSxcbn06IHtcbiAgYWN0aW9uUXVldWU6IEFwcFJvdXRlckFjdGlvblF1ZXVlXG4gIGdsb2JhbEVycm9yU3RhdGU6IEdsb2JhbEVycm9yU3RhdGVcbiAgd2ViU29ja2V0PzogV2ViU29ja2V0XG4gIHN0YXRpY0luZGljYXRvclN0YXRlPzogU3RhdGljSW5kaWNhdG9yU3RhdGVcbn0pIHtcbiAgdXNlTmF2RmFpbHVyZUhhbmRsZXIoKVxuXG4gIGNvbnN0IHJvdXRlciA9IChcbiAgICA8Um91dGVyXG4gICAgICBhY3Rpb25RdWV1ZT17YWN0aW9uUXVldWV9XG4gICAgICBnbG9iYWxFcnJvcj17Z2xvYmFsRXJyb3JTdGF0ZX1cbiAgICAgIHdlYlNvY2tldD17d2ViU29ja2V0fVxuICAgICAgc3RhdGljSW5kaWNhdG9yU3RhdGU9e3N0YXRpY0luZGljYXRvclN0YXRlfVxuICAgIC8+XG4gIClcblxuICAvLyBBdCB0aGUgdmVyeSB0b3AgbGV2ZWwsIHVzZSB0aGUgZGVmYXVsdCBHbG9iYWxFcnJvciBjb21wb25lbnQgYXMgdGhlIGZpbmFsIGZhbGxiYWNrLlxuICAvLyBXaGVuIHRoZSBhcHAgcm91dGVyIGl0c2VsZiBmYWlscywgd2hpY2ggbWVhbnMgdGhlIGZyYW1ld29yayBpdHNlbGYgZmFpbHMsIHdlIHNob3cgdGhlIGRlZmF1bHQgZXJyb3IuXG4gIHJldHVybiAoXG4gICAgPFJvb3RFcnJvckJvdW5kYXJ5IGVycm9yQ29tcG9uZW50PXtEZWZhdWx0R2xvYmFsRXJyb3J9PlxuICAgICAge3JvdXRlcn1cbiAgICA8L1Jvb3RFcnJvckJvdW5kYXJ5PlxuICApXG59XG5cbmNvbnN0IHJ1bnRpbWVTdHlsZXMgPSBuZXcgU2V0PHN0cmluZz4oKVxubGV0IHJ1bnRpbWVTdHlsZUNoYW5nZWQgPSBuZXcgU2V0PCgpID0+IHZvaWQ+KClcblxuZ2xvYmFsVGhpcy5fTl9FX1NUWUxFX0xPQUQgPSBmdW5jdGlvbiAoaHJlZjogc3RyaW5nKSB7XG4gIGxldCBsZW4gPSBydW50aW1lU3R5bGVzLnNpemVcbiAgcnVudGltZVN0eWxlcy5hZGQoaHJlZilcbiAgaWYgKHJ1bnRpbWVTdHlsZXMuc2l6ZSAhPT0gbGVuKSB7XG4gICAgcnVudGltZVN0eWxlQ2hhbmdlZC5mb3JFYWNoKChjYikgPT4gY2IoKSlcbiAgfVxuICAvLyBUT0RPIGZpZ3VyZSBvdXQgaG93IHRvIGdldCBhIHByb21pc2UgaGVyZVxuICAvLyBCdXQgbWF5YmUgaXQncyBub3QgbmVjZXNzYXJ5IGFzIHJlYWN0IHdvdWxkIGJsb2NrIHJlbmRlcmluZyB1bnRpbCBpdCdzIGxvYWRlZFxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbn1cblxuZnVuY3Rpb24gUnVudGltZVN0eWxlcygpIHtcbiAgY29uc3QgWywgZm9yY2VVcGRhdGVdID0gUmVhY3QudXNlU3RhdGUoMClcbiAgY29uc3QgcmVuZGVyZWRTdHlsZXNTaXplID0gcnVudGltZVN0eWxlcy5zaXplXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2hhbmdlZCA9ICgpID0+IGZvcmNlVXBkYXRlKChjKSA9PiBjICsgMSlcbiAgICBydW50aW1lU3R5bGVDaGFuZ2VkLmFkZChjaGFuZ2VkKVxuICAgIGlmIChyZW5kZXJlZFN0eWxlc1NpemUgIT09IHJ1bnRpbWVTdHlsZXMuc2l6ZSkge1xuICAgICAgY2hhbmdlZCgpXG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBydW50aW1lU3R5bGVDaGFuZ2VkLmRlbGV0ZShjaGFuZ2VkKVxuICAgIH1cbiAgfSwgW3JlbmRlcmVkU3R5bGVzU2l6ZSwgZm9yY2VVcGRhdGVdKVxuXG4gIGNvbnN0IGRwbElkID0gZ2V0RGVwbG95bWVudElkUXVlcnlPckVtcHR5U3RyaW5nKClcbiAgcmV0dXJuIFsuLi5ydW50aW1lU3R5bGVzXS5tYXAoKGhyZWYsIGkpID0+IChcbiAgICA8bGlua1xuICAgICAga2V5PXtpfVxuICAgICAgcmVsPVwic3R5bGVzaGVldFwiXG4gICAgICBocmVmPXtgJHtocmVmfSR7ZHBsSWR9YH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHByZWNlZGVuY2U9XCJuZXh0XCJcbiAgICAgIC8vIFRPRE8gZmlndXJlIG91dCBjcm9zc09yaWdpbiBhbmQgbm9uY2VcbiAgICAgIC8vIGNyb3NzT3JpZ2luPXtUT0RPfVxuICAgICAgLy8gbm9uY2U9e1RPRE99XG4gICAgLz5cbiAgKSlcbn1cbiJdLCJuYW1lcyI6WyJBcHBSb3V0ZXIiLCJnbG9iYWxNdXRhYmxlIiwiSGlzdG9yeVVwZGF0ZXIiLCJhcHBSb3V0ZXJTdGF0ZSIsInVzZUluc2VydGlvbkVmZmVjdCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HIiwid2luZG93IiwibmV4dCIsIl9fcGVuZGluZ1VybCIsInVuZGVmaW5lZCIsInRyZWUiLCJwdXNoUmVmIiwiY2Fub25pY2FsVXJsIiwicmVuZGVyZWRTZWFyY2giLCJhcHBIaXN0b3J5U3RhdGUiLCJoaXN0b3J5U3RhdGUiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImhpc3RvcnkiLCJzdGF0ZSIsIl9fTkEiLCJfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFIiwicGVuZGluZ1B1c2giLCJjcmVhdGVIcmVmRnJvbVVybCIsIlVSTCIsImxvY2F0aW9uIiwiaHJlZiIsInB1c2hTdGF0ZSIsInJlcGxhY2VTdGF0ZSIsInVzZUVmZmVjdCIsInBpbmdWaXNpYmxlTGlua3MiLCJuZXh0VXJsIiwiY29weU5leHRKc0ludGVybmFsSGlzdG9yeVN0YXRlIiwiZGF0YSIsImN1cnJlbnRTdGF0ZSIsIkhlYWQiLCJoZWFkQ2FjaGVOb2RlIiwiaGVhZCIsInByZWZldGNoSGVhZCIsInJlc29sdmVkUHJlZmV0Y2hSc2MiLCJ1c2VEZWZlcnJlZFZhbHVlIiwiUm91dGVyIiwiYWN0aW9uUXVldWUiLCJnbG9iYWxFcnJvciIsIndlYlNvY2tldCIsInN0YXRpY0luZGljYXRvclN0YXRlIiwidXNlQWN0aW9uUXVldWUiLCJzZWFyY2hQYXJhbXMiLCJwYXRobmFtZSIsInVzZU1lbW8iLCJ1cmwiLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiTk9ERV9FTlYiLCJjYWNoZSIsIm5kIiwicm91dGVyIiwicHVibGljQXBwUm91dGVySW5zdGFuY2UiLCJoYW5kbGVQYWdlU2hvdyIsImV2ZW50IiwicGVyc2lzdGVkIiwicGVuZGluZ01wYVBhdGgiLCJkaXNwYXRjaEFwcFJvdXRlckFjdGlvbiIsInR5cGUiLCJBQ1RJT05fUkVTVE9SRSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QiLCJlcnJvciIsInJlYXNvbiIsImlzUmVkaXJlY3RFcnJvciIsInByZXZlbnREZWZhdWx0IiwiZ2V0VVJMRnJvbVJlZGlyZWN0RXJyb3IiLCJyZWRpcmVjdFR5cGUiLCJnZXRSZWRpcmVjdFR5cGVGcm9tRXJyb3IiLCJSZWRpcmVjdFR5cGUiLCJwdXNoIiwicmVwbGFjZSIsIm1wYU5hdmlnYXRpb24iLCJhc3NpZ24iLCJ1bnJlc29sdmVkVGhlbmFibGUiLCJvcmlnaW5hbFB1c2hTdGF0ZSIsImJpbmQiLCJvcmlnaW5hbFJlcGxhY2VTdGF0ZSIsImFwcGx5VXJsRnJvbUhpc3RvcnlQdXNoUmVwbGFjZSIsInN0YXJ0VHJhbnNpdGlvbiIsIl91bnVzZWQiLCJfTiIsIm9uUG9wU3RhdGUiLCJyZWxvYWQiLCJkaXNwYXRjaFRyYXZlcnNlQWN0aW9uIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJwcmV2aW91c05leHRVcmwiLCJtYXRjaGluZ0hlYWQiLCJmaW5kSGVhZEluQ2FjaGUiLCJwYXRoUGFyYW1zIiwiZ2V0U2VsZWN0ZWRQYXJhbXMiLCJpbnN0cnVtZW50ZWROYXZpZ2F0aW9uUHJvbWlzZXMiLCJjcmVhdGVSb290TmF2aWdhdGlvblByb21pc2VzIiwicmVxdWlyZSIsImxheW91dFJvdXRlckNvbnRleHQiLCJwYXJlbnRUcmVlIiwicGFyZW50Q2FjaGVOb2RlIiwicGFyZW50U2VnbWVudFBhdGgiLCJwYXJlbnRQYXJhbXMiLCJkZWJ1Z05hbWVDb250ZXh0IiwiaXNBY3RpdmUiLCJnbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiaGVhZEtleSIsImhlYWRLZXlXaXRob3V0U2VhcmNoUGFyYW1zIiwiY29udGVudCIsIlJlZGlyZWN0Qm91bmRhcnkiLCJSb290TGF5b3V0Qm91bmRhcnkiLCJyc2MiLCJBcHBSb3V0ZXJBbm5vdW5jZXIiLCJEZXZSb290SFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkiLCJIb3RSZWxvYWRlciIsImRlZmF1bHQiLCJSb290RXJyb3JCb3VuZGFyeSIsImVycm9yQ29tcG9uZW50IiwiZXJyb3JTdHlsZXMiLCJSdW50aW1lU3R5bGVzIiwiTmF2aWdhdGlvblByb21pc2VzQ29udGV4dCIsIlByb3ZpZGVyIiwidmFsdWUiLCJQYXRoUGFyYW1zQ29udGV4dCIsIlBhdGhuYW1lQ29udGV4dCIsIlNlYXJjaFBhcmFtc0NvbnRleHQiLCJHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiQXBwUm91dGVyQ29udGV4dCIsIkxheW91dFJvdXRlckNvbnRleHQiLCJnbG9iYWxFcnJvclN0YXRlIiwidXNlTmF2RmFpbHVyZUhhbmRsZXIiLCJEZWZhdWx0R2xvYmFsRXJyb3IiLCJydW50aW1lU3R5bGVzIiwiU2V0IiwicnVudGltZVN0eWxlQ2hhbmdlZCIsImdsb2JhbFRoaXMiLCJfTl9FX1NUWUxFX0xPQUQiLCJsZW4iLCJzaXplIiwiYWRkIiwiZm9yRWFjaCIsImNiIiwiUHJvbWlzZSIsInJlc29sdmUiLCJmb3JjZVVwZGF0ZSIsIlJlYWN0IiwidXNlU3RhdGUiLCJyZW5kZXJlZFN0eWxlc1NpemUiLCJjaGFuZ2VkIiwiYyIsImRlbGV0ZSIsImRwbElkIiwiZ2V0RGVwbG95bWVudElkUXVlcnlPckVtcHR5U3RyaW5nIiwibWFwIiwiaSIsImxpbmsiLCJyZWwiLCJwcmVjZWRlbmNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"HTTPAccessFallbackBoundary\", ({\n    enumerable: true,\n    get: function() {\n        return HTTPAccessFallbackBoundary;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _navigationuntracked = __webpack_require__(/*! ../navigation-untracked */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation-untracked.js\");\nconst _httpaccessfallback = __webpack_require__(/*! ./http-access-fallback */ \"(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js\");\nconst _warnonce = __webpack_require__(/*! ../../../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nclass HTTPAccessFallbackErrorBoundary extends _react.default.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            triggeredStatus: undefined,\n            previousPathname: props.pathname\n        };\n    }\n    componentDidCatch() {\n        if ( true && this.props.missingSlots && this.props.missingSlots.size > 0 && // A missing children slot is the typical not-found case, so no need to warn\n        !this.props.missingSlots.has('children')) {\n            let warningMessage = 'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n';\n            const formattedSlots = Array.from(this.props.missingSlots).sort((a, b)=>a.localeCompare(b)).map((slot)=>`@${slot}`).join(', ');\n            warningMessage += 'Missing slots: ' + formattedSlots;\n            (0, _warnonce.warnOnce)(warningMessage);\n        }\n    }\n    static getDerivedStateFromError(error) {\n        if ((0, _httpaccessfallback.isHTTPAccessFallbackError)(error)) {\n            const httpStatus = (0, _httpaccessfallback.getAccessFallbackHTTPStatus)(error);\n            return {\n                triggeredStatus: httpStatus\n            };\n        }\n        // Re-throw if error is not for 404\n        throw error;\n    }\n    static getDerivedStateFromProps(props, state) {\n        /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */ if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n            return {\n                triggeredStatus: undefined,\n                previousPathname: props.pathname\n            };\n        }\n        return {\n            triggeredStatus: state.triggeredStatus,\n            previousPathname: props.pathname\n        };\n    }\n    render() {\n        const { notFound, forbidden, unauthorized, children } = this.props;\n        const { triggeredStatus } = this.state;\n        const errorComponents = {\n            [_httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n            [_httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n            [_httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized\n        };\n        if (triggeredStatus) {\n            const isNotFound = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND && notFound;\n            const isForbidden = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN && forbidden;\n            const isUnauthorized = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized;\n            // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n            if (!(isNotFound || isForbidden || isUnauthorized)) {\n                return children;\n            }\n            return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"robots\",\n                        content: \"noindex\"\n                    }),\n                     true && /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"boundary-next-error\",\n                        content: (0, _httpaccessfallback.getAccessFallbackErrorTypeByStatus)(triggeredStatus)\n                    }),\n                    errorComponents[triggeredStatus]\n                ]\n            });\n        }\n        return children;\n    }\n}\nfunction HTTPAccessFallbackBoundary({ notFound, forbidden, unauthorized, children }) {\n    // When we're rendering the missing params shell, this will return null. This\n    // is because we won't be rendering any not found boundaries or error\n    // boundaries for the missing params shell. When this runs on the client\n    // (where these error can occur), we will get the correct pathname.\n    const pathname = (0, _navigationuntracked.useUntrackedPathname)();\n    const missingSlots = (0, _react.useContext)(_approutercontextsharedruntime.MissingSlotContext);\n    const hasErrorFallback = !!(notFound || forbidden || unauthorized);\n    if (hasErrorFallback) {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(HTTPAccessFallbackErrorBoundary, {\n            pathname: pathname,\n            notFound: notFound,\n            forbidden: forbidden,\n            unauthorized: unauthorized,\n            missingSlots: missingSlots,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c = HTTPAccessFallbackBoundary;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary.js.map\nvar _c;\n$RefreshReg$(_c, \"HTTPAccessFallbackBoundary\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvaHR0cC1hY2Nlc3MtZmFsbGJhY2svZXJyb3ItYm91bmRhcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs4REF3SmdCQTs7O2VBQUFBOzs7Ozs2RUEzSWtCO2lEQUNHO2dEQU05QjtzQ0FDa0I7MkRBQ1U7QUFzQm5DLE1BQU1DLHdDQUF3Q0MsT0FBQUEsT0FBSyxDQUFDQyxTQUFTO0lBSTNEQyxZQUFZQyxLQUEyQyxDQUFFO1FBQ3ZELEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLEtBQUssR0FBRztZQUNYQyxpQkFBaUJDO1lBQ2pCQyxrQkFBa0JKLE1BQU1LLFFBQVE7UUFDbEM7SUFDRjtJQUVBQyxvQkFBMEI7UUFDeEIsSUFDRUMsS0FBb0IsSUFDcEIsSUFBSSxDQUFDUCxLQUFLLENBQUNVLFlBQVksSUFDdkIsSUFBSSxDQUFDVixLQUFLLENBQUNVLFlBQVksQ0FBQ0MsSUFBSSxHQUFHLEtBQy9CLDRFQUE0RTtRQUM1RSxDQUFDLElBQUksQ0FBQ1gsS0FBSyxDQUFDVSxZQUFZLENBQUNFLEdBQUcsQ0FBQyxhQUM3QjtZQUNBLElBQUlDLGlCQUNGLDRIQUNBO1lBRUYsTUFBTUMsaUJBQWlCQyxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDaEIsS0FBSyxDQUFDVSxZQUFZLEVBQ3RETyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRUUsYUFBYSxDQUFDRCxJQUMvQkUsR0FBRyxDQUFDLENBQUNDLE9BQVMsQ0FBQyxDQUFDLEVBQUVBLE1BQU0sRUFDeEJDLElBQUksQ0FBQztZQUVSVixrQkFBa0Isb0JBQW9CQztZQUV0Q1UsQ0FBQUEsR0FBQUEsVUFBQUEsUUFBQUEsRUFBU1g7UUFDWDtJQUNGO0lBRUEsT0FBT1kseUJBQXlCQyxLQUFVLEVBQUU7UUFDMUMsSUFBSUMsQ0FBQUEsR0FBQUEsb0JBQUFBLHlCQUFBQSxFQUEwQkQsUUFBUTtZQUNwQyxNQUFNRSxhQUFhQyxDQUFBQSxHQUFBQSxvQkFBQUEsMkJBQUFBLEVBQTRCSDtZQUMvQyxPQUFPO2dCQUNMeEIsaUJBQWlCMEI7WUFDbkI7UUFDRjtRQUNBLG1DQUFtQztRQUNuQyxNQUFNRjtJQUNSO0lBRUEsT0FBT0kseUJBQ0w5QixLQUEyQyxFQUMzQ0MsS0FBOEIsRUFDRTtRQUNoQzs7Ozs7S0FLQyxHQUNELElBQUlELE1BQU1LLFFBQVEsS0FBS0osTUFBTUcsZ0JBQWdCLElBQUlILE1BQU1DLGVBQWUsRUFBRTtZQUN0RSxPQUFPO2dCQUNMQSxpQkFBaUJDO2dCQUNqQkMsa0JBQWtCSixNQUFNSyxRQUFRO1lBQ2xDO1FBQ0Y7UUFDQSxPQUFPO1lBQ0xILGlCQUFpQkQsTUFBTUMsZUFBZTtZQUN0Q0Usa0JBQWtCSixNQUFNSyxRQUFRO1FBQ2xDO0lBQ0Y7SUFFQTBCLFNBQVM7UUFDUCxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxZQUFZLEVBQUVDLFFBQVEsRUFBRSxHQUFHLElBQUksQ0FBQ25DLEtBQUs7UUFDbEUsTUFBTSxFQUFFRSxlQUFlLEVBQUUsR0FBRyxJQUFJLENBQUNELEtBQUs7UUFDdEMsTUFBTW1DLGtCQUFrQjtZQUN0QixDQUFDQyxvQkFBQUEscUJBQXFCLENBQUNDLFNBQVMsQ0FBQyxFQUFFTjtZQUNuQyxDQUFDSyxvQkFBQUEscUJBQXFCLENBQUNFLFNBQVMsQ0FBQyxFQUFFTjtZQUNuQyxDQUFDSSxvQkFBQUEscUJBQXFCLENBQUNHLFlBQVksQ0FBQyxFQUFFTjtRQUN4QztRQUVBLElBQUloQyxpQkFBaUI7WUFDbkIsTUFBTXVDLGFBQ0p2QyxvQkFBb0JtQyxvQkFBQUEscUJBQXFCLENBQUNDLFNBQVMsSUFBSU47WUFDekQsTUFBTVUsY0FDSnhDLG9CQUFvQm1DLG9CQUFBQSxxQkFBcUIsQ0FBQ0UsU0FBUyxJQUFJTjtZQUN6RCxNQUFNVSxpQkFDSnpDLG9CQUFvQm1DLG9CQUFBQSxxQkFBcUIsQ0FBQ0csWUFBWSxJQUFJTjtZQUU1RCxrR0FBa0c7WUFDbEcsSUFBSSxDQUFFTyxDQUFBQSxjQUFjQyxlQUFlQyxjQUFBQSxDQUFhLEVBQUk7Z0JBQ2xELE9BQU9SO1lBQ1Q7WUFFQSxxQkFDRTs7a0NBQ0UscUJBQUNTLFFBQUFBO3dCQUFLQyxNQUFLO3dCQUFTQyxTQUFROzt5QkFDVyxJQUFiLGNBQ3hCLHFCQUFDRixRQUFBQTt3QkFDQ0MsTUFBSzt3QkFDTEMsU0FBU0MsQ0FBQUEsR0FBQUEsb0JBQUFBLGtDQUFBQSxFQUFtQzdDOztvQkFHL0NrQyxlQUFlLENBQUNsQyxnQkFBZ0I7OztRQUd2QztRQUVBLE9BQU9pQztJQUNUO0FBQ0Y7QUFFTyxvQ0FBb0MsRUFDekNILFFBQVEsRUFDUkMsU0FBUyxFQUNUQyxZQUFZLEVBQ1pDLFFBQVEsRUFDd0I7SUFDaEMsNkVBQTZFO0lBQzdFLHFFQUFxRTtJQUNyRSx3RUFBd0U7SUFDeEUsbUVBQW1FO0lBQ25FLE1BQU05QixXQUFXMkMsQ0FBQUEsR0FBQUEscUJBQUFBLG9CQUFBQTtJQUNqQixNQUFNdEMsZUFBZXVDLENBQUFBLEdBQUFBLE9BQUFBLFVBQUFBLEVBQVdDLCtCQUFBQSxrQkFBa0I7SUFDbEQsTUFBTUMsbUJBQW1CLENBQUMsQ0FBRW5CLENBQUFBLFlBQVlDLGFBQWFDLFlBQUFBLENBQVc7SUFFaEUsSUFBSWlCLGtCQUFrQjtRQUNwQixPQUNFLFdBREYsR0FDRSxxQkFBQ3ZELGlDQUFBQTtZQUNDUyxVQUFVQTtZQUNWMkIsVUFBVUE7WUFDVkMsV0FBV0E7WUFDWEMsY0FBY0E7WUFDZHhCLGNBQWNBO3NCQUVieUI7O0lBR1A7SUFFQSxxQkFBTztrQkFBR0E7O0FBQ1o7S0E3QmdCeEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yeWFucm9zenRvY3p5L3NyYy9jbGllbnQvY29tcG9uZW50cy9odHRwLWFjY2Vzcy1mYWxsYmFjay9lcnJvci1ib3VuZGFyeS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbi8qKlxuICogSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkgaXMgYSBib3VuZGFyeSB0aGF0IGNhdGNoZXMgZXJyb3JzIGFuZCByZW5kZXJzIGFcbiAqIGZhbGxiYWNrIGNvbXBvbmVudCBmb3IgSFRUUCBlcnJvcnMuXG4gKlxuICogSXQgcmVjZWl2ZXMgdGhlIHN0YXR1cyBjb2RlLCBhbmQgZGV0ZXJtaW5lIGlmIGl0IHNob3VsZCByZW5kZXIgZmFsbGJhY2tzIGZvciBmZXcgSFRUUCA0eHggZXJyb3JzLlxuICpcbiAqIGUuZy4gNDA0XG4gKiA0MDQgcmVwcmVzZW50cyBub3QgZm91bmQsIGFuZCB0aGUgZmFsbGJhY2sgY29tcG9uZW50IHBhaXIgY29udGFpbnMgdGhlIGNvbXBvbmVudCBhbmQgaXRzIHN0eWxlcy5cbiAqXG4gKi9cblxuaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZVVudHJhY2tlZFBhdGhuYW1lIH0gZnJvbSAnLi4vbmF2aWdhdGlvbi11bnRyYWNrZWQnXG5pbXBvcnQge1xuICBIVFRQQWNjZXNzRXJyb3JTdGF0dXMsXG4gIGdldEFjY2Vzc0ZhbGxiYWNrSFRUUFN0YXR1cyxcbiAgZ2V0QWNjZXNzRmFsbGJhY2tFcnJvclR5cGVCeVN0YXR1cyxcbiAgaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvcixcbn0gZnJvbSAnLi9odHRwLWFjY2Vzcy1mYWxsYmFjaydcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi91dGlscy93YXJuLW9uY2UnXG5pbXBvcnQgeyBNaXNzaW5nU2xvdENvbnRleHQgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcblxuaW50ZXJmYWNlIEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5UHJvcHMge1xuICBub3RGb3VuZD86IFJlYWN0LlJlYWN0Tm9kZVxuICBmb3JiaWRkZW4/OiBSZWFjdC5SZWFjdE5vZGVcbiAgdW5hdXRob3JpemVkPzogUmVhY3QuUmVhY3ROb2RlXG4gIC8vIFRPRE86IE1ha2UgdGhpcyByZXF1aXJlZCBvbmNlIGBSZWFjdC5jcmVhdGVFbGVtZW50YCB1bmRlcnN0YW5kcyB0aGF0IHBvc2l0aW9uYWwgYXJncyBnbyBpbnRvIGNoaWxkcmVuXG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlXG4gIG1pc3NpbmdTbG90cz86IFNldDxzdHJpbmc+XG59XG5cbmludGVyZmFjZSBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5UHJvcHNcbiAgZXh0ZW5kcyBIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeVByb3BzIHtcbiAgcGF0aG5hbWU6IHN0cmluZyB8IG51bGxcbiAgbWlzc2luZ1Nsb3RzPzogU2V0PHN0cmluZz5cbn1cblxuaW50ZXJmYWNlIEhUVFBBY2Nlc3NCb3VuZGFyeVN0YXRlIHtcbiAgdHJpZ2dlcmVkU3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWRcbiAgcHJldmlvdXNQYXRobmFtZTogc3RyaW5nIHwgbnVsbFxufVxuXG5jbGFzcyBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFxuICBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5UHJvcHMsXG4gIEhUVFBBY2Nlc3NCb3VuZGFyeVN0YXRlXG4+IHtcbiAgY29uc3RydWN0b3IocHJvcHM6IEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yQm91bmRhcnlQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB0cmlnZ2VyZWRTdGF0dXM6IHVuZGVmaW5lZCxcbiAgICAgIHByZXZpb3VzUGF0aG5hbWU6IHByb3BzLnBhdGhuYW1lLFxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZENhdGNoKCk6IHZvaWQge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICB0aGlzLnByb3BzLm1pc3NpbmdTbG90cyAmJlxuICAgICAgdGhpcy5wcm9wcy5taXNzaW5nU2xvdHMuc2l6ZSA+IDAgJiZcbiAgICAgIC8vIEEgbWlzc2luZyBjaGlsZHJlbiBzbG90IGlzIHRoZSB0eXBpY2FsIG5vdC1mb3VuZCBjYXNlLCBzbyBubyBuZWVkIHRvIHdhcm5cbiAgICAgICF0aGlzLnByb3BzLm1pc3NpbmdTbG90cy5oYXMoJ2NoaWxkcmVuJylcbiAgICApIHtcbiAgICAgIGxldCB3YXJuaW5nTWVzc2FnZSA9XG4gICAgICAgICdObyBkZWZhdWx0IGNvbXBvbmVudCB3YXMgZm91bmQgZm9yIGEgcGFyYWxsZWwgcm91dGUgcmVuZGVyZWQgb24gdGhpcyBwYWdlLiBGYWxsaW5nIGJhY2sgdG8gbmVhcmVzdCBOb3RGb3VuZCBib3VuZGFyeS5cXG4nICtcbiAgICAgICAgJ0xlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvcGFyYWxsZWwtcm91dGVzI2RlZmF1bHRqc1xcblxcbidcblxuICAgICAgY29uc3QgZm9ybWF0dGVkU2xvdHMgPSBBcnJheS5mcm9tKHRoaXMucHJvcHMubWlzc2luZ1Nsb3RzKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKVxuICAgICAgICAubWFwKChzbG90KSA9PiBgQCR7c2xvdH1gKVxuICAgICAgICAuam9pbignLCAnKVxuXG4gICAgICB3YXJuaW5nTWVzc2FnZSArPSAnTWlzc2luZyBzbG90czogJyArIGZvcm1hdHRlZFNsb3RzXG5cbiAgICAgIHdhcm5PbmNlKHdhcm5pbmdNZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3I6IGFueSkge1xuICAgIGlmIChpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yKGVycm9yKSkge1xuICAgICAgY29uc3QgaHR0cFN0YXR1cyA9IGdldEFjY2Vzc0ZhbGxiYWNrSFRUUFN0YXR1cyhlcnJvcilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyaWdnZXJlZFN0YXR1czogaHR0cFN0YXR1cyxcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciA0MDRcbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICBwcm9wczogSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVByb3BzLFxuICAgIHN0YXRlOiBIVFRQQWNjZXNzQm91bmRhcnlTdGF0ZVxuICApOiBIVFRQQWNjZXNzQm91bmRhcnlTdGF0ZSB8IG51bGwge1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgcmVzZXQgb2YgdGhlIGVycm9yIGJvdW5kYXJ5IHdoZW4gYSBuYXZpZ2F0aW9uIGhhcHBlbnMuXG4gICAgICogRW5zdXJlcyB0aGUgZXJyb3IgYm91bmRhcnkgZG9lcyBub3Qgc3RheSBlbmFibGVkIHdoZW4gbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlLlxuICAgICAqIEFwcHJvYWNoIG9mIHNldFN0YXRlIGluIHJlbmRlciBpcyBzYWZlIGFzIGl0IGNoZWNrcyB0aGUgcHJldmlvdXMgcGF0aG5hbWUgYW5kIHRoZW4gb3ZlcnJpZGVzXG4gICAgICogaXQgYXMgb3V0bGluZWQgaW4gaHR0cHM6Ly9yZWFjdC5kZXYvcmVmZXJlbmNlL3JlYWN0L3VzZVN0YXRlI3N0b3JpbmctaW5mb3JtYXRpb24tZnJvbS1wcmV2aW91cy1yZW5kZXJzXG4gICAgICovXG4gICAgaWYgKHByb3BzLnBhdGhuYW1lICE9PSBzdGF0ZS5wcmV2aW91c1BhdGhuYW1lICYmIHN0YXRlLnRyaWdnZXJlZFN0YXR1cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzOiB1bmRlZmluZWQsXG4gICAgICAgIHByZXZpb3VzUGF0aG5hbWU6IHByb3BzLnBhdGhuYW1lLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHJpZ2dlcmVkU3RhdHVzOiBzdGF0ZS50cmlnZ2VyZWRTdGF0dXMsXG4gICAgICBwcmV2aW91c1BhdGhuYW1lOiBwcm9wcy5wYXRobmFtZSxcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBub3RGb3VuZCwgZm9yYmlkZGVuLCB1bmF1dGhvcml6ZWQsIGNoaWxkcmVuIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyB0cmlnZ2VyZWRTdGF0dXMgfSA9IHRoaXMuc3RhdGVcbiAgICBjb25zdCBlcnJvckNvbXBvbmVudHMgPSB7XG4gICAgICBbSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLk5PVF9GT1VORF06IG5vdEZvdW5kLFxuICAgICAgW0hUVFBBY2Nlc3NFcnJvclN0YXR1cy5GT1JCSURERU5dOiBmb3JiaWRkZW4sXG4gICAgICBbSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLlVOQVVUSE9SSVpFRF06IHVuYXV0aG9yaXplZCxcbiAgICB9XG5cbiAgICBpZiAodHJpZ2dlcmVkU3RhdHVzKSB7XG4gICAgICBjb25zdCBpc05vdEZvdW5kID1cbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzID09PSBIVFRQQWNjZXNzRXJyb3JTdGF0dXMuTk9UX0ZPVU5EICYmIG5vdEZvdW5kXG4gICAgICBjb25zdCBpc0ZvcmJpZGRlbiA9XG4gICAgICAgIHRyaWdnZXJlZFN0YXR1cyA9PT0gSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLkZPUkJJRERFTiAmJiBmb3JiaWRkZW5cbiAgICAgIGNvbnN0IGlzVW5hdXRob3JpemVkID1cbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzID09PSBIVFRQQWNjZXNzRXJyb3JTdGF0dXMuVU5BVVRIT1JJWkVEICYmIHVuYXV0aG9yaXplZFxuXG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIG1hdGNoZWQgYm91bmRhcnkgaW4gdGhpcyBsYXllciwga2VlcCB0aHJvd2luZyB0aGUgZXJyb3IgYnkgcmVuZGVyaW5nIHRoZSBjaGlsZHJlblxuICAgICAgaWYgKCEoaXNOb3RGb3VuZCB8fCBpc0ZvcmJpZGRlbiB8fCBpc1VuYXV0aG9yaXplZCkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPG1ldGEgbmFtZT1cInJvYm90c1wiIGNvbnRlbnQ9XCJub2luZGV4XCIgLz5cbiAgICAgICAgICB7cHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgKFxuICAgICAgICAgICAgPG1ldGFcbiAgICAgICAgICAgICAgbmFtZT1cImJvdW5kYXJ5LW5leHQtZXJyb3JcIlxuICAgICAgICAgICAgICBjb250ZW50PXtnZXRBY2Nlc3NGYWxsYmFja0Vycm9yVHlwZUJ5U3RhdHVzKHRyaWdnZXJlZFN0YXR1cyl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgICAge2Vycm9yQ29tcG9uZW50c1t0cmlnZ2VyZWRTdGF0dXNdfVxuICAgICAgICA8Lz5cbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRyZW5cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkoe1xuICBub3RGb3VuZCxcbiAgZm9yYmlkZGVuLFxuICB1bmF1dGhvcml6ZWQsXG4gIGNoaWxkcmVuLFxufTogSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnlQcm9wcykge1xuICAvLyBXaGVuIHdlJ3JlIHJlbmRlcmluZyB0aGUgbWlzc2luZyBwYXJhbXMgc2hlbGwsIHRoaXMgd2lsbCByZXR1cm4gbnVsbC4gVGhpc1xuICAvLyBpcyBiZWNhdXNlIHdlIHdvbid0IGJlIHJlbmRlcmluZyBhbnkgbm90IGZvdW5kIGJvdW5kYXJpZXMgb3IgZXJyb3JcbiAgLy8gYm91bmRhcmllcyBmb3IgdGhlIG1pc3NpbmcgcGFyYW1zIHNoZWxsLiBXaGVuIHRoaXMgcnVucyBvbiB0aGUgY2xpZW50XG4gIC8vICh3aGVyZSB0aGVzZSBlcnJvciBjYW4gb2NjdXIpLCB3ZSB3aWxsIGdldCB0aGUgY29ycmVjdCBwYXRobmFtZS5cbiAgY29uc3QgcGF0aG5hbWUgPSB1c2VVbnRyYWNrZWRQYXRobmFtZSgpXG4gIGNvbnN0IG1pc3NpbmdTbG90cyA9IHVzZUNvbnRleHQoTWlzc2luZ1Nsb3RDb250ZXh0KVxuICBjb25zdCBoYXNFcnJvckZhbGxiYWNrID0gISEobm90Rm91bmQgfHwgZm9yYmlkZGVuIHx8IHVuYXV0aG9yaXplZClcblxuICBpZiAoaGFzRXJyb3JGYWxsYmFjaykge1xuICAgIHJldHVybiAoXG4gICAgICA8SFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVxuICAgICAgICBwYXRobmFtZT17cGF0aG5hbWV9XG4gICAgICAgIG5vdEZvdW5kPXtub3RGb3VuZH1cbiAgICAgICAgZm9yYmlkZGVuPXtmb3JiaWRkZW59XG4gICAgICAgIHVuYXV0aG9yaXplZD17dW5hdXRob3JpemVkfVxuICAgICAgICBtaXNzaW5nU2xvdHM9e21pc3NpbmdTbG90c31cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9IVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5PlxuICAgIClcbiAgfVxuXG4gIHJldHVybiA8PntjaGlsZHJlbn08Lz5cbn1cbiJdLCJuYW1lcyI6WyJIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSIsIkhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yQm91bmRhcnkiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJzdGF0ZSIsInRyaWdnZXJlZFN0YXR1cyIsInVuZGVmaW5lZCIsInByZXZpb3VzUGF0aG5hbWUiLCJwYXRobmFtZSIsImNvbXBvbmVudERpZENhdGNoIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwibWlzc2luZ1Nsb3RzIiwic2l6ZSIsImhhcyIsIndhcm5pbmdNZXNzYWdlIiwiZm9ybWF0dGVkU2xvdHMiLCJBcnJheSIsImZyb20iLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwibWFwIiwic2xvdCIsImpvaW4iLCJ3YXJuT25jZSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImVycm9yIiwiaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvciIsImh0dHBTdGF0dXMiLCJnZXRBY2Nlc3NGYWxsYmFja0hUVFBTdGF0dXMiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJyZW5kZXIiLCJub3RGb3VuZCIsImZvcmJpZGRlbiIsInVuYXV0aG9yaXplZCIsImNoaWxkcmVuIiwiZXJyb3JDb21wb25lbnRzIiwiSFRUUEFjY2Vzc0Vycm9yU3RhdHVzIiwiTk9UX0ZPVU5EIiwiRk9SQklEREVOIiwiVU5BVVRIT1JJWkVEIiwiaXNOb3RGb3VuZCIsImlzRm9yYmlkZGVuIiwiaXNVbmF1dGhvcml6ZWQiLCJtZXRhIiwibmFtZSIsImNvbnRlbnQiLCJnZXRBY2Nlc3NGYWxsYmFja0Vycm9yVHlwZUJ5U3RhdHVzIiwidXNlVW50cmFja2VkUGF0aG5hbWUiLCJ1c2VDb250ZXh0IiwiTWlzc2luZ1Nsb3RDb250ZXh0IiwiaGFzRXJyb3JGYWxsYmFjayJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/navigation.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    // We need the same class that was used to instantiate the context value\n    // Otherwise instanceof checks will fail in usercode\n    ReadonlyURLSearchParams: function() {\n        return _hooksclientcontextsharedruntime.ReadonlyURLSearchParams;\n    },\n    RedirectType: function() {\n        return _navigationreactserver.RedirectType;\n    },\n    ServerInsertedHTMLContext: function() {\n        return _serverinsertedhtmlsharedruntime.ServerInsertedHTMLContext;\n    },\n    forbidden: function() {\n        return _navigationreactserver.forbidden;\n    },\n    notFound: function() {\n        return _navigationreactserver.notFound;\n    },\n    permanentRedirect: function() {\n        return _navigationreactserver.permanentRedirect;\n    },\n    redirect: function() {\n        return _navigationreactserver.redirect;\n    },\n    unauthorized: function() {\n        return _navigationreactserver.unauthorized;\n    },\n    unstable_isUnrecognizedActionError: function() {\n        return _unrecognizedactionerror.unstable_isUnrecognizedActionError;\n    },\n    unstable_rethrow: function() {\n        return _navigationreactserver.unstable_rethrow;\n    },\n    useParams: function() {\n        return useParams;\n    },\n    usePathname: function() {\n        return usePathname;\n    },\n    useRouter: function() {\n        return useRouter;\n    },\n    useSearchParams: function() {\n        return useSearchParams;\n    },\n    useSelectedLayoutSegment: function() {\n        return useSelectedLayoutSegment;\n    },\n    useSelectedLayoutSegments: function() {\n        return useSelectedLayoutSegments;\n    },\n    useServerInsertedHTML: function() {\n        return _serverinsertedhtmlsharedruntime.useServerInsertedHTML;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../../shared/lib/hooks-client-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _segment = __webpack_require__(/*! ../../shared/lib/segment */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment.js\");\nconst _serverinsertedhtmlsharedruntime = __webpack_require__(/*! ../../shared/lib/server-inserted-html.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/server-inserted-html.shared-runtime.js\");\nconst _unrecognizedactionerror = __webpack_require__(/*! ./unrecognized-action-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/unrecognized-action-error.js\");\nconst _navigationreactserver = __webpack_require__(/*! ./navigation.react-server */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.react-server.js\");\nconst useDynamicRouteParams =  false ? 0 : undefined;\nconst useDynamicSearchParams =  false ? 0 : undefined;\nfunction useSearchParams() {\n    useDynamicSearchParams?.('useSearchParams()');\n    const searchParams = (0, _react.useContext)(_hooksclientcontextsharedruntime.SearchParamsContext);\n    // In the case where this is `null`, the compat types added in\n    // `next-env.d.ts` will add a new overload that changes the return type to\n    // include `null`.\n    const readonlySearchParams = (0, _react.useMemo)(()=>{\n        if (!searchParams) {\n            // When the router is not ready in pages, we won't have the search params\n            // available.\n            return null;\n        }\n        return new _hooksclientcontextsharedruntime.ReadonlyURLSearchParams(searchParams);\n    }, [\n        searchParams\n    ]);\n    // Instrument with Suspense DevTools (dev-only)\n    if ( true && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            return (0, _react.use)(navigationPromises.searchParams);\n        }\n    }\n    return readonlySearchParams;\n}\nfunction usePathname() {\n    useDynamicRouteParams?.('usePathname()');\n    // In the case where this is `null`, the compat types added in `next-env.d.ts`\n    // will add a new overload that changes the return type to include `null`.\n    const pathname = (0, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);\n    // Instrument with Suspense DevTools (dev-only)\n    if ( true && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            return (0, _react.use)(navigationPromises.pathname);\n        }\n    }\n    return pathname;\n}\nfunction useRouter() {\n    const router = (0, _react.useContext)(_approutercontextsharedruntime.AppRouterContext);\n    if (router === null) {\n        throw Object.defineProperty(new Error('invariant expected app router to be mounted'), \"__NEXT_ERROR_CODE\", {\n            value: \"E238\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return router;\n}\nfunction useParams() {\n    useDynamicRouteParams?.('useParams()');\n    const params = (0, _react.useContext)(_hooksclientcontextsharedruntime.PathParamsContext);\n    // Instrument with Suspense DevTools (dev-only)\n    if ( true && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            return (0, _react.use)(navigationPromises.params);\n        }\n    }\n    return params;\n}\nfunction useSelectedLayoutSegments(parallelRouteKey = 'children') {\n    useDynamicRouteParams?.('useSelectedLayoutSegments()');\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);\n    // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\n    if (!context) return null;\n    // Instrument with Suspense DevTools (dev-only)\n    if ( true && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            const promise = navigationPromises.selectedLayoutSegmentsPromises?.get(parallelRouteKey);\n            if (promise) {\n                // We should always have a promise here, but if we don't, it's not worth erroring over.\n                // We just won't be able to instrument it, but can still provide the value.\n                return (0, _react.use)(promise);\n            }\n        }\n    }\n    return (0, _segment.getSelectedLayoutSegmentPath)(context.parentTree, parallelRouteKey);\n}\nfunction useSelectedLayoutSegment(parallelRouteKey = 'children') {\n    _s();\n    useDynamicRouteParams?.('useSelectedLayoutSegment()');\n    const navigationPromises = (0, _react.useContext)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n    const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);\n    // Instrument with Suspense DevTools (dev-only)\n    if ( true && navigationPromises && 'use' in _react.default) {\n        const promise = navigationPromises.selectedLayoutSegmentPromises?.get(parallelRouteKey);\n        if (promise) {\n            // We should always have a promise here, but if we don't, it's not worth erroring over.\n            // We just won't be able to instrument it, but can still provide the value.\n            return (0, _react.use)(promise);\n        }\n    }\n    return (0, _segment.computeSelectedLayoutSegment)(selectedLayoutSegments, parallelRouteKey);\n}\n_s(useSelectedLayoutSegment, \"rc1U92JxkDTv7MNGlutCvlwOCmc=\", false, function() {\n    return [\n        useSelectedLayoutSegments\n    ];\n});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigation.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbmF2aWdhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQWdTRSx3RUFBd0U7SUFDeEUsb0RBQW9EO0lBQ3BEQSx1QkFBdUI7ZUFBdkJBLGlDQUFBQSx1QkFBdUI7O0lBUXZCQyxZQUFZO2VBQVpBLHVCQUFBQSxZQUFZOztJQWhMWkMseUJBQXlCO2VBQXpCQSxpQ0FBQUEseUJBQXlCOztJQTRLekJDLFNBQVM7ZUFBVEEsdUJBQUFBLFNBQVM7O0lBRFRDLFFBQVE7ZUFBUkEsdUJBQUFBLFFBQVE7O0lBSVJDLGlCQUFpQjtlQUFqQkEsdUJBQUFBLGlCQUFpQjs7SUFEakJDLFFBQVE7ZUFBUkEsdUJBQUFBLFFBQVE7O0lBRFJDLFlBQVk7ZUFBWkEsdUJBQUFBLFlBQVk7O0lBWExDLGtDQUFrQztlQUFsQ0EseUJBQUFBLGtDQUFrQzs7SUFlekNDLGdCQUFnQjtlQUFoQkEsdUJBQUFBLGdCQUFnQjs7SUEvSEZDLFNBQVM7ZUFBVEE7O0lBdEVBQyxXQUFXO2VBQVhBOztJQTJDQUMsU0FBUztlQUFUQTs7SUExRkFDLGVBQWU7ZUFBZkE7O0lBNE1BQyx3QkFBd0I7ZUFBeEJBOztJQTdDQUMseUJBQXlCO2VBQXpCQTs7SUEzRmRDLHFCQUFxQjtlQUFyQkEsaUNBQUFBLHFCQUFxQjs7Ozs2RUF6SHlCOzJEQUt6Qzs2REFPQTtxQ0FJQTs2REEwR0E7cURBZ0s0QzttREFnQjVDO0FBeFJQLE1BQU1DLHdCQUNKLE1BQTZCLEdBRXZCRSxDQUNxQixHQUN2QkM7QUFFTixNQUFNQyx5QkFDSixNQUE2QixHQUV2QkYsQ0FDc0IsR0FDeEJDO0FBdUJDLFNBQVNQO0lBQ2RRLHlCQUF5QjtJQUV6QixNQUFNQyxlQUFlQyxDQUFBQSxHQUFBQSxPQUFBQSxVQUFBQSxFQUFXQyxpQ0FBQUEsbUJBQW1CO0lBRW5ELDhEQUE4RDtJQUM5RCwwRUFBMEU7SUFDMUUsa0JB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UixDQUFBQSxHQUFBQSxPQUFBQSxVQUFBQSxFQUFXVSxpQ0FBQUEseUJBQXlCO0lBQy9ELE1BQU1nQixtREFBbURSO0lBRXpELCtDQUErQztJQUMvQyxJQUNFZCxLQUFvQixJQUNwQkksc0JBQ0EsU0FBU0QsT0FBQUEsT0FBSyxFQUNkO1FBQ0EsTUFBTWMsVUFDSmIsbUJBQW1CbUIsNkJBQTZCLEVBQUVKLElBQUlMO1FBQ3hELElBQUlHLFNBQVM7WUFDWCx1RkFBdUY7WUFDdkYsMkVBQTJFO1lBQzNFLE9BQU9aLENBQUFBLEdBQUFBLE9BQUFBLEdBQUFBLEVBQUlZO1FBQ2I7SUFDRjtJQUVBLE9BQU9PLENBQUFBLEdBQUFBLFNBQUFBLDRCQUFBQSxFQUE2QkYsd0JBQXdCUjtBQUM5RDtHQXZCZ0IzQjs7UUFLaUJDIiwic291cmNlcyI6WyIvVXNlcnMvcnlhbnJvc3p0b2N6eS9EZXZlbG9wbWVudC9zcmMvY2xpZW50L2NvbXBvbmVudHMvbmF2aWdhdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFBhcmFtcyB9IGZyb20gJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcydcblxuaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQsIHVzZU1lbW8sIHVzZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHtcbiAgQXBwUm91dGVyQ29udGV4dCxcbiAgTGF5b3V0Um91dGVyQ29udGV4dCxcbiAgdHlwZSBBcHBSb3V0ZXJJbnN0YW5jZSxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQge1xuICBTZWFyY2hQYXJhbXNDb250ZXh0LFxuICBQYXRobmFtZUNvbnRleHQsXG4gIFBhdGhQYXJhbXNDb250ZXh0LFxuICBOYXZpZ2F0aW9uUHJvbWlzZXNDb250ZXh0LFxuICBSZWFkb25seVVSTFNlYXJjaFBhcmFtcyxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9ob29rcy1jbGllbnQtY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7XG4gIGNvbXB1dGVTZWxlY3RlZExheW91dFNlZ21lbnQsXG4gIGdldFNlbGVjdGVkTGF5b3V0U2VnbWVudFBhdGgsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcblxuY29uc3QgdXNlRHluYW1pY1JvdXRlUGFyYW1zID1cbiAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCdcbiAgICA/IChcbiAgICAgICAgcmVxdWlyZSgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci9keW5hbWljLXJlbmRlcmluZycpXG4gICAgICApLnVzZUR5bmFtaWNSb3V0ZVBhcmFtc1xuICAgIDogdW5kZWZpbmVkXG5cbmNvbnN0IHVzZUR5bmFtaWNTZWFyY2hQYXJhbXMgPVxuICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJ1xuICAgID8gKFxuICAgICAgICByZXF1aXJlKCcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci9keW5hbWljLXJlbmRlcmluZycpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nJylcbiAgICAgICkudXNlRHluYW1pY1NlYXJjaFBhcmFtc1xuICAgIDogdW5kZWZpbmVkXG5cbi8qKlxuICogQSBbQ2xpZW50IENvbXBvbmVudF0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL2NsaWVudC1jb21wb25lbnRzKSBob29rXG4gKiB0aGF0IGxldHMgeW91ICpyZWFkKiB0aGUgY3VycmVudCBVUkwncyBzZWFyY2ggcGFyYW1ldGVycy5cbiAqXG4gKiBMZWFybiBtb3JlIGFib3V0IFtgVVJMU2VhcmNoUGFyYW1zYCBvbiBNRE5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9VUkxTZWFyY2hQYXJhbXMpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBcInVzZSBjbGllbnRcIlxuICogaW1wb3J0IHsgdXNlU2VhcmNoUGFyYW1zIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJ1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhZ2UoKSB7XG4gKiAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHVzZVNlYXJjaFBhcmFtcygpXG4gKiAgIHNlYXJjaFBhcmFtcy5nZXQoJ2ZvbycpIC8vIHJldHVybnMgJ2Jhcicgd2hlbiA/Zm9vPWJhclxuICogICAvLyAuLi5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgRG9jczogYHVzZVNlYXJjaFBhcmFtc2BdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2Utc2VhcmNoLXBhcmFtcylcbiAqL1xuLy8gQ2xpZW50IGNvbXBvbmVudHMgQVBJXG5leHBvcnQgZnVuY3Rpb24gdXNlU2VhcmNoUGFyYW1zKCk6IFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zIHtcbiAgdXNlRHluYW1pY1NlYXJjaFBhcmFtcz8uKCd1c2VTZWFyY2hQYXJhbXMoKScpXG5cbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gdXNlQ29udGV4dChTZWFyY2hQYXJhbXNDb250ZXh0KVxuXG4gIC8vIEluIHRoZSBjYXNlIHdoZXJlIHRoaXMgaXMgYG51bGxgLCB0aGUgY29tcGF0IHR5cGVzIGFkZGVkIGluXG4gIC8vIGBuZXh0LWVudi5kLnRzYCB3aWxsIGFkZCBhIG5ldyBvdmVybG9hZCB0aGF0IGNoYW5nZXMgdGhlIHJldHVybiB0eXBlIHRvXG4gIC8vIGluY2x1ZGUgYG51bGxgLlxuICBjb25zdCByZWFkb25seVNlYXJjaFBhcmFtcyA9IHVzZU1lbW8oKCk6IFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zID0+IHtcbiAgICBpZiAoIXNlYXJjaFBhcmFtcykge1xuICAgICAgLy8gV2hlbiB0aGUgcm91dGVyIGlzIG5vdCByZWFkeSBpbiBwYWdlcywgd2Ugd29uJ3QgaGF2ZSB0aGUgc2VhcmNoIHBhcmFtc1xuICAgICAgLy8gYXZhaWxhYmxlLlxuICAgICAgcmV0dXJuIG51bGwhXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZWFkb25seVVSTFNlYXJjaFBhcmFtcyhzZWFyY2hQYXJhbXMpXG4gIH0sIFtzZWFyY2hQYXJhbXNdKVxuXG4gIC8vIEluc3RydW1lbnQgd2l0aCBTdXNwZW5zZSBEZXZUb29scyAoZGV2LW9ubHkpXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICd1c2UnIGluIFJlYWN0KSB7XG4gICAgY29uc3QgbmF2aWdhdGlvblByb21pc2VzID0gdXNlKE5hdmlnYXRpb25Qcm9taXNlc0NvbnRleHQpXG4gICAgaWYgKG5hdmlnYXRpb25Qcm9taXNlcykge1xuICAgICAgcmV0dXJuIHVzZShuYXZpZ2F0aW9uUHJvbWlzZXMuc2VhcmNoUGFyYW1zKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkb25seVNlYXJjaFBhcmFtc1xufVxuXG4vKipcbiAqIEEgW0NsaWVudCBDb21wb25lbnRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykgaG9va1xuICogdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBjdXJyZW50IFVSTCdzIHBhdGhuYW1lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogXCJ1c2UgY2xpZW50XCJcbiAqIGltcG9ydCB7IHVzZVBhdGhuYW1lIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJ1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhZ2UoKSB7XG4gKiAgY29uc3QgcGF0aG5hbWUgPSB1c2VQYXRobmFtZSgpIC8vIHJldHVybnMgXCIvZGFzaGJvYXJkXCIgb24gL2Rhc2hib2FyZD9mb289YmFyXG4gKiAgLy8gLi4uXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGB1c2VQYXRobmFtZWBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2UtcGF0aG5hbWUpXG4gKi9cbi8vIENsaWVudCBjb21wb25lbnRzIEFQSVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhdGhuYW1lKCk6IHN0cmluZyB7XG4gIHVzZUR5bmFtaWNSb3V0ZVBhcmFtcz8uKCd1c2VQYXRobmFtZSgpJylcblxuICAvLyBJbiB0aGUgY2FzZSB3aGVyZSB0aGlzIGlzIGBudWxsYCwgdGhlIGNvbXBhdCB0eXBlcyBhZGRlZCBpbiBgbmV4dC1lbnYuZC50c2BcbiAgLy8gd2lsbCBhZGQgYSBuZXcgb3ZlcmxvYWQgdGhhdCBjaGFuZ2VzIHRoZSByZXR1cm4gdHlwZSB0byBpbmNsdWRlIGBudWxsYC5cbiAgY29uc3QgcGF0aG5hbWUgPSB1c2VDb250ZXh0KFBhdGhuYW1lQ29udGV4dCkgYXMgc3RyaW5nXG5cbiAgLy8gSW5zdHJ1bWVudCB3aXRoIFN1c3BlbnNlIERldlRvb2xzIChkZXYtb25seSlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgJ3VzZScgaW4gUmVhY3QpIHtcbiAgICBjb25zdCBuYXZpZ2F0aW9uUHJvbWlzZXMgPSB1c2UoTmF2aWdhdGlvblByb21pc2VzQ29udGV4dClcbiAgICBpZiAobmF2aWdhdGlvblByb21pc2VzKSB7XG4gICAgICByZXR1cm4gdXNlKG5hdmlnYXRpb25Qcm9taXNlcy5wYXRobmFtZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGF0aG5hbWVcbn1cblxuLy8gQ2xpZW50IGNvbXBvbmVudHMgQVBJXG5leHBvcnQge1xuICBTZXJ2ZXJJbnNlcnRlZEhUTUxDb250ZXh0LFxuICB1c2VTZXJ2ZXJJbnNlcnRlZEhUTUwsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvc2VydmVyLWluc2VydGVkLWh0bWwuc2hhcmVkLXJ1bnRpbWUnXG5cbi8qKlxuICpcbiAqIFRoaXMgaG9vayBhbGxvd3MgeW91IHRvIHByb2dyYW1tYXRpY2FsbHkgY2hhbmdlIHJvdXRlcyBpbnNpZGUgW0NsaWVudCBDb21wb25lbnRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBcInVzZSBjbGllbnRcIlxuICogaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJ1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhZ2UoKSB7XG4gKiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKClcbiAqICAvLyAuLi5cbiAqICByb3V0ZXIucHVzaCgnL2Rhc2hib2FyZCcpIC8vIE5hdmlnYXRlIHRvIC9kYXNoYm9hcmRcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgRG9jczogYHVzZVJvdXRlcmBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2Utcm91dGVyKVxuICovXG4vLyBDbGllbnQgY29tcG9uZW50cyBBUElcbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZXIoKTogQXBwUm91dGVySW5zdGFuY2Uge1xuICBjb25zdCByb3V0ZXIgPSB1c2VDb250ZXh0KEFwcFJvdXRlckNvbnRleHQpXG4gIGlmIChyb3V0ZXIgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCBleHBlY3RlZCBhcHAgcm91dGVyIHRvIGJlIG1vdW50ZWQnKVxuICB9XG5cbiAgcmV0dXJuIHJvdXRlclxufVxuXG4vKipcbiAqIEEgW0NsaWVudCBDb21wb25lbnRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykgaG9va1xuICogdGhhdCBsZXRzIHlvdSByZWFkIGEgcm91dGUncyBkeW5hbWljIHBhcmFtcyBmaWxsZWQgaW4gYnkgdGhlIGN1cnJlbnQgVVJMLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogXCJ1c2UgY2xpZW50XCJcbiAqIGltcG9ydCB7IHVzZVBhcmFtcyB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYWdlKCkge1xuICogICAvLyBvbiAvZGFzaGJvYXJkL1t0ZWFtXSB3aGVyZSBwYXRobmFtZSBpcyAvZGFzaGJvYXJkL25leHRqc1xuICogICBjb25zdCB7IHRlYW0gfSA9IHVzZVBhcmFtcygpIC8vIHRlYW0gPT09IFwibmV4dGpzXCJcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgRG9jczogYHVzZVBhcmFtc2BdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2UtcGFyYW1zKVxuICovXG4vLyBDbGllbnQgY29tcG9uZW50cyBBUElcbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXJhbXM8VCBleHRlbmRzIFBhcmFtcyA9IFBhcmFtcz4oKTogVCB7XG4gIHVzZUR5bmFtaWNSb3V0ZVBhcmFtcz8uKCd1c2VQYXJhbXMoKScpXG5cbiAgY29uc3QgcGFyYW1zID0gdXNlQ29udGV4dChQYXRoUGFyYW1zQ29udGV4dCkgYXMgVFxuXG4gIC8vIEluc3RydW1lbnQgd2l0aCBTdXNwZW5zZSBEZXZUb29scyAoZGV2LW9ubHkpXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICd1c2UnIGluIFJlYWN0KSB7XG4gICAgY29uc3QgbmF2aWdhdGlvblByb21pc2VzID0gdXNlKE5hdmlnYXRpb25Qcm9taXNlc0NvbnRleHQpXG4gICAgaWYgKG5hdmlnYXRpb25Qcm9taXNlcykge1xuICAgICAgcmV0dXJuIHVzZShuYXZpZ2F0aW9uUHJvbWlzZXMucGFyYW1zKSBhcyBUXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcmFtc1xufVxuXG4vKipcbiAqIEEgW0NsaWVudCBDb21wb25lbnRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykgaG9va1xuICogdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBhY3RpdmUgcm91dGUgc2VnbWVudHMgKipiZWxvdyoqIHRoZSBMYXlvdXQgaXQgaXMgY2FsbGVkIGZyb20uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiAndXNlIGNsaWVudCdcbiAqXG4gKiBpbXBvcnQgeyB1c2VTZWxlY3RlZExheW91dFNlZ21lbnRzIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJ1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEV4YW1wbGVDbGllbnRDb21wb25lbnQoKSB7XG4gKiAgIGNvbnN0IHNlZ21lbnRzID0gdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50cygpXG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDx1bD5cbiAqICAgICAgIHtzZWdtZW50cy5tYXAoKHNlZ21lbnQsIGluZGV4KSA9PiAoXG4gKiAgICAgICAgIDxsaSBrZXk9e2luZGV4fT57c2VnbWVudH08L2xpPlxuICogICAgICAgKSl9XG4gKiAgICAgPC91bD5cbiAqICAgKVxuICogfVxuICogYGBgXG4gKlxuICogUmVhZCBtb3JlOiBbTmV4dC5qcyBEb2NzOiBgdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50c2BdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2Utc2VsZWN0ZWQtbGF5b3V0LXNlZ21lbnRzKVxuICovXG4vLyBDbGllbnQgY29tcG9uZW50cyBBUElcbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWxlY3RlZExheW91dFNlZ21lbnRzKFxuICBwYXJhbGxlbFJvdXRlS2V5OiBzdHJpbmcgPSAnY2hpbGRyZW4nXG4pOiBzdHJpbmdbXSB7XG4gIHVzZUR5bmFtaWNSb3V0ZVBhcmFtcz8uKCd1c2VTZWxlY3RlZExheW91dFNlZ21lbnRzKCknKVxuXG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KExheW91dFJvdXRlckNvbnRleHQpXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBvbmx5IGhhcHBlbnMgaW4gYHBhZ2VzYC4gVHlwZSBpcyBvdmVyd3JpdHRlbiBpbiBuYXZpZ2F0aW9uLmQudHNcbiAgaWYgKCFjb250ZXh0KSByZXR1cm4gbnVsbFxuXG4gIC8vIEluc3RydW1lbnQgd2l0aCBTdXNwZW5zZSBEZXZUb29scyAoZGV2LW9ubHkpXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICd1c2UnIGluIFJlYWN0KSB7XG4gICAgY29uc3QgbmF2aWdhdGlvblByb21pc2VzID0gdXNlKE5hdmlnYXRpb25Qcm9taXNlc0NvbnRleHQpXG4gICAgaWYgKG5hdmlnYXRpb25Qcm9taXNlcykge1xuICAgICAgY29uc3QgcHJvbWlzZSA9XG4gICAgICAgIG5hdmlnYXRpb25Qcm9taXNlcy5zZWxlY3RlZExheW91dFNlZ21lbnRzUHJvbWlzZXM/LmdldChwYXJhbGxlbFJvdXRlS2V5KVxuICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgcHJvbWlzZSBoZXJlLCBidXQgaWYgd2UgZG9uJ3QsIGl0J3Mgbm90IHdvcnRoIGVycm9yaW5nIG92ZXIuXG4gICAgICAgIC8vIFdlIGp1c3Qgd29uJ3QgYmUgYWJsZSB0byBpbnN0cnVtZW50IGl0LCBidXQgY2FuIHN0aWxsIHByb3ZpZGUgdGhlIHZhbHVlLlxuICAgICAgICByZXR1cm4gdXNlKHByb21pc2UpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFNlbGVjdGVkTGF5b3V0U2VnbWVudFBhdGgoY29udGV4dC5wYXJlbnRUcmVlLCBwYXJhbGxlbFJvdXRlS2V5KVxufVxuXG4vKipcbiAqIEEgW0NsaWVudCBDb21wb25lbnRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykgaG9va1xuICogdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBhY3RpdmUgcm91dGUgc2VnbWVudCAqKm9uZSBsZXZlbCBiZWxvdyoqIHRoZSBMYXlvdXQgaXQgaXMgY2FsbGVkIGZyb20uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiAndXNlIGNsaWVudCdcbiAqIGltcG9ydCB7IHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudCB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFeGFtcGxlQ2xpZW50Q29tcG9uZW50KCkge1xuICogICBjb25zdCBzZWdtZW50ID0gdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50KClcbiAqXG4gKiAgIHJldHVybiA8cD5BY3RpdmUgc2VnbWVudDoge3NlZ21lbnR9PC9wPlxuICogfVxuICogYGBgXG4gKlxuICogUmVhZCBtb3JlOiBbTmV4dC5qcyBEb2NzOiBgdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50YF0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL3VzZS1zZWxlY3RlZC1sYXlvdXQtc2VnbWVudClcbiAqL1xuLy8gQ2xpZW50IGNvbXBvbmVudHMgQVBJXG5leHBvcnQgZnVuY3Rpb24gdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50KFxuICBwYXJhbGxlbFJvdXRlS2V5OiBzdHJpbmcgPSAnY2hpbGRyZW4nXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgdXNlRHluYW1pY1JvdXRlUGFyYW1zPy4oJ3VzZVNlbGVjdGVkTGF5b3V0U2VnbWVudCgpJylcbiAgY29uc3QgbmF2aWdhdGlvblByb21pc2VzID0gdXNlQ29udGV4dChOYXZpZ2F0aW9uUHJvbWlzZXNDb250ZXh0KVxuICBjb25zdCBzZWxlY3RlZExheW91dFNlZ21lbnRzID0gdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50cyhwYXJhbGxlbFJvdXRlS2V5KVxuXG4gIC8vIEluc3RydW1lbnQgd2l0aCBTdXNwZW5zZSBEZXZUb29scyAoZGV2LW9ubHkpXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgbmF2aWdhdGlvblByb21pc2VzICYmXG4gICAgJ3VzZScgaW4gUmVhY3RcbiAgKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9XG4gICAgICBuYXZpZ2F0aW9uUHJvbWlzZXMuc2VsZWN0ZWRMYXlvdXRTZWdtZW50UHJvbWlzZXM/LmdldChwYXJhbGxlbFJvdXRlS2V5KVxuICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAvLyBXZSBzaG91bGQgYWx3YXlzIGhhdmUgYSBwcm9taXNlIGhlcmUsIGJ1dCBpZiB3ZSBkb24ndCwgaXQncyBub3Qgd29ydGggZXJyb3Jpbmcgb3Zlci5cbiAgICAgIC8vIFdlIGp1c3Qgd29uJ3QgYmUgYWJsZSB0byBpbnN0cnVtZW50IGl0LCBidXQgY2FuIHN0aWxsIHByb3ZpZGUgdGhlIHZhbHVlLlxuICAgICAgcmV0dXJuIHVzZShwcm9taXNlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb21wdXRlU2VsZWN0ZWRMYXlvdXRTZWdtZW50KHNlbGVjdGVkTGF5b3V0U2VnbWVudHMsIHBhcmFsbGVsUm91dGVLZXkpXG59XG5cbmV4cG9ydCB7IHVuc3RhYmxlX2lzVW5yZWNvZ25pemVkQWN0aW9uRXJyb3IgfSBmcm9tICcuL3VucmVjb2duaXplZC1hY3Rpb24tZXJyb3InXG5cbi8vIFNoYXJlZCBjb21wb25lbnRzIEFQSXNcbmV4cG9ydCB7XG4gIC8vIFdlIG5lZWQgdGhlIHNhbWUgY2xhc3MgdGhhdCB3YXMgdXNlZCB0byBpbnN0YW50aWF0ZSB0aGUgY29udGV4dCB2YWx1ZVxuICAvLyBPdGhlcndpc2UgaW5zdGFuY2VvZiBjaGVja3Mgd2lsbCBmYWlsIGluIHVzZXJjb2RlXG4gIFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zLFxufVxuZXhwb3J0IHtcbiAgbm90Rm91bmQsXG4gIGZvcmJpZGRlbixcbiAgdW5hdXRob3JpemVkLFxuICByZWRpcmVjdCxcbiAgcGVybWFuZW50UmVkaXJlY3QsXG4gIFJlZGlyZWN0VHlwZSxcbiAgdW5zdGFibGVfcmV0aHJvdyxcbn0gZnJvbSAnLi9uYXZpZ2F0aW9uLnJlYWN0LXNlcnZlcidcbiJdLCJuYW1lcyI6WyJSZWFkb25seVVSTFNlYXJjaFBhcmFtcyIsIlJlZGlyZWN0VHlwZSIsIlNlcnZlckluc2VydGVkSFRNTENvbnRleHQiLCJmb3JiaWRkZW4iLCJub3RGb3VuZCIsInBlcm1hbmVudFJlZGlyZWN0IiwicmVkaXJlY3QiLCJ1bmF1dGhvcml6ZWQiLCJ1bnN0YWJsZV9pc1VucmVjb2duaXplZEFjdGlvbkVycm9yIiwidW5zdGFibGVfcmV0aHJvdyIsInVzZVBhcmFtcyIsInVzZVBhdGhuYW1lIiwidXNlUm91dGVyIiwidXNlU2VhcmNoUGFyYW1zIiwidXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50IiwidXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50cyIsInVzZVNlcnZlckluc2VydGVkSFRNTCIsInVzZUR5bmFtaWNSb3V0ZVBhcmFtcyIsIndpbmRvdyIsInJlcXVpcmUiLCJ1bmRlZmluZWQiLCJ1c2VEeW5hbWljU2VhcmNoUGFyYW1zIiwic2VhcmNoUGFyYW1zIiwidXNlQ29udGV4dCIsIlNlYXJjaFBhcmFtc0NvbnRleHQiLCJyZWFkb25seVNlYXJjaFBhcmFtcyIsInVzZU1lbW8iLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJSZWFjdCIsIm5hdmlnYXRpb25Qcm9taXNlcyIsInVzZSIsIk5hdmlnYXRpb25Qcm9taXNlc0NvbnRleHQiLCJwYXRobmFtZSIsIlBhdGhuYW1lQ29udGV4dCIsInJvdXRlciIsIkFwcFJvdXRlckNvbnRleHQiLCJFcnJvciIsInBhcmFtcyIsIlBhdGhQYXJhbXNDb250ZXh0IiwicGFyYWxsZWxSb3V0ZUtleSIsImNvbnRleHQiLCJMYXlvdXRSb3V0ZXJDb250ZXh0IiwicHJvbWlzZSIsInNlbGVjdGVkTGF5b3V0U2VnbWVudHNQcm9taXNlcyIsImdldCIsImdldFNlbGVjdGVkTGF5b3V0U2VnbWVudFBhdGgiLCJwYXJlbnRUcmVlIiwic2VsZWN0ZWRMYXlvdXRTZWdtZW50cyIsInNlbGVjdGVkTGF5b3V0U2VnbWVudFByb21pc2VzIiwiY29tcHV0ZVNlbGVjdGVkTGF5b3V0U2VnbWVudCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache/cache.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/segment-cache/cache.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    EntryStatus: function() {\n        return EntryStatus;\n    },\n    canNewFetchStrategyProvideMoreContent: function() {\n        return canNewFetchStrategyProvideMoreContent;\n    },\n    convertRouteTreeToFlightRouterState: function() {\n        return convertRouteTreeToFlightRouterState;\n    },\n    createDetachedSegmentCacheEntry: function() {\n        return createDetachedSegmentCacheEntry;\n    },\n    fetchRouteOnCacheMiss: function() {\n        return fetchRouteOnCacheMiss;\n    },\n    fetchSegmentOnCacheMiss: function() {\n        return fetchSegmentOnCacheMiss;\n    },\n    fetchSegmentPrefetchesUsingDynamicRequest: function() {\n        return fetchSegmentPrefetchesUsingDynamicRequest;\n    },\n    getCurrentCacheVersion: function() {\n        return getCurrentCacheVersion;\n    },\n    getStaleTimeMs: function() {\n        return getStaleTimeMs;\n    },\n    overwriteRevalidatingSegmentCacheEntry: function() {\n        return overwriteRevalidatingSegmentCacheEntry;\n    },\n    pingInvalidationListeners: function() {\n        return pingInvalidationListeners;\n    },\n    readOrCreateRevalidatingSegmentEntry: function() {\n        return readOrCreateRevalidatingSegmentEntry;\n    },\n    readOrCreateRouteCacheEntry: function() {\n        return readOrCreateRouteCacheEntry;\n    },\n    readOrCreateSegmentCacheEntry: function() {\n        return readOrCreateSegmentCacheEntry;\n    },\n    readRouteCacheEntry: function() {\n        return readRouteCacheEntry;\n    },\n    readSegmentCacheEntry: function() {\n        return readSegmentCacheEntry;\n    },\n    requestOptimisticRouteCacheEntry: function() {\n        return requestOptimisticRouteCacheEntry;\n    },\n    revalidateEntireCache: function() {\n        return revalidateEntireCache;\n    },\n    upgradeToPendingSegment: function() {\n        return upgradeToPendingSegment;\n    },\n    upsertSegmentEntry: function() {\n        return upsertSegmentEntry;\n    },\n    waitForSegmentCacheEntry: function() {\n        return waitForSegmentCacheEntry;\n    }\n});\nconst _approutertypes = __webpack_require__(/*! ../../../shared/lib/app-router-types */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-types.js\");\nconst _approuterheaders = __webpack_require__(/*! ../app-router-headers */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-headers.js\");\nconst _fetchserverresponse = __webpack_require__(/*! ../router-reducer/fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _scheduler = __webpack_require__(/*! ./scheduler */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache/scheduler.js\");\nconst _varypath = __webpack_require__(/*! ./vary-path */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache/vary-path.js\");\nconst _appbuildid = __webpack_require__(/*! ../../app-build-id */ \"(app-pages-browser)/./node_modules/next/dist/client/app-build-id.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../router-reducer/create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _cachekey = __webpack_require__(/*! ./cache-key */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache/cache-key.js\");\nconst _routeparams = __webpack_require__(/*! ../../route-params */ \"(app-pages-browser)/./node_modules/next/dist/client/route-params.js\");\nconst _cachemap = __webpack_require__(/*! ./cache-map */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache/cache-map.js\");\nconst _segmentvalueencoding = __webpack_require__(/*! ../../../shared/lib/segment-cache/segment-value-encoding */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment-cache/segment-value-encoding.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/next/dist/client/flight-data-helpers.js\");\nconst _navigatereducer = __webpack_require__(/*! ../router-reducer/reducers/navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _links = __webpack_require__(/*! ../links */ \"(app-pages-browser)/./node_modules/next/dist/client/components/links.js\");\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment.js\");\nconst _types = __webpack_require__(/*! ./types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache/types.js\");\nconst _promisewithresolvers = __webpack_require__(/*! ../../../shared/lib/promise-with-resolvers */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/promise-with-resolvers.js\");\nfunction getStaleTimeMs(staleTimeSeconds) {\n    return Math.max(staleTimeSeconds, 30) * 1000;\n}\nvar EntryStatus = /*#__PURE__*/ function(EntryStatus) {\n    EntryStatus[EntryStatus[\"Empty\"] = 0] = \"Empty\";\n    EntryStatus[EntryStatus[\"Pending\"] = 1] = \"Pending\";\n    EntryStatus[EntryStatus[\"Fulfilled\"] = 2] = \"Fulfilled\";\n    EntryStatus[EntryStatus[\"Rejected\"] = 3] = \"Rejected\";\n    return EntryStatus;\n}({});\nconst isOutputExportMode =  false && 0;\nconst MetadataOnlyRequestTree = [\n    '',\n    {},\n    null,\n    'metadata-only'\n];\nlet routeCacheMap = (0, _cachemap.createCacheMap)();\nlet segmentCacheMap = (0, _cachemap.createCacheMap)();\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners = null;\n// Incrementing counter used to track cache invalidations.\nlet currentCacheVersion = 0;\nfunction getCurrentCacheVersion() {\n    return currentCacheVersion;\n}\nfunction revalidateEntireCache(nextUrl, tree) {\n    // Increment the current cache version. This does not eagerly evict anything\n    // from the cache, but because all the entries are versioned, and we check\n    // the version when reading from the cache, this effectively causes all\n    // entries to be evicted lazily. We do it lazily because in the future,\n    // actions like revalidateTag or refresh will not evict the entire cache,\n    // but rather some subset of the entries.\n    currentCacheVersion++;\n    // Start a cooldown before re-prefetching to allow CDN cache propagation.\n    (0, _scheduler.startRevalidationCooldown)();\n    // Prefetch all the currently visible links again, to re-fill the cache.\n    (0, _links.pingVisibleLinks)(nextUrl, tree);\n    // Similarly, notify all invalidation listeners (i.e. those passed to\n    // `router.prefetch(onInvalidate)`), so they can trigger a new prefetch\n    // if needed.\n    pingInvalidationListeners(nextUrl, tree);\n}\nfunction attachInvalidationListener(task) {\n    // This function is called whenever a prefetch task reads a cache entry. If\n    // the task has an onInvalidate function associated with it  i.e. the one\n    // optionally passed to router.prefetch(onInvalidate)  then we attach that\n    // listener to the every cache entry that the task reads. Then, if an entry\n    // is invalidated, we call the function.\n    if (task.onInvalidate !== null) {\n        if (invalidationListeners === null) {\n            invalidationListeners = new Set([\n                task\n            ]);\n        } else {\n            invalidationListeners.add(task);\n        }\n    }\n}\nfunction notifyInvalidationListener(task) {\n    const onInvalidate = task.onInvalidate;\n    if (onInvalidate !== null) {\n        // Clear the callback from the task object to guarantee it's not called more\n        // than once.\n        task.onInvalidate = null;\n        // This is a user-space function, so we must wrap in try/catch.\n        try {\n            onInvalidate();\n        } catch (error) {\n            if (typeof reportError === 'function') {\n                reportError(error);\n            } else {\n                console.error(error);\n            }\n        }\n    }\n}\nfunction pingInvalidationListeners(nextUrl, tree) {\n    // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n    // This is called when the Next-Url or the base tree changes, since those\n    // may affect the result of a prefetch task. It's also called after a\n    // cache invalidation.\n    if (invalidationListeners !== null) {\n        const tasks = invalidationListeners;\n        invalidationListeners = null;\n        for (const task of tasks){\n            if ((0, _scheduler.isPrefetchTaskDirty)(task, nextUrl, tree)) {\n                notifyInvalidationListener(task);\n            }\n        }\n    }\n}\nfunction readRouteCacheEntry(now, key) {\n    const varyPath = (0, _varypath.getRouteVaryPath)(key.pathname, key.search, key.nextUrl);\n    const isRevalidation = false;\n    return (0, _cachemap.getFromCacheMap)(now, getCurrentCacheVersion(), routeCacheMap, varyPath, isRevalidation);\n}\nfunction readSegmentCacheEntry(now, varyPath) {\n    const isRevalidation = false;\n    return (0, _cachemap.getFromCacheMap)(now, getCurrentCacheVersion(), segmentCacheMap, varyPath, isRevalidation);\n}\nfunction readRevalidatingSegmentCacheEntry(now, varyPath) {\n    const isRevalidation = true;\n    return (0, _cachemap.getFromCacheMap)(now, getCurrentCacheVersion(), segmentCacheMap, varyPath, isRevalidation);\n}\nfunction waitForSegmentCacheEntry(pendingEntry) {\n    // Because the entry is pending, there's already a in-progress request.\n    // Attach a promise to the entry that will resolve when the server responds.\n    let promiseWithResolvers = pendingEntry.promise;\n    if (promiseWithResolvers === null) {\n        promiseWithResolvers = pendingEntry.promise = (0, _promisewithresolvers.createPromiseWithResolvers)();\n    } else {\n    // There's already a promise we can use\n    }\n    return promiseWithResolvers.promise;\n}\nfunction readOrCreateRouteCacheEntry(now, task, key) {\n    attachInvalidationListener(task);\n    const existingEntry = readRouteCacheEntry(now, key);\n    if (existingEntry !== null) {\n        return existingEntry;\n    }\n    // Create a pending entry and add it to the cache.\n    const pendingEntry = {\n        canonicalUrl: null,\n        status: 0,\n        blockedTasks: null,\n        tree: null,\n        metadata: null,\n        // This is initialized to true because we don't know yet whether the route\n        // could be intercepted. It's only set to false once we receive a response\n        // from the server.\n        couldBeIntercepted: true,\n        // Similarly, we don't yet know if the route supports PPR.\n        isPPREnabled: false,\n        renderedSearch: null,\n        // Map-related fields\n        ref: null,\n        size: 0,\n        // Since this is an empty entry, there's no reason to ever evict it. It will\n        // be updated when the data is populated.\n        staleAt: Infinity,\n        version: getCurrentCacheVersion()\n    };\n    const varyPath = (0, _varypath.getRouteVaryPath)(key.pathname, key.search, key.nextUrl);\n    const isRevalidation = false;\n    (0, _cachemap.setInCacheMap)(routeCacheMap, varyPath, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction requestOptimisticRouteCacheEntry(now, requestedUrl, nextUrl) {\n    // This function is called during a navigation when there was no matching\n    // route tree in the prefetch cache. Before de-opting to a blocking,\n    // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n    // route tree by checking the cache for similar routes.\n    //\n    // Check if there's a route with the same pathname, but with different\n    // search params. We can then base our optimistic route tree on this entry.\n    //\n    // Conceptually, we are simulating what would happen if we did perform a\n    // prefetch the requested URL, under the assumption that the server will\n    // not redirect or rewrite the request in a different manner than the\n    // base route tree. This assumption might not hold, in which case we'll have\n    // to recover when we perform the dynamic navigation request. However, this\n    // is what would happen if a route were dynamically rewritten/redirected\n    // in between the prefetch and the navigation. So the logic needs to exist\n    // to handle this case regardless.\n    // Look for a route with the same pathname, but with an empty search string.\n    // TODO: There's nothing inherently special about the empty search string;\n    // it's chosen somewhat arbitrarily, with the rationale that it's the most\n    // likely one to exist. But we should update this to match _any_ search\n    // string. The plan is to generalize this logic alongside other improvements\n    // related to \"fallback\" cache entries.\n    const requestedSearch = requestedUrl.search;\n    if (requestedSearch === '') {\n        // The caller would have already checked if a route with an empty search\n        // string is in the cache. So we can bail out here.\n        return null;\n    }\n    const urlWithoutSearchParams = new URL(requestedUrl);\n    urlWithoutSearchParams.search = '';\n    const routeWithNoSearchParams = readRouteCacheEntry(now, (0, _cachekey.createCacheKey)(urlWithoutSearchParams.href, nextUrl));\n    if (routeWithNoSearchParams === null || routeWithNoSearchParams.status !== 2) {\n        // Bail out of constructing an optimistic route tree. This will result in\n        // a blocking, unprefetched navigation.\n        return null;\n    }\n    // Now we have a base route tree we can \"patch\" with our optimistic values.\n    // Optimistically assume that redirects for the requested pathname do\n    // not vary on the search string. Therefore, if the base route was\n    // redirected to a different search string, then the optimistic route\n    // should be redirected to the same search string. Otherwise, we use\n    // the requested search string.\n    const canonicalUrlForRouteWithNoSearchParams = new URL(routeWithNoSearchParams.canonicalUrl, requestedUrl.origin);\n    const optimisticCanonicalSearch = canonicalUrlForRouteWithNoSearchParams.search !== '' ? canonicalUrlForRouteWithNoSearchParams.search : requestedSearch;\n    // Similarly, optimistically assume that rewrites for the requested\n    // pathname do not vary on the search string. Therefore, if the base\n    // route was rewritten to a different search string, then the optimistic\n    // route should be rewritten to the same search string. Otherwise, we use\n    // the requested search string.\n    const optimisticRenderedSearch = routeWithNoSearchParams.renderedSearch !== '' ? routeWithNoSearchParams.renderedSearch : requestedSearch;\n    const optimisticUrl = new URL(routeWithNoSearchParams.canonicalUrl, location.origin);\n    optimisticUrl.search = optimisticCanonicalSearch;\n    const optimisticCanonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(optimisticUrl);\n    const optimisticRouteTree = createOptimisticRouteTree(routeWithNoSearchParams.tree, optimisticRenderedSearch);\n    const optimisticMetadataTree = createOptimisticRouteTree(routeWithNoSearchParams.metadata, optimisticRenderedSearch);\n    // Clone the base route tree, and override the relevant fields with our\n    // optimistic values.\n    const optimisticEntry = {\n        canonicalUrl: optimisticCanonicalUrl,\n        status: 2,\n        // This isn't cloned because it's instance-specific\n        blockedTasks: null,\n        tree: optimisticRouteTree,\n        metadata: optimisticMetadataTree,\n        couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n        isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n        // Override the rendered search with the optimistic value.\n        renderedSearch: optimisticRenderedSearch,\n        // Map-related fields\n        ref: null,\n        size: 0,\n        staleAt: routeWithNoSearchParams.staleAt,\n        version: routeWithNoSearchParams.version\n    };\n    // Do not insert this entry into the cache. It only exists so we can\n    // perform the current navigation. Just return it to the caller.\n    return optimisticEntry;\n}\nfunction createOptimisticRouteTree(tree, newRenderedSearch) {\n    // Create a new route tree that identical to the original one except for\n    // the rendered search string, which is contained in the vary path.\n    let clonedSlots = null;\n    const originalSlots = tree.slots;\n    if (originalSlots !== null) {\n        clonedSlots = {};\n        for(const parallelRouteKey in originalSlots){\n            const childTree = originalSlots[parallelRouteKey];\n            clonedSlots[parallelRouteKey] = createOptimisticRouteTree(childTree, newRenderedSearch);\n        }\n    }\n    // We only need to clone the vary path if the route is a page.\n    if (tree.isPage) {\n        return {\n            requestKey: tree.requestKey,\n            segment: tree.segment,\n            varyPath: (0, _varypath.clonePageVaryPathWithNewSearchParams)(tree.varyPath, newRenderedSearch),\n            isPage: true,\n            slots: clonedSlots,\n            isRootLayout: tree.isRootLayout,\n            hasLoadingBoundary: tree.hasLoadingBoundary,\n            hasRuntimePrefetch: tree.hasRuntimePrefetch\n        };\n    }\n    return {\n        requestKey: tree.requestKey,\n        segment: tree.segment,\n        varyPath: tree.varyPath,\n        isPage: false,\n        slots: clonedSlots,\n        isRootLayout: tree.isRootLayout,\n        hasLoadingBoundary: tree.hasLoadingBoundary,\n        hasRuntimePrefetch: tree.hasRuntimePrefetch\n    };\n}\nfunction readOrCreateSegmentCacheEntry(now, fetchStrategy, route, tree) {\n    const existingEntry = readSegmentCacheEntry(now, tree.varyPath);\n    if (existingEntry !== null) {\n        return existingEntry;\n    }\n    // Create a pending entry and add it to the cache.\n    const varyPathForRequest = (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree);\n    const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt);\n    const isRevalidation = false;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPathForRequest, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction readOrCreateRevalidatingSegmentEntry(now, fetchStrategy, route, tree) {\n    // This function is called when we've already confirmed that a particular\n    // segment is cached, but we want to perform another request anyway in case it\n    // returns more complete and/or fresher data than we already have. The logic\n    // for deciding whether to replace the existing entry is handled elsewhere;\n    // this function just handles retrieving a cache entry that we can use to\n    // track the revalidation.\n    //\n    // The reason revalidations are stored in the cache is because we need to be\n    // able to dedupe multiple revalidation requests. The reason they have to be\n    // handled specially is because we shouldn't overwrite a \"normal\" entry if\n    // one exists at the same keypath. So, for each internal cache location, there\n    // is a special \"revalidation\" slot that is used solely for this purpose.\n    //\n    // You can think of it as if all the revalidation entries were stored in a\n    // separate cache map from the canonical entries, and then transfered to the\n    // canonical cache map once the request is complete  this isn't how it's\n    // actually implemented, since it's more efficient to store them in the same\n    // data structure as the normal entries, but that's how it's modeled\n    // conceptually.\n    // TODO: Once we implement Fallback behavior for params, where an entry is\n    // re-keyed based on response information, we'll need to account for the\n    // possibility that the keypath of the previous entry is more generic than\n    // the keypath of the revalidating entry. In other words, the server could\n    // return a less generic entry upon revalidation. For now, though, this isn't\n    // a concern because the keypath is based solely on the prefetch strategy,\n    // not on data contained in the response.\n    const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath);\n    if (existingEntry !== null) {\n        return existingEntry;\n    }\n    // Create a pending entry and add it to the cache.\n    const varyPathForRequest = (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree);\n    const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt);\n    const isRevalidation = true;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPathForRequest, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction overwriteRevalidatingSegmentCacheEntry(fetchStrategy, route, tree) {\n    // This function is called when we've already decided to replace an existing\n    // revalidation entry. Create a new entry and write it into the cache,\n    // overwriting the previous value.\n    const varyPathForRequest = (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree);\n    const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt);\n    const isRevalidation = true;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPathForRequest, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction upsertSegmentEntry(now, varyPath, candidateEntry) {\n    // We have a new entry that has not yet been inserted into the cache. Before\n    // we do so, we need to confirm whether it takes precedence over the existing\n    // entry (if one exists).\n    // TODO: We should not upsert an entry if its key was invalidated in the time\n    // since the request was made. We can do that by passing the \"owner\" entry to\n    // this function and confirming it's the same as `existingEntry`.\n    if ((0, _cachemap.isValueExpired)(now, getCurrentCacheVersion(), candidateEntry)) {\n        // The entry is expired. We cannot upsert it.\n        return null;\n    }\n    const existingEntry = readSegmentCacheEntry(now, varyPath);\n    if (existingEntry !== null) {\n        // Don't replace a more specific segment with a less-specific one. A case where this\n        // might happen is if the existing segment was fetched via\n        // `<Link prefetch={true}>`.\n        if (// than the segment we already have in the cache, so it can't have more content.\n        candidateEntry.fetchStrategy !== existingEntry.fetchStrategy && !canNewFetchStrategyProvideMoreContent(existingEntry.fetchStrategy, candidateEntry.fetchStrategy) || // The existing entry isn't partial, but the new one is.\n        // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n        !existingEntry.isPartial && candidateEntry.isPartial) {\n            // We're going to leave revalidating entry in the cache so that it doesn't\n            // get revalidated again unnecessarily. Downgrade the Fulfilled entry to\n            // Rejected and null out the data so it can be garbage collected. We leave\n            // `staleAt` intact to prevent subsequent revalidation attempts only until\n            // the entry expires.\n            const rejectedEntry = candidateEntry;\n            rejectedEntry.status = 3;\n            rejectedEntry.loading = null;\n            rejectedEntry.rsc = null;\n            return null;\n        }\n        // Evict the existing entry from the cache.\n        (0, _cachemap.deleteFromCacheMap)(existingEntry);\n    }\n    const isRevalidation = false;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPath, candidateEntry, isRevalidation);\n    return candidateEntry;\n}\nfunction createDetachedSegmentCacheEntry(staleAt) {\n    const emptyEntry = {\n        status: 0,\n        // Default to assuming the fetch strategy will be PPR. This will be updated\n        // when a fetch is actually initiated.\n        fetchStrategy: _types.FetchStrategy.PPR,\n        rsc: null,\n        loading: null,\n        isPartial: true,\n        promise: null,\n        // Map-related fields\n        ref: null,\n        size: 0,\n        staleAt,\n        version: 0\n    };\n    return emptyEntry;\n}\nfunction upgradeToPendingSegment(emptyEntry, fetchStrategy) {\n    const pendingEntry = emptyEntry;\n    pendingEntry.status = 1;\n    pendingEntry.fetchStrategy = fetchStrategy;\n    if (fetchStrategy === _types.FetchStrategy.Full) {\n        // We can assume the response will contain the full segment data. Set this\n        // to false so we know it's OK to omit this segment from any navigation\n        // requests that may happen while the data is still pending.\n        pendingEntry.isPartial = false;\n    }\n    // Set the version here, since this is right before the request is initiated.\n    // The next time the global cache version is incremented, the entry will\n    // effectively be evicted. This happens before initiating the request, rather\n    // than when receiving the response, because it's guaranteed to happen\n    // before the data is read on the server.\n    pendingEntry.version = getCurrentCacheVersion();\n    return pendingEntry;\n}\nfunction pingBlockedTasks(entry) {\n    const blockedTasks = entry.blockedTasks;\n    if (blockedTasks !== null) {\n        for (const task of blockedTasks){\n            (0, _scheduler.pingPrefetchTask)(task);\n        }\n        entry.blockedTasks = null;\n    }\n}\nfunction fulfillRouteCacheEntry(entry, tree, metadataVaryPath, staleAt, couldBeIntercepted, canonicalUrl, renderedSearch, isPPREnabled) {\n    // The Head is not actually part of the route tree, but other than that, it's\n    // fetched and cached like a segment. Some functions expect a RouteTree\n    // object, so rather than fork the logic in all those places, we use this\n    // \"fake\" one.\n    const metadata = {\n        requestKey: _segmentvalueencoding.HEAD_REQUEST_KEY,\n        segment: _segmentvalueencoding.HEAD_REQUEST_KEY,\n        varyPath: metadataVaryPath,\n        // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n        // either) but for the purposes of how this field is used, it behaves like\n        // one. If this logic ever gets more complex we can change this to an enum.\n        isPage: true,\n        slots: null,\n        isRootLayout: false,\n        hasLoadingBoundary: _approutertypes.HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n        hasRuntimePrefetch: false\n    };\n    const fulfilledEntry = entry;\n    fulfilledEntry.status = 2;\n    fulfilledEntry.tree = tree;\n    fulfilledEntry.metadata = metadata;\n    fulfilledEntry.staleAt = staleAt;\n    fulfilledEntry.couldBeIntercepted = couldBeIntercepted;\n    fulfilledEntry.canonicalUrl = canonicalUrl;\n    fulfilledEntry.renderedSearch = renderedSearch;\n    fulfilledEntry.isPPREnabled = isPPREnabled;\n    pingBlockedTasks(entry);\n    return fulfilledEntry;\n}\nfunction fulfillSegmentCacheEntry(segmentCacheEntry, rsc, loading, staleAt, isPartial) {\n    const fulfilledEntry = segmentCacheEntry;\n    fulfilledEntry.status = 2;\n    fulfilledEntry.rsc = rsc;\n    fulfilledEntry.loading = loading;\n    fulfilledEntry.staleAt = staleAt;\n    fulfilledEntry.isPartial = isPartial;\n    // Resolve any listeners that were waiting for this data.\n    if (segmentCacheEntry.promise !== null) {\n        segmentCacheEntry.promise.resolve(fulfilledEntry);\n        // Free the promise for garbage collection.\n        fulfilledEntry.promise = null;\n    }\n    return fulfilledEntry;\n}\nfunction rejectRouteCacheEntry(entry, staleAt) {\n    const rejectedEntry = entry;\n    rejectedEntry.status = 3;\n    rejectedEntry.staleAt = staleAt;\n    pingBlockedTasks(entry);\n}\nfunction rejectSegmentCacheEntry(entry, staleAt) {\n    const rejectedEntry = entry;\n    rejectedEntry.status = 3;\n    rejectedEntry.staleAt = staleAt;\n    if (entry.promise !== null) {\n        // NOTE: We don't currently propagate the reason the prefetch was canceled\n        // but we could by accepting a `reason` argument.\n        entry.promise.resolve(null);\n        entry.promise = null;\n    }\n}\nfunction convertRootTreePrefetchToRouteTree(rootTree, renderedPathname, renderedSearch, acc) {\n    // Remove trailing and leading slashes\n    const pathnameParts = renderedPathname.split('/').filter((p)=>p !== '');\n    const index = 0;\n    const rootSegment = _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY;\n    return convertTreePrefetchToRouteTree(rootTree.tree, rootSegment, null, _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY, pathnameParts, index, renderedSearch, acc);\n}\nfunction convertTreePrefetchToRouteTree(prefetch, segment, partialVaryPath, requestKey, pathnameParts, pathnamePartsIndex, renderedSearch, acc) {\n    // Converts the route tree sent by the server into the format used by the\n    // cache. The cached version of the tree includes additional fields, such as a\n    // cache key for each segment. Since this is frequently accessed, we compute\n    // it once instead of on every access. This same cache key is also used to\n    // request the segment from the server.\n    let slots = null;\n    let isPage;\n    let varyPath;\n    const prefetchSlots = prefetch.slots;\n    if (prefetchSlots !== null) {\n        isPage = false;\n        varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        slots = {};\n        for(let parallelRouteKey in prefetchSlots){\n            const childPrefetch = prefetchSlots[parallelRouteKey];\n            const childParamName = childPrefetch.name;\n            const childParamType = childPrefetch.paramType;\n            const childServerSentParamKey = childPrefetch.paramKey;\n            let childDoesAppearInURL;\n            let childSegment;\n            let childPartialVaryPath;\n            if (childParamType !== null) {\n                // This segment is parameterized. Get the param from the pathname.\n                const childParamValue = (0, _routeparams.parseDynamicParamFromURLPart)(childParamType, pathnameParts, pathnamePartsIndex);\n                // Assign a cache key to the segment, based on the param value. In the\n                // pre-Segment Cache implementation, the server computes this and sends\n                // it in the body of the response. In the Segment Cache implementation,\n                // the server sends an empty string and we fill it in here.\n                // TODO: We're intentionally not adding the search param to page\n                // segments here; it's tracked separately and added back during a read.\n                // This would clearer if we waited to construct the segment until it's\n                // read from the cache, since that's effectively what we're\n                // doing anyway.\n                const childParamKey = // cacheComponents is enabled.\n                childServerSentParamKey !== null ? childServerSentParamKey : (0, _routeparams.getCacheKeyForDynamicParam)(childParamValue, '');\n                childPartialVaryPath = (0, _varypath.appendLayoutVaryPath)(partialVaryPath, childParamKey);\n                childSegment = [\n                    childParamName,\n                    childParamKey,\n                    childParamType\n                ];\n                childDoesAppearInURL = true;\n            } else {\n                // This segment does not have a param. Inherit the partial vary path of\n                // the parent.\n                childPartialVaryPath = partialVaryPath;\n                childSegment = childParamName;\n                childDoesAppearInURL = (0, _routeparams.doesStaticSegmentAppearInURL)(childParamName);\n            }\n            // Only increment the index if the segment appears in the URL. If it's a\n            // \"virtual\" segment, like a route group, it remains the same.\n            const childPathnamePartsIndex = childDoesAppearInURL ? pathnamePartsIndex + 1 : pathnamePartsIndex;\n            const childRequestKeyPart = (0, _segmentvalueencoding.createSegmentRequestKeyPart)(childSegment);\n            const childRequestKey = (0, _segmentvalueencoding.appendSegmentRequestKeyPart)(requestKey, parallelRouteKey, childRequestKeyPart);\n            slots[parallelRouteKey] = convertTreePrefetchToRouteTree(childPrefetch, childSegment, childPartialVaryPath, childRequestKey, pathnameParts, childPathnamePartsIndex, renderedSearch, acc);\n        }\n    } else {\n        if (requestKey.endsWith(_segment.PAGE_SEGMENT_KEY)) {\n            // This is a page segment.\n            isPage = true;\n            varyPath = (0, _varypath.finalizePageVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            // The metadata \"segment\" is not part the route tree, but it has the same\n            // conceptual params as a page segment. Write the vary path into the\n            // accumulator object. If there are multiple parallel pages, we use the\n            // first one. Which page we choose is arbitrary as long as it's\n            // consistently the same one every time every time. See\n            // finalizeMetadataVaryPath for more details.\n            if (acc.metadataVaryPath === null) {\n                acc.metadataVaryPath = (0, _varypath.finalizeMetadataVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            }\n        } else {\n            // This is a layout segment.\n            isPage = false;\n            varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        }\n    }\n    return {\n        requestKey,\n        segment,\n        varyPath,\n        // TODO: Cheating the type system here a bit because TypeScript can't tell\n        // that the type of isPage and varyPath are consistent. The fix would be to\n        // create separate constructors and call the appropriate one from each of\n        // the branches above. Just seems a bit overkill only for one field so I'll\n        // leave it as-is for now. If isPage were wrong it would break the behavior\n        // and we'd catch it quickly, anyway.\n        isPage: isPage,\n        slots,\n        isRootLayout: prefetch.isRootLayout,\n        // This field is only relevant to dynamic routes. For a PPR/static route,\n        // there's always some partial loading state we can fetch.\n        hasLoadingBoundary: _approutertypes.HasLoadingBoundary.SegmentHasLoadingBoundary,\n        hasRuntimePrefetch: prefetch.hasRuntimePrefetch\n    };\n}\nfunction convertRootFlightRouterStateToRouteTree(flightRouterState, renderedSearch, acc) {\n    return convertFlightRouterStateToRouteTree(flightRouterState, _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY, null, renderedSearch, acc);\n}\nfunction convertFlightRouterStateToRouteTree(flightRouterState, requestKey, parentPartialVaryPath, renderedSearch, acc) {\n    const originalSegment = flightRouterState[0];\n    let segment;\n    let partialVaryPath;\n    let isPage;\n    let varyPath;\n    if (Array.isArray(originalSegment)) {\n        isPage = false;\n        const paramCacheKey = originalSegment[1];\n        partialVaryPath = (0, _varypath.appendLayoutVaryPath)(parentPartialVaryPath, paramCacheKey);\n        varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        segment = originalSegment;\n    } else {\n        // This segment does not have a param. Inherit the partial vary path of\n        // the parent.\n        partialVaryPath = parentPartialVaryPath;\n        if (requestKey.endsWith(_segment.PAGE_SEGMENT_KEY)) {\n            // This is a page segment.\n            isPage = true;\n            // The navigation implementation expects the search params to be included\n            // in the segment. However, in the case of a static response, the search\n            // params are omitted. So the client needs to add them back in when reading\n            // from the Segment Cache.\n            //\n            // For consistency, we'll do this for dynamic responses, too.\n            //\n            // TODO: We should move search params out of FlightRouterState and handle\n            // them entirely on the client, similar to our plan for dynamic params.\n            segment = _segment.PAGE_SEGMENT_KEY;\n            varyPath = (0, _varypath.finalizePageVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            // The metadata \"segment\" is not part the route tree, but it has the same\n            // conceptual params as a page segment. Write the vary path into the\n            // accumulator object. If there are multiple parallel pages, we use the\n            // first one. Which page we choose is arbitrary as long as it's\n            // consistently the same one every time every time. See\n            // finalizeMetadataVaryPath for more details.\n            if (acc.metadataVaryPath === null) {\n                acc.metadataVaryPath = (0, _varypath.finalizeMetadataVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            }\n        } else {\n            // This is a layout segment.\n            isPage = false;\n            segment = originalSegment;\n            varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        }\n    }\n    let slots = null;\n    const parallelRoutes = flightRouterState[1];\n    for(let parallelRouteKey in parallelRoutes){\n        const childRouterState = parallelRoutes[parallelRouteKey];\n        const childSegment = childRouterState[0];\n        // TODO: Eventually, the param values will not be included in the response\n        // from the server. We'll instead fill them in on the client by parsing\n        // the URL. This is where we'll do that.\n        const childRequestKeyPart = (0, _segmentvalueencoding.createSegmentRequestKeyPart)(childSegment);\n        const childRequestKey = (0, _segmentvalueencoding.appendSegmentRequestKeyPart)(requestKey, parallelRouteKey, childRequestKeyPart);\n        const childTree = convertFlightRouterStateToRouteTree(childRouterState, childRequestKey, partialVaryPath, renderedSearch, acc);\n        if (slots === null) {\n            slots = {\n                [parallelRouteKey]: childTree\n            };\n        } else {\n            slots[parallelRouteKey] = childTree;\n        }\n    }\n    return {\n        requestKey,\n        segment,\n        varyPath,\n        // TODO: Cheating the type system here a bit because TypeScript can't tell\n        // that the type of isPage and varyPath are consistent. The fix would be to\n        // create separate constructors and call the appropriate one from each of\n        // the branches above. Just seems a bit overkill only for one field so I'll\n        // leave it as-is for now. If isPage were wrong it would break the behavior\n        // and we'd catch it quickly, anyway.\n        isPage: isPage,\n        slots,\n        isRootLayout: flightRouterState[4] === true,\n        hasLoadingBoundary: flightRouterState[5] !== undefined ? flightRouterState[5] : _approutertypes.HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n        // Non-static tree responses are only used by apps that haven't adopted\n        // Cache Components. So this is always false.\n        hasRuntimePrefetch: false\n    };\n}\nfunction convertRouteTreeToFlightRouterState(routeTree) {\n    const parallelRoutes = {};\n    if (routeTree.slots !== null) {\n        for(const parallelRouteKey in routeTree.slots){\n            parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(routeTree.slots[parallelRouteKey]);\n        }\n    }\n    const flightRouterState = [\n        routeTree.segment,\n        parallelRoutes,\n        null,\n        null,\n        routeTree.isRootLayout\n    ];\n    return flightRouterState;\n}\nasync function fetchRouteOnCacheMiss(entry, task, key) {\n    // This function is allowed to use async/await because it contains the actual\n    // fetch that gets issued on a cache miss. Notice it writes the result to the\n    // cache entry directly, rather than return data that is then written by\n    // the caller.\n    const pathname = key.pathname;\n    const search = key.search;\n    const nextUrl = key.nextUrl;\n    const segmentPath = '/_tree';\n    const headers = {\n        [_approuterheaders.RSC_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath\n    };\n    if (nextUrl !== null) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    try {\n        const url = new URL(pathname + search, location.origin);\n        let response;\n        let urlAfterRedirects;\n        if (isOutputExportMode) {\n            // In output: \"export\" mode, we can't use headers to request a particular\n            // segment. Instead, we encode the extra request information into the URL.\n            // This is not part of the \"public\" interface of the app; it's an internal\n            // Next.js implementation detail that the app developer should not need to\n            // concern themselves with.\n            //\n            // For example, to request a segment:\n            //\n            //   Path passed to <Link>:   /path/to/page\n            //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n            //\n            //   (This is not the exact protocol, just an illustration.)\n            //\n            // Before we do that, though, we need to account for redirects. Even in\n            // output: \"export\" mode, a proxy might redirect the page to a different\n            // location, but we shouldn't assume or expect that they also redirect all\n            // the segment files, too.\n            //\n            // To check whether the page is redirected, previously we perform a range\n            // request of 64 bytes of the HTML document to check if the target page\n            // is part of this app (by checking if build id matches). Only if the target\n            // page is part of this app do we determine the final canonical URL.\n            //\n            // However, as mentioned in https://github.com/vercel/next.js/pull/85903,\n            // some popular static hosting providers (like Cloudflare Pages or Render.com)\n            // do not support range requests, in the worst case, the entire HTML instead\n            // of 64 bytes could be returned, which is wasteful.\n            //\n            // So instead, we drops the check for build id here, and simply perform\n            // a HEAD request to rejects 1xx/4xx/5xx responses, and then determine the\n            // final URL after redirects.\n            //\n            // NOTE: We could embed the route tree into the HTML document, to avoid\n            // a second request. We're not doing that currently because it would make\n            // the HTML document larger and affect normal page loads.\n            const headResponse = await fetch(url, {\n                method: 'HEAD'\n            });\n            if (headResponse.status < 200 || headResponse.status >= 400) {\n                // The target page responded w/o a successful status code\n                // Could be a WAF serving a 403, or a 5xx from a backend\n                //\n                // Note that we can't use headResponse.ok here, because\n                // Response#ok returns `false` with 3xx responses.\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            urlAfterRedirects = headResponse.redirected ? new URL(headResponse.url) : url;\n            response = await fetchPrefetchResponse(addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath), headers);\n        } else {\n            // \"Server\" mode. We can use request headers instead of the pathname.\n            // TODO: The eventual plan is to get rid of our custom request headers and\n            // encode everything into the URL, using a similar strategy to the\n            // \"output: export\" block above.\n            response = await fetchPrefetchResponse(url, headers);\n            urlAfterRedirects = response !== null && response.redirected ? new URL(response.url) : url;\n        }\n        if (!response || !response.ok || // 204 is a Cache miss. Though theoretically this shouldn't happen when\n        // PPR is enabled, because we always respond to route tree requests, even\n        // if it needs to be blockingly generated on demand.\n        response.status === 204 || !response.body) {\n            // Server responded with an error, or with a miss. We should still cache\n            // the response, but we can try again after 10 seconds.\n            rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n            return null;\n        }\n        // TODO: The canonical URL is the href without the origin. I think\n        // historically the reason for this is because the initial canonical URL\n        // gets passed as a prop to the top-level React component, which means it\n        // needs to be computed during SSR. If it were to include the origin, it\n        // would need to always be same as location.origin on the client, to prevent\n        // a hydration mismatch. To sidestep this complexity, we omit the origin.\n        //\n        // However, since this is neither a native URL object nor a fully qualified\n        // URL string, we need to be careful about how we use it. To prevent subtle\n        // mistakes, we should create a special type for it, instead of just string.\n        // Or, we should just use a (readonly) URL object instead. The type of the\n        // prop that we pass to seed the initial state does not need to be the same\n        // type as the state itself.\n        const canonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(urlAfterRedirects);\n        // Check whether the response varies based on the Next-Url header.\n        const varyHeader = response.headers.get('vary');\n        const couldBeIntercepted = varyHeader !== null && varyHeader.includes(_approuterheaders.NEXT_URL);\n        // Track when the network connection closes.\n        const closed = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        // This checks whether the response was served from the per-segment cache,\n        // rather than the old prefetching flow. If it fails, it implies that PPR\n        // is disabled on this route.\n        const routeIsPPREnabled = response.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER) === '2' || // In output: \"export\" mode, we can't rely on response headers. But if we\n        // receive a well-formed response, we can assume it's a static response,\n        // because all data is static in this mode.\n        isOutputExportMode;\n        if (routeIsPPREnabled) {\n            const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(size) {\n                (0, _cachemap.setSizeInCacheMap)(entry, size);\n            });\n            const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n            if (serverData.buildId !== (0, _appbuildid.getAppBuildId)()) {\n                // The server build does not match the client. Treat as a 404. During\n                // an actual navigation, the router will trigger an MPA navigation.\n                // TODO: Consider moving the build ID to a response header so we can check\n                // it before decoding the response, and so there's one way of checking\n                // across all response types.\n                // TODO: We should cache the fact that this is an MPA navigation.\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            // Get the params that were used to render the target page. These may\n            // be different from the params in the request URL, if the page\n            // was rewritten.\n            const renderedPathname = (0, _routeparams.getRenderedPathname)(response);\n            const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n            // Convert the server-sent data into the RouteTree format used by the\n            // client cache.\n            //\n            // During this traversal, we accumulate additional data into this\n            // \"accumulator\" object.\n            const acc = {\n                metadataVaryPath: null\n            };\n            const routeTree = convertRootTreePrefetchToRouteTree(serverData, renderedPathname, renderedSearch, acc);\n            const metadataVaryPath = acc.metadataVaryPath;\n            if (metadataVaryPath === null) {\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            const staleTimeMs = getStaleTimeMs(serverData.staleTime);\n            fulfillRouteCacheEntry(entry, routeTree, metadataVaryPath, Date.now() + staleTimeMs, couldBeIntercepted, canonicalUrl, renderedSearch, routeIsPPREnabled);\n        } else {\n            // PPR is not enabled for this route. The server responds with a\n            // different format (FlightRouterState) that we need to convert.\n            // TODO: We will unify the responses eventually. I'm keeping the types\n            // separate for now because FlightRouterState has so many\n            // overloaded concerns.\n            const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(size) {\n                (0, _cachemap.setSizeInCacheMap)(entry, size);\n            });\n            const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n            if (serverData.b !== (0, _appbuildid.getAppBuildId)()) {\n                // The server build does not match the client. Treat as a 404. During\n                // an actual navigation, the router will trigger an MPA navigation.\n                // TODO: Consider moving the build ID to a response header so we can check\n                // it before decoding the response, and so there's one way of checking\n                // across all response types.\n                // TODO: We should cache the fact that this is an MPA navigation.\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            writeDynamicTreeResponseIntoCache(Date.now(), task, // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n            _types.FetchStrategy.LoadingBoundary, response, serverData, entry, couldBeIntercepted, canonicalUrl, routeIsPPREnabled);\n        }\n        if (!couldBeIntercepted) {\n            // This route will never be intercepted. So we can use this entry for all\n            // requests to this route, regardless of the Next-Url header. This works\n            // because when reading the cache we always check for a valid\n            // non-intercepted entry first.\n            // Re-key the entry. The `set` implementation handles removing it from\n            // its previous position in the cache. We don't need to do anything to\n            // update the LRU, because the entry is already in it.\n            // TODO: Treat this as an upsert  should check if an entry already\n            // exists at the new keypath, and if so, whether we should keep that\n            // one instead.\n            const fulfilledVaryPath = (0, _varypath.getFulfilledRouteVaryPath)(pathname, search, nextUrl, couldBeIntercepted);\n            const isRevalidation = false;\n            (0, _cachemap.setInCacheMap)(routeCacheMap, fulfilledVaryPath, entry, isRevalidation);\n        }\n        // Return a promise that resolves when the network connection closes, so\n        // the scheduler can track the number of concurrent network connections.\n        return {\n            value: null,\n            closed: closed.promise\n        };\n    } catch (error) {\n        // Either the connection itself failed, or something bad happened while\n        // decoding the response.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n        return null;\n    }\n}\nasync function fetchSegmentOnCacheMiss(route, segmentCacheEntry, routeKey, tree) {\n    // This function is allowed to use async/await because it contains the actual\n    // fetch that gets issued on a cache miss. Notice it writes the result to the\n    // cache entry directly, rather than return data that is then written by\n    // the caller.\n    //\n    // Segment fetches are non-blocking so we don't need to ping the scheduler\n    // on completion.\n    // Use the canonical URL to request the segment, not the original URL. These\n    // are usually the same, but the canonical URL will be different if the route\n    // tree response was redirected. To avoid an extra waterfall on every segment\n    // request, we pass the redirected URL instead of the original one.\n    const url = new URL(route.canonicalUrl, location.origin);\n    const nextUrl = routeKey.nextUrl;\n    const requestKey = tree.requestKey;\n    const normalizedRequestKey = requestKey === _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY ? // `_index` instead of as an empty string. This should be treated as\n    // an implementation detail and not as a stable part of the protocol.\n    // It just needs to match the equivalent logic that happens when\n    // prerendering the responses. It should not leak outside of Next.js.\n    '/_index' : requestKey;\n    const headers = {\n        [_approuterheaders.RSC_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey\n    };\n    if (nextUrl !== null) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    const requestUrl = isOutputExportMode ? addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey) : url;\n    try {\n        const response = await fetchPrefetchResponse(requestUrl, headers);\n        if (!response || !response.ok || response.status === 204 || // Cache miss\n        // This checks whether the response was served from the per-segment cache,\n        // rather than the old prefetching flow. If it fails, it implies that PPR\n        // is disabled on this route. Theoretically this should never happen\n        // because we only issue requests for segments once we've verified that\n        // the route supports PPR.\n        response.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER) !== '2' && // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode || !response.body) {\n            // Server responded with an error, or with a miss. We should still cache\n            // the response, but we can try again after 10 seconds.\n            rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000);\n            return null;\n        }\n        // Track when the network connection closes.\n        const closed = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        // Wrap the original stream in a new stream that never closes. That way the\n        // Flight client doesn't error if there's a hanging promise.\n        const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(size) {\n            (0, _cachemap.setSizeInCacheMap)(segmentCacheEntry, size);\n        });\n        const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n        if (serverData.buildId !== (0, _appbuildid.getAppBuildId)()) {\n            // The server build does not match the client. Treat as a 404. During\n            // an actual navigation, the router will trigger an MPA navigation.\n            // TODO: Consider moving the build ID to a response header so we can check\n            // it before decoding the response, and so there's one way of checking\n            // across all response types.\n            rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000);\n            return null;\n        }\n        return {\n            value: fulfillSegmentCacheEntry(segmentCacheEntry, serverData.rsc, serverData.loading, // So we use the stale time of the route.\n            route.staleAt, serverData.isPartial),\n            // Return a promise that resolves when the network connection closes, so\n            // the scheduler can track the number of concurrent network connections.\n            closed: closed.promise\n        };\n    } catch (error) {\n        // Either the connection itself failed, or something bad happened while\n        // decoding the response.\n        rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000);\n        return null;\n    }\n}\nasync function fetchSegmentPrefetchesUsingDynamicRequest(task, route, fetchStrategy, dynamicRequestTree, spawnedEntries) {\n    const key = task.key;\n    const url = new URL(route.canonicalUrl, location.origin);\n    const nextUrl = key.nextUrl;\n    if (spawnedEntries.size === 1 && spawnedEntries.has(route.metadata.requestKey)) {\n        // The only thing pending is the head. Instruct the server to\n        // skip over everything else.\n        dynamicRequestTree = MetadataOnlyRequestTree;\n    }\n    const headers = {\n        [_approuterheaders.RSC_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(dynamicRequestTree)\n    };\n    if (nextUrl !== null) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    switch(fetchStrategy){\n        case _types.FetchStrategy.Full:\n            {\n                break;\n            }\n        case _types.FetchStrategy.PPRRuntime:\n            {\n                headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '2';\n                break;\n            }\n        case _types.FetchStrategy.LoadingBoundary:\n            {\n                headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '1';\n                break;\n            }\n        default:\n            {\n                fetchStrategy;\n            }\n    }\n    try {\n        const response = await fetchPrefetchResponse(url, headers);\n        if (!response || !response.ok || !response.body) {\n            // Server responded with an error, or with a miss. We should still cache\n            // the response, but we can try again after 10 seconds.\n            rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000);\n            return null;\n        }\n        const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n        if (renderedSearch !== route.renderedSearch) {\n            // The search params that were used to render the target page are\n            // different from the search params in the request URL. This only happens\n            // when there's a dynamic rewrite in between the tree prefetch and the\n            // data prefetch.\n            // TODO: For now, since this is an edge case, we reject the prefetch, but\n            // the proper way to handle this is to evict the stale route tree entry\n            // then fill the cache with the new response.\n            rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000);\n            return null;\n        }\n        // Track when the network connection closes.\n        const closed = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        let fulfilledEntries = null;\n        const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n            // When processing a dynamic response, we don't know how large each\n            // individual segment is, so approximate by assiging each segment\n            // the average of the total response size.\n            if (fulfilledEntries === null) {\n                // Haven't received enough data yet to know which segments\n                // were included.\n                return;\n            }\n            const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length;\n            for (const entry of fulfilledEntries){\n                (0, _cachemap.setSizeInCacheMap)(entry, averageSize);\n            }\n        });\n        const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n        const isResponsePartial = fetchStrategy === _types.FetchStrategy.PPRRuntime ? serverData.rp?.[0] === true : false;\n        // Aside from writing the data into the cache, this function also returns\n        // the entries that were fulfilled, so we can streamingly update their sizes\n        // in the LRU as more data comes in.\n        fulfilledEntries = writeDynamicRenderResponseIntoCache(Date.now(), task, fetchStrategy, response, serverData, isResponsePartial, route, spawnedEntries);\n        // Return a promise that resolves when the network connection closes, so\n        // the scheduler can track the number of concurrent network connections.\n        return {\n            value: null,\n            closed: closed.promise\n        };\n    } catch (error) {\n        rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000);\n        return null;\n    }\n}\nfunction writeDynamicTreeResponseIntoCache(now, task, fetchStrategy, response, serverData, entry, couldBeIntercepted, canonicalUrl, routeIsPPREnabled) {\n    // Get the URL that was used to render the target page. This may be different\n    // from the URL in the request URL, if the page was rewritten.\n    const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n    const normalizedFlightDataResult = (0, _flightdatahelpers.normalizeFlightData)(serverData.f);\n    if (// MPA navigation.\n    typeof normalizedFlightDataResult === 'string' || normalizedFlightDataResult.length !== 1) {\n        rejectRouteCacheEntry(entry, now + 10 * 1000);\n        return;\n    }\n    const flightData = normalizedFlightDataResult[0];\n    if (!flightData.isRootRender) {\n        // Unexpected response format.\n        rejectRouteCacheEntry(entry, now + 10 * 1000);\n        return;\n    }\n    const flightRouterState = flightData.tree;\n    // For runtime prefetches, stale time is in the payload at rp[1].\n    // For other responses, fall back to the header.\n    const staleTimeSeconds = typeof serverData.rp?.[1] === 'number' ? serverData.rp[1] : parseInt(response.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10);\n    const staleTimeMs = !isNaN(staleTimeSeconds) ? getStaleTimeMs(staleTimeSeconds) : _navigatereducer.STATIC_STALETIME_MS;\n    // If the response contains dynamic holes, then we must conservatively assume\n    // that any individual segment might contain dynamic holes, and also the\n    // head. If it did not contain dynamic holes, then we can assume every segment\n    // and the head is completely static.\n    const isResponsePartial = response.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER) === '1';\n    // Convert the server-sent data into the RouteTree format used by the\n    // client cache.\n    //\n    // During this traversal, we accumulate additional data into this\n    // \"accumulator\" object.\n    const acc = {\n        metadataVaryPath: null\n    };\n    const routeTree = convertRootFlightRouterStateToRouteTree(flightRouterState, renderedSearch, acc);\n    const metadataVaryPath = acc.metadataVaryPath;\n    if (metadataVaryPath === null) {\n        rejectRouteCacheEntry(entry, now + 10 * 1000);\n        return;\n    }\n    const fulfilledEntry = fulfillRouteCacheEntry(entry, routeTree, metadataVaryPath, now + staleTimeMs, couldBeIntercepted, canonicalUrl, renderedSearch, routeIsPPREnabled);\n    // If the server sent segment data as part of the response, we should write\n    // it into the cache to prevent a second, redundant prefetch request.\n    //\n    // TODO: When `clientSegmentCache` is enabled, the server does not include\n    // segment data when responding to a route tree prefetch request. However,\n    // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n    // the page is fully static), the normal check is bypassed and the server\n    // responds with the full page. This is a temporary situation until we can\n    // remove the \"client-only\" option. Then, we can delete this function call.\n    writeDynamicRenderResponseIntoCache(now, task, fetchStrategy, response, serverData, isResponsePartial, fulfilledEntry, null);\n}\nfunction rejectSegmentEntriesIfStillPending(entries, staleAt) {\n    const fulfilledEntries = [];\n    for (const entry of entries.values()){\n        if (entry.status === 1) {\n            rejectSegmentCacheEntry(entry, staleAt);\n        } else if (entry.status === 2) {\n            fulfilledEntries.push(entry);\n        }\n    }\n    return fulfilledEntries;\n}\nfunction writeDynamicRenderResponseIntoCache(now, task, fetchStrategy, response, serverData, isResponsePartial, route, spawnedEntries) {\n    if (serverData.b !== (0, _appbuildid.getAppBuildId)()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        if (spawnedEntries !== null) {\n            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000);\n        }\n        return null;\n    }\n    const flightDatas = (0, _flightdatahelpers.normalizeFlightData)(serverData.f);\n    if (typeof flightDatas === 'string') {\n        // This means navigating to this route will result in an MPA navigation.\n        // TODO: We should cache this, too, so that the MPA navigation is immediate.\n        return null;\n    }\n    // For runtime prefetches, stale time is in the payload at rp[1].\n    // For other responses, fall back to the header.\n    const staleTimeSeconds = typeof serverData.rp?.[1] === 'number' ? serverData.rp[1] : parseInt(response.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10);\n    const staleTimeMs = !isNaN(staleTimeSeconds) ? getStaleTimeMs(staleTimeSeconds) : _navigatereducer.STATIC_STALETIME_MS;\n    const staleAt = now + staleTimeMs;\n    for (const flightData of flightDatas){\n        const seedData = flightData.seedData;\n        if (seedData !== null) {\n            // The data sent by the server represents only a subtree of the app. We\n            // need to find the part of the task tree that matches the response.\n            //\n            // segmentPath represents the parent path of subtree. It's a repeating\n            // pattern of parallel route key and segment:\n            //\n            //   [string, Segment, string, Segment, string, Segment, ...]\n            const segmentPath = flightData.segmentPath;\n            let tree = route.tree;\n            for(let i = 0; i < segmentPath.length; i += 2){\n                const parallelRouteKey = segmentPath[i];\n                if (tree?.slots?.[parallelRouteKey] !== undefined) {\n                    tree = tree.slots[parallelRouteKey];\n                } else {\n                    if (spawnedEntries !== null) {\n                        rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000);\n                    }\n                    return null;\n                }\n            }\n            writeSeedDataIntoCache(now, task, fetchStrategy, route, tree, staleAt, seedData, isResponsePartial, spawnedEntries);\n        }\n        const head = flightData.head;\n        if (head !== null) {\n            fulfillEntrySpawnedByRuntimePrefetch(now, fetchStrategy, route, head, null, flightData.isHeadPartial, staleAt, route.metadata, spawnedEntries);\n        }\n    }\n    // Any entry that's still pending was intentionally not rendered by the\n    // server, because it was inside the loading boundary. Mark them as rejected\n    // so we know not to fetch them again.\n    // TODO: If PPR is enabled on some routes but not others, then it's possible\n    // that a different page is able to do a per-segment prefetch of one of the\n    // segments we're marking as rejected here. We should mark on the segment\n    // somehow that the reason for the rejection is because of a non-PPR prefetch.\n    // That way a per-segment prefetch knows to disregard the rejection.\n    if (spawnedEntries !== null) {\n        const fulfilledEntries = rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000);\n        return fulfilledEntries;\n    }\n    return null;\n}\nfunction writeSeedDataIntoCache(now, task, fetchStrategy, route, tree, staleAt, seedData, isResponsePartial, entriesOwnedByCurrentTask) {\n    // This function is used to write the result of a runtime server request\n    // (CacheNodeSeedData) into the prefetch cache.\n    const rsc = seedData[0];\n    const loading = seedData[2];\n    const isPartial = rsc === null || isResponsePartial;\n    fulfillEntrySpawnedByRuntimePrefetch(now, fetchStrategy, route, rsc, loading, isPartial, staleAt, tree, entriesOwnedByCurrentTask);\n    // Recursively write the child data into the cache.\n    const slots = tree.slots;\n    if (slots !== null) {\n        const seedDataChildren = seedData[1];\n        for(const parallelRouteKey in slots){\n            const childTree = slots[parallelRouteKey];\n            const childSeedData = seedDataChildren[parallelRouteKey];\n            if (childSeedData !== null && childSeedData !== undefined) {\n                writeSeedDataIntoCache(now, task, fetchStrategy, route, childTree, staleAt, childSeedData, isResponsePartial, entriesOwnedByCurrentTask);\n            }\n        }\n    }\n}\nfunction fulfillEntrySpawnedByRuntimePrefetch(now, fetchStrategy, route, rsc, loading, isPartial, staleAt, tree, entriesOwnedByCurrentTask) {\n    // We should only write into cache entries that are owned by us. Or create\n    // a new one and write into that. We must never write over an entry that was\n    // created by a different task, because that causes data races.\n    const ownedEntry = entriesOwnedByCurrentTask !== null ? entriesOwnedByCurrentTask.get(tree.requestKey) : undefined;\n    if (ownedEntry !== undefined) {\n        fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial);\n    } else {\n        // There's no matching entry. Attempt to create a new one.\n        const possiblyNewEntry = readOrCreateSegmentCacheEntry(now, fetchStrategy, route, tree);\n        if (possiblyNewEntry.status === 0) {\n            // Confirmed this is a new entry. We can fulfill it.\n            const newEntry = possiblyNewEntry;\n            fulfillSegmentCacheEntry(upgradeToPendingSegment(newEntry, fetchStrategy), rsc, loading, staleAt, isPartial);\n        } else {\n            // There was already an entry in the cache. But we may be able to\n            // replace it with the new one from the server.\n            const newEntry = fulfillSegmentCacheEntry(upgradeToPendingSegment(createDetachedSegmentCacheEntry(staleAt), fetchStrategy), rsc, loading, staleAt, isPartial);\n            upsertSegmentEntry(now, (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree), newEntry);\n        }\n    }\n}\nasync function fetchPrefetchResponse(url, headers) {\n    const fetchPriority = 'low';\n    // When issuing a prefetch request, don't immediately decode the response; we\n    // use the lower level `createFromResponse` API instead because we need to do\n    // some extra processing of the response stream. See\n    // `createPrefetchResponseStream` for more details.\n    const shouldImmediatelyDecode = false;\n    const response = await (0, _fetchserverresponse.createFetch)(url, headers, fetchPriority, shouldImmediatelyDecode);\n    if (!response.ok) {\n        return null;\n    }\n    // Check the content type\n    if (isOutputExportMode) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n    } else {\n        const contentType = response.headers.get('content-type');\n        const isFlightResponse = contentType && contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);\n        if (!isFlightResponse) {\n            return null;\n        }\n    }\n    return response;\n}\nfunction createPrefetchResponseStream(originalFlightStream, onStreamClose, onResponseSizeUpdate) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    //\n    // While processing the original stream, we also incrementally update the size\n    // of the cache entry in the LRU.\n    let totalByteLength = 0;\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    // Incrementally update the size of the cache entry in the LRU.\n                    // NOTE: Since prefetch responses are delivered in a single chunk,\n                    // it's not really necessary to do this streamingly, but I'm doing it\n                    // anyway in case this changes in the future.\n                    totalByteLength += value.byteLength;\n                    onResponseSizeUpdate(totalByteLength);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream. We do notify the caller, though.\n                onStreamClose();\n                return;\n            }\n        }\n    });\n}\nfunction addSegmentPathToUrlInOutputExportMode(url, segmentPath) {\n    if (isOutputExportMode) {\n        // In output: \"export\" mode, we cannot use a header to encode the segment\n        // path. Instead, we append it to the end of the pathname.\n        const staticUrl = new URL(url);\n        const routeDir = staticUrl.pathname.endsWith('/') ? staticUrl.pathname.slice(0, -1) : staticUrl.pathname;\n        const staticExportFilename = (0, _segmentvalueencoding.convertSegmentPathToStaticExportFilename)(segmentPath);\n        staticUrl.pathname = `${routeDir}/${staticExportFilename}`;\n        return staticUrl;\n    }\n    return url;\n}\nfunction canNewFetchStrategyProvideMoreContent(currentStrategy, newStrategy) {\n    return currentStrategy < newStrategy;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=cache.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvc2VnbWVudC1jYWNoZS9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUErS2tCQSxXQUFXO2VBQVhBOztJQXFrRUZDLHFDQUFxQztlQUFyQ0E7O0lBaGdDQUMsbUNBQW1DO2VBQW5DQTs7SUFwY0FDLCtCQUErQjtlQUEvQkE7O0lBeWRNQyxxQkFBcUI7ZUFBckJBOztJQW9SQUMsdUJBQXVCO2VBQXZCQTs7SUFxSEFDLHlDQUF5QztlQUF6Q0E7O0lBMzJDTkMsc0JBQXNCO2VBQXRCQTs7SUF2TUFDLGNBQWM7ZUFBZEE7O0lBcW9CQUMsc0NBQXNDO2VBQXRDQTs7SUF6WEFDLHlCQUF5QjtlQUF6QkE7O0lBdVVBQyxvQ0FBb0M7ZUFBcENBOztJQWxQQUMsMkJBQTJCO2VBQTNCQTs7SUEyTkFDLDZCQUE2QjtlQUE3QkE7O0lBN1JBQyxtQkFBbUI7ZUFBbkJBOztJQW1CQUMscUJBQXFCO2VBQXJCQTs7SUEyRkFDLGdDQUFnQztlQUFoQ0E7O0lBNUxBQyxxQkFBcUI7ZUFBckJBOztJQXFoQkFDLHVCQUF1QjtlQUF2QkE7O0lBN0VBQyxrQkFBa0I7ZUFBbEJBOztJQTNVQUMsd0JBQXdCO2VBQXhCQTs7OzRDQXBhbUI7OENBVTVCO2lEQU1BO3VDQU9BO3NDQWNBO3dDQUN1QjsrQ0FDSTtzQ0FHeUI7eUNBT3BEO3NDQVVBO2tEQVFBOytDQVFBOzZDQUM2QjttQ0FDSDtxQ0FDQTttQ0FDSDtrREFDYTtBQU1wQyxTQUFTWixlQUFlYSxnQkFBd0I7SUFDckQsT0FBT0MsS0FBS0MsR0FBRyxDQUFDRixrQkFBa0IsTUFBTTtBQUMxQztBQTZFTyxJQUFXckIsY0FBQUEsV0FBQUEsR0FBQUEsU0FBQUEsV0FBQUE7Ozs7O1dBQUFBOztBQStGbEIsTUFBTXdCLHFCQXVuQjZDcUcsTUF0bkI3QixJQUNwQnBHLENBQTZDO0FBRS9DLE1BQU1JLDBCQUE2QztJQUNq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QUVDLElBQUksRUFBRTFELEtBQUssRUFBRSxHQUFHLE1BQU1xRCxPQUFPTSxJQUFJO2dCQUN6QyxJQUFJLENBQUNELE1BQU07b0JBQ1QsbUVBQW1FO29CQUNuRSxtQkFBbUI7b0JBQ25CRCxXQUFXRyxPQUFPLENBQUM1RDtvQkFFbkIsK0RBQStEO29CQUMvRCxrRUFBa0U7b0JBQ2xFLHFFQUFxRTtvQkFDckUsNkNBQTZDO29CQUM3Q29ELG1CQUFtQnBELE1BQU02RCxVQUFVO29CQUNuQzVFLHFCQUFxQm1FO29CQUNyQjtnQkFDRjtnQkFDQSxxRUFBcUU7Z0JBQ3JFLHNEQUFzRDtnQkFDdEREO2dCQUNBO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTN0Usc0NBQ1BULEdBQVEsRUFDUk4sV0FBOEI7SUFFOUIsSUFBSXpLLG9CQUFvQjtRQUN0Qix5RUFBeUU7UUFDekUsMERBQTBEO1FBQzFELE1BQU1nUixZQUFZLElBQUl4TixJQUFJdUg7UUFDMUIsTUFBTWtHLFdBQVdELFVBQVVsUCxRQUFRLENBQUMwSCxRQUFRLENBQUMsT0FDekN3SCxVQUFVbFAsUUFBUSxDQUFDb1AsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUM3QkYsVUFBVWxQLFFBQVE7UUFDdEIsTUFBTXFQLHVCQUNKQyxDQUFBQSxHQUFBQSxzQkFBQUEsd0NBQUFBLEVBQXlDM0c7UUFDM0N1RyxVQUFVbFAsUUFBUSxHQUFHLEdBQUdtUCxTQUFTLENBQUMsRUFBRUUsc0JBQXNCO1FBQzFELE9BQU9IO0lBQ1Q7SUFDQSxPQUFPakc7QUFDVDtBQXVCTyxTQUFTdE0sc0NBQ2Q0UyxlQUE4QixFQUM5QkMsV0FBMEI7SUFFMUIsT0FBT0Qsa0JBQWtCQztBQUMzQiIsInNvdXJjZXMiOlsiL1VzZXJzL3J5YW5yb3N6dG9jenkvc3JjL2NsaWVudC9jb21wb25lbnRzL3NlZ21lbnQtY2FjaGUvY2FjaGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBUcmVlUHJlZmV0Y2gsXG4gIFJvb3RUcmVlUHJlZmV0Y2gsXG4gIFNlZ21lbnRQcmVmZXRjaCxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvY29sbGVjdC1zZWdtZW50LWRhdGEnXG5pbXBvcnQgdHlwZSB7IExvYWRpbmdNb2R1bGVEYXRhIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLXR5cGVzJ1xuaW1wb3J0IHR5cGUge1xuICBDYWNoZU5vZGVTZWVkRGF0YSxcbiAgU2VnbWVudCBhcyBGbGlnaHRSb3V0ZXJTdGF0ZVNlZ21lbnQsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci10eXBlcydcbmltcG9ydCB7IEhhc0xvYWRpbmdCb3VuZGFyeSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci10eXBlcydcbmltcG9ydCB7XG4gIE5FWFRfRElEX1BPU1RQT05FX0hFQURFUixcbiAgTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU1RBTEVfVElNRV9IRUFERVIsXG4gIE5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSLFxuICBORVhUX1VSTCxcbiAgUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIsXG4gIFJTQ19IRUFERVIsXG59IGZyb20gJy4uL2FwcC1yb3V0ZXItaGVhZGVycydcbmltcG9ydCB7XG4gIGNyZWF0ZUZldGNoLFxuICBjcmVhdGVGcm9tTmV4dFJlYWRhYmxlU3RyZWFtLFxuICB0eXBlIFJTQ1Jlc3BvbnNlLFxuICB0eXBlIFJlcXVlc3RIZWFkZXJzLFxufSBmcm9tICcuLi9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQge1xuICBwaW5nUHJlZmV0Y2hUYXNrLFxuICBpc1ByZWZldGNoVGFza0RpcnR5LFxuICB0eXBlIFByZWZldGNoVGFzayxcbiAgdHlwZSBQcmVmZXRjaFN1YnRhc2tSZXN1bHQsXG4gIHN0YXJ0UmV2YWxpZGF0aW9uQ29vbGRvd24sXG59IGZyb20gJy4vc2NoZWR1bGVyJ1xuaW1wb3J0IHtcbiAgdHlwZSBSb3V0ZVZhcnlQYXRoLFxuICB0eXBlIFNlZ21lbnRWYXJ5UGF0aCxcbiAgdHlwZSBQYXJ0aWFsU2VnbWVudFZhcnlQYXRoLFxuICBnZXRSb3V0ZVZhcnlQYXRoLFxuICBnZXRGdWxmaWxsZWRSb3V0ZVZhcnlQYXRoLFxuICBnZXRTZWdtZW50VmFyeVBhdGhGb3JSZXF1ZXN0LFxuICBhcHBlbmRMYXlvdXRWYXJ5UGF0aCxcbiAgZmluYWxpemVMYXlvdXRWYXJ5UGF0aCxcbiAgZmluYWxpemVQYWdlVmFyeVBhdGgsXG4gIGNsb25lUGFnZVZhcnlQYXRoV2l0aE5ld1NlYXJjaFBhcmFtcyxcbiAgdHlwZSBQYWdlVmFyeVBhdGgsXG4gIGZpbmFsaXplTWV0YWRhdGFWYXJ5UGF0aCxcbn0gZnJvbSAnLi92YXJ5LXBhdGgnXG5pbXBvcnQgeyBnZXRBcHBCdWlsZElkIH0gZnJvbSAnLi4vLi4vYXBwLWJ1aWxkLWlkJ1xuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuLi9yb3V0ZXItcmVkdWNlci9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB0eXBlIHsgTm9ybWFsaXplZFNlYXJjaCwgUm91dGVDYWNoZUtleSB9IGZyb20gJy4vY2FjaGUta2V5J1xuLy8gVE9ETzogUmVuYW1lIHRoaXMgbW9kdWxlIHRvIGF2b2lkIGNvbmZ1c2lvbiB3aXRoIG90aGVyIHR5cGVzIG9mIGNhY2hlIGtleXNcbmltcG9ydCB7IGNyZWF0ZUNhY2hlS2V5IGFzIGNyZWF0ZVByZWZldGNoUmVxdWVzdEtleSB9IGZyb20gJy4vY2FjaGUta2V5J1xuaW1wb3J0IHtcbiAgZG9lc1N0YXRpY1NlZ21lbnRBcHBlYXJJblVSTCxcbiAgZ2V0Q2FjaGVLZXlGb3JEeW5hbWljUGFyYW0sXG4gIGdldFJlbmRlcmVkUGF0aG5hbWUsXG4gIGdldFJlbmRlcmVkU2VhcmNoLFxuICBwYXJzZUR5bmFtaWNQYXJhbUZyb21VUkxQYXJ0LFxufSBmcm9tICcuLi8uLi9yb3V0ZS1wYXJhbXMnXG5pbXBvcnQge1xuICBjcmVhdGVDYWNoZU1hcCxcbiAgZ2V0RnJvbUNhY2hlTWFwLFxuICBzZXRJbkNhY2hlTWFwLFxuICBzZXRTaXplSW5DYWNoZU1hcCxcbiAgZGVsZXRlRnJvbUNhY2hlTWFwLFxuICBpc1ZhbHVlRXhwaXJlZCxcbiAgdHlwZSBDYWNoZU1hcCxcbiAgdHlwZSBVbmtub3duTWFwRW50cnksXG59IGZyb20gJy4vY2FjaGUtbWFwJ1xuaW1wb3J0IHtcbiAgYXBwZW5kU2VnbWVudFJlcXVlc3RLZXlQYXJ0LFxuICBjb252ZXJ0U2VnbWVudFBhdGhUb1N0YXRpY0V4cG9ydEZpbGVuYW1lLFxuICBjcmVhdGVTZWdtZW50UmVxdWVzdEtleVBhcnQsXG4gIEhFQURfUkVRVUVTVF9LRVksXG4gIFJPT1RfU0VHTUVOVF9SRVFVRVNUX0tFWSxcbiAgdHlwZSBTZWdtZW50UmVxdWVzdEtleSxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50LWNhY2hlL3NlZ21lbnQtdmFsdWUtZW5jb2RpbmcnXG5pbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBOYXZpZ2F0aW9uRmxpZ2h0UmVzcG9uc2UsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci10eXBlcydcbmltcG9ydCB7XG4gIG5vcm1hbGl6ZUZsaWdodERhdGEsXG4gIHByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QsXG59IGZyb20gJy4uLy4uL2ZsaWdodC1kYXRhLWhlbHBlcnMnXG5pbXBvcnQgeyBTVEFUSUNfU1RBTEVUSU1FX01TIH0gZnJvbSAnLi4vcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlcidcbmltcG9ydCB7IHBpbmdWaXNpYmxlTGlua3MgfSBmcm9tICcuLi9saW5rcydcbmltcG9ydCB7IFBBR0VfU0VHTUVOVF9LRVkgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL3NlZ21lbnQnXG5pbXBvcnQgeyBGZXRjaFN0cmF0ZWd5IH0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB7IGNyZWF0ZVByb21pc2VXaXRoUmVzb2x2ZXJzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9wcm9taXNlLXdpdGgtcmVzb2x2ZXJzJ1xuXG4vKipcbiAqIEVuc3VyZXMgYSBtaW5pbXVtIHN0YWxlIHRpbWUgb2YgMzBzIHRvIGF2b2lkIGlzc3VlcyB3aGVyZSB0aGUgc2VydmVyIHNlbmRzIGEgdG9vXG4gKiBzaG9ydC1saXZlZCBzdGFsZSB0aW1lLCB3aGljaCB3b3VsZCBwcmV2ZW50IGFueXRoaW5nIGZyb20gYmVpbmcgcHJlZmV0Y2hlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YWxlVGltZU1zKHN0YWxlVGltZVNlY29uZHM6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLm1heChzdGFsZVRpbWVTZWNvbmRzLCAzMCkgKiAxMDAwXG59XG5cbi8vIEEgbm90ZSBvbiBhc3luYy9hd2FpdCB3aGVuIHdvcmtpbmcgaW4gdGhlIHByZWZldGNoIGNhY2hlOlxuLy9cbi8vIE1vc3QgYXN5bmMgb3BlcmF0aW9ucyBpbiB0aGUgcHJlZmV0Y2ggY2FjaGUgc2hvdWxkICpub3QqIHVzZSBhc3luYy9hd2FpdCxcbi8vIEluc3RlYWQsIHNwYXduIGEgc3VidGFzayB0aGF0IHdyaXRlcyB0aGUgcmVzdWx0cyB0byBhIGNhY2hlIGVudHJ5LCBhbmQgYXR0YWNoXG4vLyBhIFwicGluZ1wiIGxpc3RlbmVyIHRvIG5vdGlmeSB0aGUgcHJlZmV0Y2ggcXVldWUgdG8gdHJ5IGFnYWluLlxuLy9cbi8vIFRoZSByZWFzb24gaXMgd2UgbmVlZCB0byBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgc2VnbWVudCBjYWNoZSBhbmQgdHJhdmVyc2UgaXRzXG4vLyBkYXRhIHN0cnVjdHVyZXMgc3luY2hyb25vdXNseS4gRm9yIGV4YW1wbGUsIGlmIHRoZXJlJ3MgYSBzeW5jaHJvbm91cyB1cGRhdGVcbi8vIHdlIGNhbiB0YWtlIGFuIGltbWVkaWF0ZSBzbmFwc2hvdCBvZiB0aGUgY2FjaGUgdG8gcHJvZHVjZSBzb21ldGhpbmcgd2UgY2FuXG4vLyByZW5kZXIuIExpbWl0aW5nIHRoZSB1c2Ugb2YgYXN5bmMvYXdhaXQgYWxzbyBtYWtlcyBpdCBlYXNpZXIgdG8gYXZvaWQgcmFjZVxuLy8gY29uZGl0aW9ucywgd2hpY2ggaXMgZXNwZWNpYWxseSBpbXBvcnRhbnQgYmVjYXVzZSBpcyBjYWNoZSBpcyBtdXRhYmxlLlxuLy9cbi8vIEFub3RoZXIgcmVhc29uIGlzIHRoYXQgd2hpbGUgd2UncmUgcGVyZm9ybWluZyBhc3luYyB3b3JrLCBpdCdzIHBvc3NpYmxlIGZvclxuLy8gZXhpc3RpbmcgZW50cmllcyB0byBiZWNvbWUgc3RhbGUsIG9yIGZvciBMaW5rIHByZWZldGNoZXMgdG8gYmUgcmVtb3ZlZCBmcm9tXG4vLyB0aGUgcXVldWUuIEZvciBvcHRpbWFsIHNjaGVkdWxpbmcsIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBcImNhbmNlbFwiIHN1YnRhc2tzXG4vLyB0aGF0IGFyZSBubyBsb25nZXIgbmVlZGVkLiBTbywgd2hlbiBhIHNlZ21lbnQgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLCB3ZVxuLy8gcmVzdGFydCBmcm9tIHRoZSByb290IG9mIHRoZSB0cmVlIHRoYXQncyBiZWluZyBwcmVmZXRjaGVkLCB0byBjb25maXJtIGFsbCB0aGVcbi8vIHBhcmVudCBzZWdtZW50cyBhcmUgc3RpbGwgY2FjaGVkLiBJZiB0aGUgc2VnbWVudCBpcyBubyBsb25nZXIgcmVhY2hhYmxlIGZyb21cbi8vIHRoZSByb290LCB0aGVuIGl0J3MgZWZmZWN0aXZlbHkgY2FuY2VsZWQuIFRoaXMgaXMgc2ltaWxhciB0byB0aGUgZGVzaWduIG9mXG4vLyBSdXN0IEZ1dHVyZXMsIG9yIFJlYWN0IFN1c3BlbnNlLlxuXG50eXBlIFJvdXRlVHJlZVNoYXJlZCA9IHtcbiAgcmVxdWVzdEtleTogU2VnbWVudFJlcXVlc3RLZXlcbiAgLy8gVE9ETzogUmVtb3ZlIHRoZSBgc2VnbWVudGAgZmllbGQsIG5vdyB0aGF0IGl0IGNhbiBiZSByZWNvbnN0cnVjdGVkXG4gIC8vIGZyb20gYHBhcmFtYC5cbiAgc2VnbWVudDogRmxpZ2h0Um91dGVyU3RhdGVTZWdtZW50XG4gIHNsb3RzOiBudWxsIHwge1xuICAgIFtwYXJhbGxlbFJvdXRlS2V5OiBzdHJpbmddOiBSb3V0ZVRyZWVcbiAgfVxuICBpc1Jvb3RMYXlvdXQ6IGJvb2xlYW5cblxuICAvLyBJZiB0aGlzIGlzIGEgZHluYW1pYyByb3V0ZSwgaW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYSBsb2FkaW5nIGJvdW5kYXJ5XG4gIC8vIHNvbWV3aGVyZSBpbiB0aGUgdHJlZS4gSWYgbm90LCB3ZSBjYW4gc2tpcCB0aGUgcHJlZmV0Y2ggZm9yIHRoZSBkYXRhLFxuICAvLyBiZWNhdXNlIHdlIGtub3cgaXQgd291bGQgYmUgYW4gZW1wdHkgcmVzcG9uc2UuIChGb3IgYSBzdGF0aWMvUFBSIHJvdXRlLFxuICAvLyB0aGlzIHZhbHVlIGlzIGRpc3JlZ2FyZGVkLCBiZWNhdXNlIGluIHRoYXQgbW9kZWwgYGxvYWRpbmcudHN4YCBpcyB0cmVhdGVkXG4gIC8vIGxpa2UgYW55IG90aGVyIFN1c3BlbnNlIGJvdW5kYXJ5LilcbiAgaGFzTG9hZGluZ0JvdW5kYXJ5OiBIYXNMb2FkaW5nQm91bmRhcnlcblxuICAvLyBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHJvdXRlIGhhcyBhIHJ1bnRpbWUgcHJlZmV0Y2ggdGhhdCB3ZSBjYW4gcmVxdWVzdC5cbiAgLy8gVGhpcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBzZXJ2ZXI7IGl0J3Mgbm90IHB1cmVseSBhIHVzZXIgY29uZmlndXJhdGlvblxuICAvLyBiZWNhdXNlIHRoZSBzZXJ2ZXIgbWF5IGRldGVybWluZSB0aGF0IGEgcm91dGUgaXMgZnVsbHkgc3RhdGljIGFuZCBkb2Vzbid0XG4gIC8vIG5lZWQgcnVudGltZSBwcmVmZXRjaGluZyByZWdhcmRsZXNzIG9mIHRoZSBjb25maWd1cmF0aW9uLlxuICBoYXNSdW50aW1lUHJlZmV0Y2g6IGJvb2xlYW5cbn1cblxudHlwZSBMYXlvdXRSb3V0ZVRyZWUgPSBSb3V0ZVRyZWVTaGFyZWQgJiB7XG4gIGlzUGFnZTogZmFsc2VcbiAgdmFyeVBhdGg6IFNlZ21lbnRWYXJ5UGF0aFxufVxuXG50eXBlIFBhZ2VSb3V0ZVRyZWUgPSBSb3V0ZVRyZWVTaGFyZWQgJiB7XG4gIGlzUGFnZTogdHJ1ZVxuICB2YXJ5UGF0aDogUGFnZVZhcnlQYXRoXG59XG5cbmV4cG9ydCB0eXBlIFJvdXRlVHJlZSA9IExheW91dFJvdXRlVHJlZSB8IFBhZ2VSb3V0ZVRyZWVcblxudHlwZSBSb3V0ZUNhY2hlRW50cnlTaGFyZWQgPSB7XG4gIC8vIFRoaXMgaXMgZmFsc2Ugb25seSBpZiB3ZSdyZSBjZXJ0YWluIHRoZSByb3V0ZSBjYW5ub3QgYmUgaW50ZXJjZXB0ZWQuIEl0J3NcbiAgLy8gdHJ1ZSBpbiBhbGwgb3RoZXIgY2FzZXMsIGluY2x1ZGluZyBvbiBpbml0aWFsaXphdGlvbiB3aGVuIHdlIGhhdmVuJ3QgeWV0XG4gIC8vIHJlY2VpdmVkIGEgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLlxuICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGJvb2xlYW5cblxuICAvLyBNYXAtcmVsYXRlZCBmaWVsZHMuXG4gIHJlZjogVW5rbm93bk1hcEVudHJ5IHwgbnVsbFxuICBzaXplOiBudW1iZXJcbiAgc3RhbGVBdDogbnVtYmVyXG4gIHZlcnNpb246IG51bWJlclxufVxuXG4vKipcbiAqIFRyYWNrcyB0aGUgc3RhdHVzIG9mIGEgY2FjaGUgZW50cnkgYXMgaXQgcHJvZ3Jlc3NlcyBmcm9tIG5vIGRhdGEgKEVtcHR5KSxcbiAqIHdhaXRpbmcgZm9yIHNlcnZlciBkYXRhIChQZW5kaW5nKSwgYW5kIGZpbmlzaGVkIChlaXRoZXIgRnVsZmlsbGVkIG9yXG4gKiBSZWplY3RlZCBkZXBlbmRpbmcgb24gdGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gRW50cnlTdGF0dXMge1xuICBFbXB0eSA9IDAsXG4gIFBlbmRpbmcgPSAxLFxuICBGdWxmaWxsZWQgPSAyLFxuICBSZWplY3RlZCA9IDMsXG59XG5cbnR5cGUgUGVuZGluZ1JvdXRlQ2FjaGVFbnRyeSA9IFJvdXRlQ2FjaGVFbnRyeVNoYXJlZCAmIHtcbiAgc3RhdHVzOiBFbnRyeVN0YXR1cy5FbXB0eSB8IEVudHJ5U3RhdHVzLlBlbmRpbmdcbiAgYmxvY2tlZFRhc2tzOiBTZXQ8UHJlZmV0Y2hUYXNrPiB8IG51bGxcbiAgY2Fub25pY2FsVXJsOiBudWxsXG4gIHJlbmRlcmVkU2VhcmNoOiBudWxsXG4gIHRyZWU6IG51bGxcbiAgbWV0YWRhdGE6IG51bGxcbiAgaXNQUFJFbmFibGVkOiBmYWxzZVxufVxuXG50eXBlIFJlamVjdGVkUm91dGVDYWNoZUVudHJ5ID0gUm91dGVDYWNoZUVudHJ5U2hhcmVkICYge1xuICBzdGF0dXM6IEVudHJ5U3RhdHVzLlJlamVjdGVkXG4gIGJsb2NrZWRUYXNrczogU2V0PFByZWZldGNoVGFzaz4gfCBudWxsXG4gIGNhbm9uaWNhbFVybDogbnVsbFxuICByZW5kZXJlZFNlYXJjaDogbnVsbFxuICB0cmVlOiBudWxsXG4gIG1ldGFkYXRhOiBudWxsXG4gIGlzUFBSRW5hYmxlZDogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBGdWxmaWxsZWRSb3V0ZUNhY2hlRW50cnkgPSBSb3V0ZUNhY2hlRW50cnlTaGFyZWQgJiB7XG4gIHN0YXR1czogRW50cnlTdGF0dXMuRnVsZmlsbGVkXG4gIGJsb2NrZWRUYXNrczogbnVsbFxuICBjYW5vbmljYWxVcmw6IHN0cmluZ1xuICByZW5kZXJlZFNlYXJjaDogTm9ybWFsaXplZFNlYXJjaFxuICB0cmVlOiBSb3V0ZVRyZWVcbiAgbWV0YWRhdGE6IFJvdXRlVHJlZVxuICBpc1BQUkVuYWJsZWQ6IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgUm91dGVDYWNoZUVudHJ5ID1cbiAgfCBQZW5kaW5nUm91dGVDYWNoZUVudHJ5XG4gIHwgRnVsZmlsbGVkUm91dGVDYWNoZUVudHJ5XG4gIHwgUmVqZWN0ZWRSb3V0ZUNhY2hlRW50cnlcblxudHlwZSBTZWdtZW50Q2FjaGVFbnRyeVNoYXJlZCA9IHtcbiAgZmV0Y2hTdHJhdGVneTogRmV0Y2hTdHJhdGVneVxuXG4gIC8vIE1hcC1yZWxhdGVkIGZpZWxkcy5cbiAgcmVmOiBVbmtub3duTWFwRW50cnkgfCBudWxsXG4gIHNpemU6IG51bWJlclxuICBzdGFsZUF0OiBudW1iZXJcbiAgdmVyc2lvbjogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIEVtcHR5U2VnbWVudENhY2hlRW50cnkgPSBTZWdtZW50Q2FjaGVFbnRyeVNoYXJlZCAmIHtcbiAgc3RhdHVzOiBFbnRyeVN0YXR1cy5FbXB0eVxuICByc2M6IG51bGxcbiAgbG9hZGluZzogbnVsbFxuICBpc1BhcnRpYWw6IHRydWVcbiAgcHJvbWlzZTogbnVsbFxufVxuXG5leHBvcnQgdHlwZSBQZW5kaW5nU2VnbWVudENhY2hlRW50cnkgPSBTZWdtZW50Q2FjaGVFbnRyeVNoYXJlZCAmIHtcbiAgc3RhdHVzOiBFbnRyeVN0YXR1cy5QZW5kaW5nXG4gIHJzYzogbnVsbFxuICBsb2FkaW5nOiBudWxsXG4gIGlzUGFydGlhbDogYm9vbGVhblxuICBwcm9taXNlOiBudWxsIHwgUHJvbWlzZVdpdGhSZXNvbHZlcnM8RnVsZmlsbGVkU2VnbWVudENhY2hlRW50cnkgfCBudWxsPlxufVxuXG50eXBlIFJlamVjdGVkU2VnbWVudENhY2hlRW50cnkgPSBTZWdtZW50Q2FjaGVFbnRyeVNoYXJlZCAmIHtcbiAgc3RhdHVzOiBFbnRyeVN0YXR1cy5SZWplY3RlZFxuICByc2M6IG51bGxcbiAgbG9hZGluZzogbnVsbFxuICBpc1BhcnRpYWw6IHRydWVcbiAgcHJvbWlzZTogbnVsbFxufVxuXG5leHBvcnQgdHlwZSBGdWxmaWxsZWRTZWdtZW50Q2FjaGVFbnRyeSA9IFNlZ21lbnRDYWNoZUVudHJ5U2hhcmVkICYge1xuICBzdGF0dXM6IEVudHJ5U3RhdHVzLkZ1bGZpbGxlZFxuICByc2M6IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGxcbiAgbG9hZGluZzogTG9hZGluZ01vZHVsZURhdGEgfCBQcm9taXNlPExvYWRpbmdNb2R1bGVEYXRhPlxuICBpc1BhcnRpYWw6IGJvb2xlYW5cbiAgcHJvbWlzZTogbnVsbFxufVxuXG5leHBvcnQgdHlwZSBTZWdtZW50Q2FjaGVFbnRyeSA9XG4gIHwgRW1wdHlTZWdtZW50Q2FjaGVFbnRyeVxuICB8IFBlbmRpbmdTZWdtZW50Q2FjaGVFbnRyeVxuICB8IFJlamVjdGVkU2VnbWVudENhY2hlRW50cnlcbiAgfCBGdWxmaWxsZWRTZWdtZW50Q2FjaGVFbnRyeVxuXG5leHBvcnQgdHlwZSBOb25FbXB0eVNlZ21lbnRDYWNoZUVudHJ5ID0gRXhjbHVkZTxcbiAgU2VnbWVudENhY2hlRW50cnksXG4gIEVtcHR5U2VnbWVudENhY2hlRW50cnlcbj5cblxuY29uc3QgaXNPdXRwdXRFeHBvcnRNb2RlID1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJlxuICBwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gJ2V4cG9ydCdcblxuY29uc3QgTWV0YWRhdGFPbmx5UmVxdWVzdFRyZWU6IEZsaWdodFJvdXRlclN0YXRlID0gW1xuICAnJyxcbiAge30sXG4gIG51bGwsXG4gICdtZXRhZGF0YS1vbmx5Jyxcbl1cblxubGV0IHJvdXRlQ2FjaGVNYXA6IENhY2hlTWFwPFJvdXRlQ2FjaGVFbnRyeT4gPSBjcmVhdGVDYWNoZU1hcCgpXG5sZXQgc2VnbWVudENhY2hlTWFwOiBDYWNoZU1hcDxTZWdtZW50Q2FjaGVFbnRyeT4gPSBjcmVhdGVDYWNoZU1hcCgpXG5cbi8vIEFsbCBpbnZhbGlkYXRpb24gbGlzdGVuZXJzIGZvciB0aGUgd2hvbGUgY2FjaGUgYXJlIHRyYWNrZWQgaW4gc2luZ2xlIHNldC5cbi8vIFNpbmNlIHdlIGRvbid0IHlldCBzdXBwb3J0IHRhZyBvciBwYXRoLWJhc2VkIGludmFsaWRhdGlvbiwgdGhlcmUncyBubyBwb2ludFxuLy8gdHJhY2tpbmcgdGhlbSBhbnkgbW9yZSBncmFudWxhcmx5IHRoYW4gdGhpcy4gT25jZSB3ZSBhZGQgZ3JhbnVsYXJcbi8vIGludmFsaWRhdGlvbiwgdGhhdCBtYXkgY2hhbmdlLCB0aG91Z2ggZ2VuZXJhbGx5IHRoZSBtb2RlbCBpcyB0byBqdXN0IG5vdGlmeVxuLy8gdGhlIGxpc3RlbmVycyBhbmQgYWxsb3cgdGhlIGNhbGxlciB0byBwb2xsIHRoZSBwcmVmZXRjaCBjYWNoZSB3aXRoIGEgbmV3XG4vLyBwcmVmZXRjaCB0YXNrIGlmIGRlc2lyZWQuXG5sZXQgaW52YWxpZGF0aW9uTGlzdGVuZXJzOiBTZXQ8UHJlZmV0Y2hUYXNrPiB8IG51bGwgPSBudWxsXG5cbi8vIEluY3JlbWVudGluZyBjb3VudGVyIHVzZWQgdG8gdHJhY2sgY2FjaGUgaW52YWxpZGF0aW9ucy5cbmxldCBjdXJyZW50Q2FjaGVWZXJzaW9uID0gMFxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudENhY2hlVmVyc2lvbigpOiBudW1iZXIge1xuICByZXR1cm4gY3VycmVudENhY2hlVmVyc2lvblxufVxuXG4vKipcbiAqIFVzZWQgdG8gY2xlYXIgdGhlIGNsaWVudCBwcmVmZXRjaCBjYWNoZSB3aGVuIGEgc2VydmVyIGFjdGlvbiBjYWxsc1xuICogcmV2YWxpZGF0ZVBhdGggb3IgcmV2YWxpZGF0ZVRhZy4gRXZlbnR1YWxseSB3ZSB3aWxsIHN1cHBvcnQgb25seSBjbGVhcmluZyB0aGVcbiAqIHNlZ21lbnRzIHRoYXQgd2VyZSBhY3R1YWxseSBhZmZlY3RlZCwgYnV0IHRoZXJlJ3MgbW9yZSB3b3JrIHRvIGJlIGRvbmUgb24gdGhlXG4gKiBzZXJ2ZXIgYmVmb3JlIHRoZSBjbGllbnQgaXMgYWJsZSB0byBkbyB0aGlzIGNvcnJlY3RseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldmFsaWRhdGVFbnRpcmVDYWNoZShcbiAgbmV4dFVybDogc3RyaW5nIHwgbnVsbCxcbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbikge1xuICAvLyBJbmNyZW1lbnQgdGhlIGN1cnJlbnQgY2FjaGUgdmVyc2lvbi4gVGhpcyBkb2VzIG5vdCBlYWdlcmx5IGV2aWN0IGFueXRoaW5nXG4gIC8vIGZyb20gdGhlIGNhY2hlLCBidXQgYmVjYXVzZSBhbGwgdGhlIGVudHJpZXMgYXJlIHZlcnNpb25lZCwgYW5kIHdlIGNoZWNrXG4gIC8vIHRoZSB2ZXJzaW9uIHdoZW4gcmVhZGluZyBmcm9tIHRoZSBjYWNoZSwgdGhpcyBlZmZlY3RpdmVseSBjYXVzZXMgYWxsXG4gIC8vIGVudHJpZXMgdG8gYmUgZXZpY3RlZCBsYXppbHkuIFdlIGRvIGl0IGxhemlseSBiZWNhdXNlIGluIHRoZSBmdXR1cmUsXG4gIC8vIGFjdGlvbnMgbGlrZSByZXZhbGlkYXRlVGFnIG9yIHJlZnJlc2ggd2lsbCBub3QgZXZpY3QgdGhlIGVudGlyZSBjYWNoZSxcbiAgLy8gYnV0IHJhdGhlciBzb21lIHN1YnNldCBvZiB0aGUgZW50cmllcy5cbiAgY3VycmVudENhY2hlVmVyc2lvbisrXG5cbiAgLy8gU3RhcnQgYSBjb29sZG93biBiZWZvcmUgcmUtcHJlZmV0Y2hpbmcgdG8gYWxsb3cgQ0ROIGNhY2hlIHByb3BhZ2F0aW9uLlxuICBzdGFydFJldmFsaWRhdGlvbkNvb2xkb3duKClcblxuICAvLyBQcmVmZXRjaCBhbGwgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGxpbmtzIGFnYWluLCB0byByZS1maWxsIHRoZSBjYWNoZS5cbiAgcGluZ1Zpc2libGVMaW5rcyhuZXh0VXJsLCB0cmVlKVxuXG4gIC8vIFNpbWlsYXJseSwgbm90aWZ5IGFsbCBpbnZhbGlkYXRpb24gbGlzdGVuZXJzIChpLmUuIHRob3NlIHBhc3NlZCB0b1xuICAvLyBgcm91dGVyLnByZWZldGNoKG9uSW52YWxpZGF0ZSlgKSwgc28gdGhleSBjYW4gdHJpZ2dlciBhIG5ldyBwcmVmZXRjaFxuICAvLyBpZiBuZWVkZWQuXG4gIHBpbmdJbnZhbGlkYXRpb25MaXN0ZW5lcnMobmV4dFVybCwgdHJlZSlcbn1cblxuZnVuY3Rpb24gYXR0YWNoSW52YWxpZGF0aW9uTGlzdGVuZXIodGFzazogUHJlZmV0Y2hUYXNrKTogdm9pZCB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIGEgcHJlZmV0Y2ggdGFzayByZWFkcyBhIGNhY2hlIGVudHJ5LiBJZlxuICAvLyB0aGUgdGFzayBoYXMgYW4gb25JbnZhbGlkYXRlIGZ1bmN0aW9uIGFzc29jaWF0ZWQgd2l0aCBpdCDigJQgaS5lLiB0aGUgb25lXG4gIC8vIG9wdGlvbmFsbHkgcGFzc2VkIHRvIHJvdXRlci5wcmVmZXRjaChvbkludmFsaWRhdGUpIOKAlCB0aGVuIHdlIGF0dGFjaCB0aGF0XG4gIC8vIGxpc3RlbmVyIHRvIHRoZSBldmVyeSBjYWNoZSBlbnRyeSB0aGF0IHRoZSB0YXNrIHJlYWRzLiBUaGVuLCBpZiBhbiBlbnRyeVxuICAvLyBpcyBpbnZhbGlkYXRlZCwgd2UgY2FsbCB0aGUgZnVuY3Rpb24uXG4gIGlmICh0YXNrLm9uSW52YWxpZGF0ZSAhPT0gbnVsbCkge1xuICAgIGlmIChpbnZhbGlkYXRpb25MaXN0ZW5lcnMgPT09IG51bGwpIHtcbiAgICAgIGludmFsaWRhdGlvbkxpc3RlbmVycyA9IG5ldyBTZXQoW3Rhc2tdKVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhbGlkYXRpb25MaXN0ZW5lcnMuYWRkKHRhc2spXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vdGlmeUludmFsaWRhdGlvbkxpc3RlbmVyKHRhc2s6IFByZWZldGNoVGFzayk6IHZvaWQge1xuICBjb25zdCBvbkludmFsaWRhdGUgPSB0YXNrLm9uSW52YWxpZGF0ZVxuICBpZiAob25JbnZhbGlkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gQ2xlYXIgdGhlIGNhbGxiYWNrIGZyb20gdGhlIHRhc2sgb2JqZWN0IHRvIGd1YXJhbnRlZSBpdCdzIG5vdCBjYWxsZWQgbW9yZVxuICAgIC8vIHRoYW4gb25jZS5cbiAgICB0YXNrLm9uSW52YWxpZGF0ZSA9IG51bGxcblxuICAgIC8vIFRoaXMgaXMgYSB1c2VyLXNwYWNlIGZ1bmN0aW9uLCBzbyB3ZSBtdXN0IHdyYXAgaW4gdHJ5L2NhdGNoLlxuICAgIHRyeSB7XG4gICAgICBvbkludmFsaWRhdGUoKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcG9ydEVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcG9ydEVycm9yKGVycm9yKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcilcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBpbmdJbnZhbGlkYXRpb25MaXN0ZW5lcnMoXG4gIG5leHRVcmw6IHN0cmluZyB8IG51bGwsXG4gIHRyZWU6IEZsaWdodFJvdXRlclN0YXRlXG4pOiB2b2lkIHtcbiAgLy8gVGhlIHJvdWdoIGVxdWl2YWxlbnQgb2YgcGluZ1Zpc2libGVMaW5rcywgYnV0IGZvciBvbkludmFsaWRhdGUgY2FsbGJhY2tzLlxuICAvLyBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBOZXh0LVVybCBvciB0aGUgYmFzZSB0cmVlIGNoYW5nZXMsIHNpbmNlIHRob3NlXG4gIC8vIG1heSBhZmZlY3QgdGhlIHJlc3VsdCBvZiBhIHByZWZldGNoIHRhc2suIEl0J3MgYWxzbyBjYWxsZWQgYWZ0ZXIgYVxuICAvLyBjYWNoZSBpbnZhbGlkYXRpb24uXG4gIGlmIChpbnZhbGlkYXRpb25MaXN0ZW5lcnMgIT09IG51bGwpIHtcbiAgICBjb25zdCB0YXNrcyA9IGludmFsaWRhdGlvbkxpc3RlbmVyc1xuICAgIGludmFsaWRhdGlvbkxpc3RlbmVycyA9IG51bGxcbiAgICBmb3IgKGNvbnN0IHRhc2sgb2YgdGFza3MpIHtcbiAgICAgIGlmIChpc1ByZWZldGNoVGFza0RpcnR5KHRhc2ssIG5leHRVcmwsIHRyZWUpKSB7XG4gICAgICAgIG5vdGlmeUludmFsaWRhdGlvbkxpc3RlbmVyKHRhc2spXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkUm91dGVDYWNoZUVudHJ5KFxuICBub3c6IG51bWJlcixcbiAga2V5OiBSb3V0ZUNhY2hlS2V5XG4pOiBSb3V0ZUNhY2hlRW50cnkgfCBudWxsIHtcbiAgY29uc3QgdmFyeVBhdGg6IFJvdXRlVmFyeVBhdGggPSBnZXRSb3V0ZVZhcnlQYXRoKFxuICAgIGtleS5wYXRobmFtZSxcbiAgICBrZXkuc2VhcmNoLFxuICAgIGtleS5uZXh0VXJsXG4gIClcbiAgY29uc3QgaXNSZXZhbGlkYXRpb24gPSBmYWxzZVxuICByZXR1cm4gZ2V0RnJvbUNhY2hlTWFwKFxuICAgIG5vdyxcbiAgICBnZXRDdXJyZW50Q2FjaGVWZXJzaW9uKCksXG4gICAgcm91dGVDYWNoZU1hcCxcbiAgICB2YXJ5UGF0aCxcbiAgICBpc1JldmFsaWRhdGlvblxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkU2VnbWVudENhY2hlRW50cnkoXG4gIG5vdzogbnVtYmVyLFxuICB2YXJ5UGF0aDogU2VnbWVudFZhcnlQYXRoXG4pOiBTZWdtZW50Q2FjaGVFbnRyeSB8IG51bGwge1xuICBjb25zdCBpc1JldmFsaWRhdGlvbiA9IGZhbHNlXG4gIHJldHVybiBnZXRGcm9tQ2FjaGVNYXAoXG4gICAgbm93LFxuICAgIGdldEN1cnJlbnRDYWNoZVZlcnNpb24oKSxcbiAgICBzZWdtZW50Q2FjaGVNYXAsXG4gICAgdmFyeVBhdGgsXG4gICAgaXNSZXZhbGlkYXRpb25cbiAgKVxufVxuXG5mdW5jdGlvbiByZWFkUmV2YWxpZGF0aW5nU2VnbWVudENhY2hlRW50cnkoXG4gIG5vdzogbnVtYmVyLFxuICB2YXJ5UGF0aDogU2VnbWVudFZhcnlQYXRoXG4pOiBTZWdtZW50Q2FjaGVFbnRyeSB8IG51bGwge1xuICBjb25zdCBpc1JldmFsaWRhdGlvbiA9IHRydWVcbiAgcmV0dXJuIGdldEZyb21DYWNoZU1hcChcbiAgICBub3csXG4gICAgZ2V0Q3VycmVudENhY2hlVmVyc2lvbigpLFxuICAgIHNlZ21lbnRDYWNoZU1hcCxcbiAgICB2YXJ5UGF0aCxcbiAgICBpc1JldmFsaWRhdGlvblxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YWl0Rm9yU2VnbWVudENhY2hlRW50cnkoXG4gIHBlbmRpbmdFbnRyeTogUGVuZGluZ1NlZ21lbnRDYWNoZUVudHJ5XG4pOiBQcm9taXNlPEZ1bGZpbGxlZFNlZ21lbnRDYWNoZUVudHJ5IHwgbnVsbD4ge1xuICAvLyBCZWNhdXNlIHRoZSBlbnRyeSBpcyBwZW5kaW5nLCB0aGVyZSdzIGFscmVhZHkgYSBpbi1wcm9ncmVzcyByZXF1ZXN0LlxuICAvLyBBdHRhY2ggYSBwcm9taXNlIHRvIHRoZSBlbnRyeSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIHRoZSBzZXJ2ZXIgcmVzcG9uZHMuXG4gIGxldCBwcm9taXNlV2l0aFJlc29sdmVycyA9IHBlbmRpbmdFbnRyeS5wcm9taXNlXG4gIGlmIChwcm9taXNlV2l0aFJlc29sdmVycyA9PT0gbnVsbCkge1xuICAgIHByb21pc2VXaXRoUmVzb2x2ZXJzID0gcGVuZGluZ0VudHJ5LnByb21pc2UgPVxuICAgICAgY3JlYXRlUHJvbWlzZVdpdGhSZXNvbHZlcnM8RnVsZmlsbGVkU2VnbWVudENhY2hlRW50cnkgfCBudWxsPigpXG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgcHJvbWlzZSB3ZSBjYW4gdXNlXG4gIH1cbiAgcmV0dXJuIHByb21pc2VXaXRoUmVzb2x2ZXJzLnByb21pc2Vcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gZW50cnkgZm9yIGEgcm91dGUgZXhpc3RzIGluIHRoZSBjYWNoZS4gSWYgc28sIGl0IHJldHVybnMgdGhlXG4gKiBlbnRyeSwgSWYgbm90LCBpdCBhZGRzIGFuIGVtcHR5IGVudHJ5IHRvIHRoZSBjYWNoZSBhbmQgcmV0dXJucyBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRPckNyZWF0ZVJvdXRlQ2FjaGVFbnRyeShcbiAgbm93OiBudW1iZXIsXG4gIHRhc2s6IFByZWZldGNoVGFzayxcbiAga2V5OiBSb3V0ZUNhY2hlS2V5XG4pOiBSb3V0ZUNhY2hlRW50cnkge1xuICBhdHRhY2hJbnZhbGlkYXRpb25MaXN0ZW5lcih0YXNrKVxuXG4gIGNvbnN0IGV4aXN0aW5nRW50cnkgPSByZWFkUm91dGVDYWNoZUVudHJ5KG5vdywga2V5KVxuICBpZiAoZXhpc3RpbmdFbnRyeSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBleGlzdGluZ0VudHJ5XG4gIH1cbiAgLy8gQ3JlYXRlIGEgcGVuZGluZyBlbnRyeSBhbmQgYWRkIGl0IHRvIHRoZSBjYWNoZS5cbiAgY29uc3QgcGVuZGluZ0VudHJ5OiBQZW5kaW5nUm91dGVDYWNoZUVudHJ5ID0ge1xuICAgIGNhbm9uaWNhbFVybDogbnVsbCxcbiAgICBzdGF0dXM6IEVudHJ5U3RhdHVzLkVtcHR5LFxuICAgIGJsb2NrZWRUYXNrczogbnVsbCxcbiAgICB0cmVlOiBudWxsLFxuICAgIG1ldGFkYXRhOiBudWxsLFxuICAgIC8vIFRoaXMgaXMgaW5pdGlhbGl6ZWQgdG8gdHJ1ZSBiZWNhdXNlIHdlIGRvbid0IGtub3cgeWV0IHdoZXRoZXIgdGhlIHJvdXRlXG4gICAgLy8gY291bGQgYmUgaW50ZXJjZXB0ZWQuIEl0J3Mgb25seSBzZXQgdG8gZmFsc2Ugb25jZSB3ZSByZWNlaXZlIGEgcmVzcG9uc2VcbiAgICAvLyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgY291bGRCZUludGVyY2VwdGVkOiB0cnVlLFxuICAgIC8vIFNpbWlsYXJseSwgd2UgZG9uJ3QgeWV0IGtub3cgaWYgdGhlIHJvdXRlIHN1cHBvcnRzIFBQUi5cbiAgICBpc1BQUkVuYWJsZWQ6IGZhbHNlLFxuICAgIHJlbmRlcmVkU2VhcmNoOiBudWxsLFxuXG4gICAgLy8gTWFwLXJlbGF0ZWQgZmllbGRzXG4gICAgcmVmOiBudWxsLFxuICAgIHNpemU6IDAsXG4gICAgLy8gU2luY2UgdGhpcyBpcyBhbiBlbXB0eSBlbnRyeSwgdGhlcmUncyBubyByZWFzb24gdG8gZXZlciBldmljdCBpdC4gSXQgd2lsbFxuICAgIC8vIGJlIHVwZGF0ZWQgd2hlbiB0aGUgZGF0YSBpcyBwb3B1bGF0ZWQuXG4gICAgc3RhbGVBdDogSW5maW5pdHksXG4gICAgdmVyc2lvbjogZ2V0Q3VycmVudENhY2hlVmVyc2lvbigpLFxuICB9XG4gIGNvbnN0IHZhcnlQYXRoOiBSb3V0ZVZhcnlQYXRoID0gZ2V0Um91dGVWYXJ5UGF0aChcbiAgICBrZXkucGF0aG5hbWUsXG4gICAga2V5LnNlYXJjaCxcbiAgICBrZXkubmV4dFVybFxuICApXG4gIGNvbnN0IGlzUmV2YWxpZGF0aW9uID0gZmFsc2VcbiAgc2V0SW5DYWNoZU1hcChyb3V0ZUNhY2hlTWFwLCB2YXJ5UGF0aCwgcGVuZGluZ0VudHJ5LCBpc1JldmFsaWRhdGlvbilcbiAgcmV0dXJuIHBlbmRpbmdFbnRyeVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdE9wdGltaXN0aWNSb3V0ZUNhY2hlRW50cnkoXG4gIG5vdzogbnVtYmVyLFxuICByZXF1ZXN0ZWRVcmw6IFVSTCxcbiAgbmV4dFVybDogc3RyaW5nIHwgbnVsbFxuKTogRnVsZmlsbGVkUm91dGVDYWNoZUVudHJ5IHwgbnVsbCB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGR1cmluZyBhIG5hdmlnYXRpb24gd2hlbiB0aGVyZSB3YXMgbm8gbWF0Y2hpbmdcbiAgLy8gcm91dGUgdHJlZSBpbiB0aGUgcHJlZmV0Y2ggY2FjaGUuIEJlZm9yZSBkZS1vcHRpbmcgdG8gYSBibG9ja2luZyxcbiAgLy8gdW5wcmVmZXRjaGVkIG5hdmlnYXRpb24sIHdlIHdpbGwgZmlyc3QgYXR0ZW1wdCB0byBjb25zdHJ1Y3QgYW4gXCJvcHRpbWlzdGljXCJcbiAgLy8gcm91dGUgdHJlZSBieSBjaGVja2luZyB0aGUgY2FjaGUgZm9yIHNpbWlsYXIgcm91dGVzLlxuICAvL1xuICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgcm91dGUgd2l0aCB0aGUgc2FtZSBwYXRobmFtZSwgYnV0IHdpdGggZGlmZmVyZW50XG4gIC8vIHNlYXJjaCBwYXJhbXMuIFdlIGNhbiB0aGVuIGJhc2Ugb3VyIG9wdGltaXN0aWMgcm91dGUgdHJlZSBvbiB0aGlzIGVudHJ5LlxuICAvL1xuICAvLyBDb25jZXB0dWFsbHksIHdlIGFyZSBzaW11bGF0aW5nIHdoYXQgd291bGQgaGFwcGVuIGlmIHdlIGRpZCBwZXJmb3JtIGFcbiAgLy8gcHJlZmV0Y2ggdGhlIHJlcXVlc3RlZCBVUkwsIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhlIHNlcnZlciB3aWxsXG4gIC8vIG5vdCByZWRpcmVjdCBvciByZXdyaXRlIHRoZSByZXF1ZXN0IGluIGEgZGlmZmVyZW50IG1hbm5lciB0aGFuIHRoZVxuICAvLyBiYXNlIHJvdXRlIHRyZWUuIFRoaXMgYXNzdW1wdGlvbiBtaWdodCBub3QgaG9sZCwgaW4gd2hpY2ggY2FzZSB3ZSdsbCBoYXZlXG4gIC8vIHRvIHJlY292ZXIgd2hlbiB3ZSBwZXJmb3JtIHRoZSBkeW5hbWljIG5hdmlnYXRpb24gcmVxdWVzdC4gSG93ZXZlciwgdGhpc1xuICAvLyBpcyB3aGF0IHdvdWxkIGhhcHBlbiBpZiBhIHJvdXRlIHdlcmUgZHluYW1pY2FsbHkgcmV3cml0dGVuL3JlZGlyZWN0ZWRcbiAgLy8gaW4gYmV0d2VlbiB0aGUgcHJlZmV0Y2ggYW5kIHRoZSBuYXZpZ2F0aW9uLiBTbyB0aGUgbG9naWMgbmVlZHMgdG8gZXhpc3RcbiAgLy8gdG8gaGFuZGxlIHRoaXMgY2FzZSByZWdhcmRsZXNzLlxuXG4gIC8vIExvb2sgZm9yIGEgcm91dGUgd2l0aCB0aGUgc2FtZSBwYXRobmFtZSwgYnV0IHdpdGggYW4gZW1wdHkgc2VhcmNoIHN0cmluZy5cbiAgLy8gVE9ETzogVGhlcmUncyBub3RoaW5nIGluaGVyZW50bHkgc3BlY2lhbCBhYm91dCB0aGUgZW1wdHkgc2VhcmNoIHN0cmluZztcbiAgLy8gaXQncyBjaG9zZW4gc29tZXdoYXQgYXJiaXRyYXJpbHksIHdpdGggdGhlIHJhdGlvbmFsZSB0aGF0IGl0J3MgdGhlIG1vc3RcbiAgLy8gbGlrZWx5IG9uZSB0byBleGlzdC4gQnV0IHdlIHNob3VsZCB1cGRhdGUgdGhpcyB0byBtYXRjaCBfYW55XyBzZWFyY2hcbiAgLy8gc3RyaW5nLiBUaGUgcGxhbiBpcyB0byBnZW5lcmFsaXplIHRoaXMgbG9naWMgYWxvbmdzaWRlIG90aGVyIGltcHJvdmVtZW50c1xuICAvLyByZWxhdGVkIHRvIFwiZmFsbGJhY2tcIiBjYWNoZSBlbnRyaWVzLlxuICBjb25zdCByZXF1ZXN0ZWRTZWFyY2ggPSByZXF1ZXN0ZWRVcmwuc2VhcmNoIGFzIE5vcm1hbGl6ZWRTZWFyY2hcbiAgaWYgKHJlcXVlc3RlZFNlYXJjaCA9PT0gJycpIHtcbiAgICAvLyBUaGUgY2FsbGVyIHdvdWxkIGhhdmUgYWxyZWFkeSBjaGVja2VkIGlmIGEgcm91dGUgd2l0aCBhbiBlbXB0eSBzZWFyY2hcbiAgICAvLyBzdHJpbmcgaXMgaW4gdGhlIGNhY2hlLiBTbyB3ZSBjYW4gYmFpbCBvdXQgaGVyZS5cbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGNvbnN0IHVybFdpdGhvdXRTZWFyY2hQYXJhbXMgPSBuZXcgVVJMKHJlcXVlc3RlZFVybClcbiAgdXJsV2l0aG91dFNlYXJjaFBhcmFtcy5zZWFyY2ggPSAnJ1xuICBjb25zdCByb3V0ZVdpdGhOb1NlYXJjaFBhcmFtcyA9IHJlYWRSb3V0ZUNhY2hlRW50cnkoXG4gICAgbm93LFxuICAgIGNyZWF0ZVByZWZldGNoUmVxdWVzdEtleSh1cmxXaXRob3V0U2VhcmNoUGFyYW1zLmhyZWYsIG5leHRVcmwpXG4gIClcblxuICBpZiAoXG4gICAgcm91dGVXaXRoTm9TZWFyY2hQYXJhbXMgPT09IG51bGwgfHxcbiAgICByb3V0ZVdpdGhOb1NlYXJjaFBhcmFtcy5zdGF0dXMgIT09IEVudHJ5U3RhdHVzLkZ1bGZpbGxlZFxuICApIHtcbiAgICAvLyBCYWlsIG91dCBvZiBjb25zdHJ1Y3RpbmcgYW4gb3B0aW1pc3RpYyByb3V0ZSB0cmVlLiBUaGlzIHdpbGwgcmVzdWx0IGluXG4gICAgLy8gYSBibG9ja2luZywgdW5wcmVmZXRjaGVkIG5hdmlnYXRpb24uXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIE5vdyB3ZSBoYXZlIGEgYmFzZSByb3V0ZSB0cmVlIHdlIGNhbiBcInBhdGNoXCIgd2l0aCBvdXIgb3B0aW1pc3RpYyB2YWx1ZXMuXG5cbiAgLy8gT3B0aW1pc3RpY2FsbHkgYXNzdW1lIHRoYXQgcmVkaXJlY3RzIGZvciB0aGUgcmVxdWVzdGVkIHBhdGhuYW1lIGRvXG4gIC8vIG5vdCB2YXJ5IG9uIHRoZSBzZWFyY2ggc3RyaW5nLiBUaGVyZWZvcmUsIGlmIHRoZSBiYXNlIHJvdXRlIHdhc1xuICAvLyByZWRpcmVjdGVkIHRvIGEgZGlmZmVyZW50IHNlYXJjaCBzdHJpbmcsIHRoZW4gdGhlIG9wdGltaXN0aWMgcm91dGVcbiAgLy8gc2hvdWxkIGJlIHJlZGlyZWN0ZWQgdG8gdGhlIHNhbWUgc2VhcmNoIHN0cmluZy4gT3RoZXJ3aXNlLCB3ZSB1c2VcbiAgLy8gdGhlIHJlcXVlc3RlZCBzZWFyY2ggc3RyaW5nLlxuICBjb25zdCBjYW5vbmljYWxVcmxGb3JSb3V0ZVdpdGhOb1NlYXJjaFBhcmFtcyA9IG5ldyBVUkwoXG4gICAgcm91dGVXaXRoTm9TZWFyY2hQYXJhbXMuY2Fub25pY2FsVXJsLFxuICAgIHJlcXVlc3RlZFVybC5vcmlnaW5cbiAgKVxuICBjb25zdCBvcHRpbWlzdGljQ2Fub25pY2FsU2VhcmNoID1cbiAgICBjYW5vbmljYWxVcmxGb3JSb3V0ZVdpdGhOb1NlYXJjaFBhcmFtcy5zZWFyY2ggIT09ICcnXG4gICAgICA/IC8vIEJhc2Ugcm91dGUgd2FzIHJlZGlyZWN0ZWQuIFJldXNlIHRoZSBzYW1lIHJlZGlyZWN0ZWQgc2VhcmNoIHN0cmluZy5cbiAgICAgICAgY2Fub25pY2FsVXJsRm9yUm91dGVXaXRoTm9TZWFyY2hQYXJhbXMuc2VhcmNoXG4gICAgICA6IHJlcXVlc3RlZFNlYXJjaFxuXG4gIC8vIFNpbWlsYXJseSwgb3B0aW1pc3RpY2FsbHkgYXNzdW1lIHRoYXQgcmV3cml0ZXMgZm9yIHRoZSByZXF1ZXN0ZWRcbiAgLy8gcGF0aG5hbWUgZG8gbm90IHZhcnkgb24gdGhlIHNlYXJjaCBzdHJpbmcuIFRoZXJlZm9yZSwgaWYgdGhlIGJhc2VcbiAgLy8gcm91dGUgd2FzIHJld3JpdHRlbiB0byBhIGRpZmZlcmVudCBzZWFyY2ggc3RyaW5nLCB0aGVuIHRoZSBvcHRpbWlzdGljXG4gIC8vIHJvdXRlIHNob3VsZCBiZSByZXdyaXR0ZW4gdG8gdGhlIHNhbWUgc2VhcmNoIHN0cmluZy4gT3RoZXJ3aXNlLCB3ZSB1c2VcbiAgLy8gdGhlIHJlcXVlc3RlZCBzZWFyY2ggc3RyaW5nLlxuICBjb25zdCBvcHRpbWlzdGljUmVuZGVyZWRTZWFyY2ggPVxuICAgIHJvdXRlV2l0aE5vU2VhcmNoUGFyYW1zLnJlbmRlcmVkU2VhcmNoICE9PSAnJ1xuICAgICAgPyAvLyBCYXNlIHJvdXRlIHdhcyByZXdyaXR0ZW4uIFJldXNlIHRoZSBzYW1lIHJld3JpdHRlbiBzZWFyY2ggc3RyaW5nLlxuICAgICAgICByb3V0ZVdpdGhOb1NlYXJjaFBhcmFtcy5yZW5kZXJlZFNlYXJjaFxuICAgICAgOiByZXF1ZXN0ZWRTZWFyY2hcblxuICBjb25zdCBvcHRpbWlzdGljVXJsID0gbmV3IFVSTChcbiAgICByb3V0ZVdpdGhOb1NlYXJjaFBhcmFtcy5jYW5vbmljYWxVcmwsXG4gICAgbG9jYXRpb24ub3JpZ2luXG4gIClcbiAgb3B0aW1pc3RpY1VybC5zZWFyY2ggPSBvcHRpbWlzdGljQ2Fub25pY2FsU2VhcmNoXG4gIGNvbnN0IG9wdGltaXN0aWNDYW5vbmljYWxVcmwgPSBjcmVhdGVIcmVmRnJvbVVybChvcHRpbWlzdGljVXJsKVxuXG4gIGNvbnN0IG9wdGltaXN0aWNSb3V0ZVRyZWUgPSBjcmVhdGVPcHRpbWlzdGljUm91dGVUcmVlKFxuICAgIHJvdXRlV2l0aE5vU2VhcmNoUGFyYW1zLnRyZWUsXG4gICAgb3B0aW1pc3RpY1JlbmRlcmVkU2VhcmNoXG4gIClcbiAgY29uc3Qgb3B0aW1pc3RpY01ldGFkYXRhVHJlZSA9IGNyZWF0ZU9wdGltaXN0aWNSb3V0ZVRyZWUoXG4gICAgcm91dGVXaXRoTm9TZWFyY2hQYXJhbXMubWV0YWRhdGEsXG4gICAgb3B0aW1pc3RpY1JlbmRlcmVkU2VhcmNoXG4gIClcblxuICAvLyBDbG9uZSB0aGUgYmFzZSByb3V0ZSB0cmVlLCBhbmQgb3ZlcnJpZGUgdGhlIHJlbGV2YW50IGZpZWxkcyB3aXRoIG91clxuICAvLyBvcHRpbWlzdGljIHZhbHVlcy5cbiAgY29uc3Qgb3B0aW1pc3RpY0VudHJ5OiBGdWxmaWxsZWRSb3V0ZUNhY2hlRW50cnkgPSB7XG4gICAgY2Fub25pY2FsVXJsOiBvcHRpbWlzdGljQ2Fub25pY2FsVXJsLFxuXG4gICAgc3RhdHVzOiBFbnRyeVN0YXR1cy5GdWxmaWxsZWQsXG4gICAgLy8gVGhpcyBpc24ndCBjbG9uZWQgYmVjYXVzZSBpdCdzIGluc3RhbmNlLXNwZWNpZmljXG4gICAgYmxvY2tlZFRhc2tzOiBudWxsLFxuICAgIHRyZWU6IG9wdGltaXN0aWNSb3V0ZVRyZWUsXG4gICAgbWV0YWRhdGE6IG9wdGltaXN0aWNNZXRhZGF0YVRyZWUsXG4gICAgY291bGRCZUludGVyY2VwdGVkOiByb3V0ZVdpdGhOb1NlYXJjaFBhcmFtcy5jb3VsZEJlSW50ZXJjZXB0ZWQsXG4gICAgaXNQUFJFbmFibGVkOiByb3V0ZVdpdGhOb1NlYXJjaFBhcmFtcy5pc1BQUkVuYWJsZWQsXG5cbiAgICAvLyBPdmVycmlkZSB0aGUgcmVuZGVyZWQgc2VhcmNoIHdpdGggdGhlIG9wdGltaXN0aWMgdmFsdWUuXG4gICAgcmVuZGVyZWRTZWFyY2g6IG9wdGltaXN0aWNSZW5kZXJlZFNlYXJjaCxcblxuICAgIC8vIE1hcC1yZWxhdGVkIGZpZWxkc1xuICAgIHJlZjogbnVsbCxcbiAgICBzaXplOiAwLFxuICAgIHN0YWxlQXQ6IHJvdXRlV2l0aE5vU2VhcmNoUGFyYW1zLnN0YWxlQXQsXG4gICAgdmVyc2lvbjogcm91dGVXaXRoTm9TZWFyY2hQYXJhbXMudmVyc2lvbixcbiAgfVxuXG4gIC8vIERvIG5vdCBpbnNlcnQgdGhpcyBlbnRyeSBpbnRvIHRoZSBjYWNoZS4gSXQgb25seSBleGlzdHMgc28gd2UgY2FuXG4gIC8vIHBlcmZvcm0gdGhlIGN1cnJlbnQgbmF2aWdhdGlvbi4gSnVzdCByZXR1cm4gaXQgdG8gdGhlIGNhbGxlci5cbiAgcmV0dXJuIG9wdGltaXN0aWNFbnRyeVxufVxuXG5mdW5jdGlvbiBjcmVhdGVPcHRpbWlzdGljUm91dGVUcmVlKFxuICB0cmVlOiBSb3V0ZVRyZWUsXG4gIG5ld1JlbmRlcmVkU2VhcmNoOiBOb3JtYWxpemVkU2VhcmNoXG4pOiBSb3V0ZVRyZWUge1xuICAvLyBDcmVhdGUgYSBuZXcgcm91dGUgdHJlZSB0aGF0IGlkZW50aWNhbCB0byB0aGUgb3JpZ2luYWwgb25lIGV4Y2VwdCBmb3JcbiAgLy8gdGhlIHJlbmRlcmVkIHNlYXJjaCBzdHJpbmcsIHdoaWNoIGlzIGNvbnRhaW5lZCBpbiB0aGUgdmFyeSBwYXRoLlxuXG4gIGxldCBjbG9uZWRTbG90czogUmVjb3JkPHN0cmluZywgUm91dGVUcmVlPiB8IG51bGwgPSBudWxsXG4gIGNvbnN0IG9yaWdpbmFsU2xvdHMgPSB0cmVlLnNsb3RzXG4gIGlmIChvcmlnaW5hbFNsb3RzICE9PSBudWxsKSB7XG4gICAgY2xvbmVkU2xvdHMgPSB7fVxuICAgIGZvciAoY29uc3QgcGFyYWxsZWxSb3V0ZUtleSBpbiBvcmlnaW5hbFNsb3RzKSB7XG4gICAgICBjb25zdCBjaGlsZFRyZWUgPSBvcmlnaW5hbFNsb3RzW3BhcmFsbGVsUm91dGVLZXldXG4gICAgICBjbG9uZWRTbG90c1twYXJhbGxlbFJvdXRlS2V5XSA9IGNyZWF0ZU9wdGltaXN0aWNSb3V0ZVRyZWUoXG4gICAgICAgIGNoaWxkVHJlZSxcbiAgICAgICAgbmV3UmVuZGVyZWRTZWFyY2hcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvLyBXZSBvbmx5IG5lZWQgdG8gY2xvbmUgdGhlIHZhcnkgcGF0aCBpZiB0aGUgcm91dGUgaXMgYSBwYWdlLlxuICBpZiAodHJlZS5pc1BhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWVzdEtleTogdHJlZS5yZXF1ZXN0S2V5LFxuICAgICAgc2VnbWVudDogdHJlZS5zZWdtZW50LFxuICAgICAgdmFyeVBhdGg6IGNsb25lUGFnZVZhcnlQYXRoV2l0aE5ld1NlYXJjaFBhcmFtcyhcbiAgICAgICAgdHJlZS52YXJ5UGF0aCxcbiAgICAgICAgbmV3UmVuZGVyZWRTZWFyY2hcbiAgICAgICksXG4gICAgICBpc1BhZ2U6IHRydWUsXG4gICAgICBzbG90czogY2xvbmVkU2xvdHMsXG4gICAgICBpc1Jvb3RMYXlvdXQ6IHRyZWUuaXNSb290TGF5b3V0LFxuICAgICAgaGFzTG9hZGluZ0JvdW5kYXJ5OiB0cmVlLmhhc0xvYWRpbmdCb3VuZGFyeSxcbiAgICAgIGhhc1J1bnRpbWVQcmVmZXRjaDogdHJlZS5oYXNSdW50aW1lUHJlZmV0Y2gsXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZXF1ZXN0S2V5OiB0cmVlLnJlcXVlc3RLZXksXG4gICAgc2VnbWVudDogdHJlZS5zZWdtZW50LFxuICAgIHZhcnlQYXRoOiB0cmVlLnZhcnlQYXRoLFxuICAgIGlzUGFnZTogZmFsc2UsXG4gICAgc2xvdHM6IGNsb25lZFNsb3RzLFxuICAgIGlzUm9vdExheW91dDogdHJlZS5pc1Jvb3RMYXlvdXQsXG4gICAgaGFzTG9hZGluZ0JvdW5kYXJ5OiB0cmVlLmhhc0xvYWRpbmdCb3VuZGFyeSxcbiAgICBoYXNSdW50aW1lUHJlZmV0Y2g6IHRyZWUuaGFzUnVudGltZVByZWZldGNoLFxuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGVudHJ5IGZvciBhIHNlZ21lbnQgZXhpc3RzIGluIHRoZSBjYWNoZS4gSWYgc28sIGl0IHJldHVybnMgdGhlXG4gKiBlbnRyeSwgSWYgbm90LCBpdCBhZGRzIGFuIGVtcHR5IGVudHJ5IHRvIHRoZSBjYWNoZSBhbmQgcmV0dXJucyBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRPckNyZWF0ZVNlZ21lbnRDYWNoZUVudHJ5KFxuICBub3c6IG51bWJlcixcbiAgZmV0Y2hTdHJhdGVneTogRmV0Y2hTdHJhdGVneSxcbiAgcm91dGU6IEZ1bGZpbGxlZFJvdXRlQ2FjaGVFbnRyeSxcbiAgdHJlZTogUm91dGVUcmVlXG4pOiBTZWdtZW50Q2FjaGVFbnRyeSB7XG4gIGNvbnN0IGV4aXN0aW5nRW50cnkgPSByZWFkU2VnbWVudENhY2hlRW50cnkobm93LCB0cmVlLnZhcnlQYXRoKVxuICBpZiAoZXhpc3RpbmdFbnRyeSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBleGlzdGluZ0VudHJ5XG4gIH1cbiAgLy8gQ3JlYXRlIGEgcGVuZGluZyBlbnRyeSBhbmQgYWRkIGl0IHRvIHRoZSBjYWNoZS5cbiAgY29uc3QgdmFyeVBhdGhGb3JSZXF1ZXN0ID0gZ2V0U2VnbWVudFZhcnlQYXRoRm9yUmVxdWVzdChmZXRjaFN0cmF0ZWd5LCB0cmVlKVxuICBjb25zdCBwZW5kaW5nRW50cnkgPSBjcmVhdGVEZXRhY2hlZFNlZ21lbnRDYWNoZUVudHJ5KHJvdXRlLnN0YWxlQXQpXG4gIGNvbnN0IGlzUmV2YWxpZGF0aW9uID0gZmFsc2VcbiAgc2V0SW5DYWNoZU1hcChcbiAgICBzZWdtZW50Q2FjaGVNYXAsXG4gICAgdmFyeVBhdGhGb3JSZXF1ZXN0LFxuICAgIHBlbmRpbmdFbnRyeSxcbiAgICBpc1JldmFsaWRhdGlvblxuICApXG4gIHJldHVybiBwZW5kaW5nRW50cnlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRPckNyZWF0ZVJldmFsaWRhdGluZ1NlZ21lbnRFbnRyeShcbiAgbm93OiBudW1iZXIsXG4gIGZldGNoU3RyYXRlZ3k6IEZldGNoU3RyYXRlZ3ksXG4gIHJvdXRlOiBGdWxmaWxsZWRSb3V0ZUNhY2hlRW50cnksXG4gIHRyZWU6IFJvdXRlVHJlZVxuKTogU2VnbWVudENhY2hlRW50cnkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHdlJ3ZlIGFscmVhZHkgY29uZmlybWVkIHRoYXQgYSBwYXJ0aWN1bGFyXG4gIC8vIHNlZ21lbnQgaXMgY2FjaGVkLCBidXQgd2Ugd2FudCB0byBwZXJmb3JtIGFub3RoZXIgcmVxdWVzdCBhbnl3YXkgaW4gY2FzZSBpdFxuICAvLyByZXR1cm5zIG1vcmUgY29tcGxldGUgYW5kL29yIGZyZXNoZXIgZGF0YSB0aGFuIHdlIGFscmVhZHkgaGF2ZS4gVGhlIGxvZ2ljXG4gIC8vIGZvciBkZWNpZGluZyB3aGV0aGVyIHRvIHJlcGxhY2UgdGhlIGV4aXN0aW5nIGVudHJ5IGlzIGhhbmRsZWQgZWxzZXdoZXJlO1xuICAvLyB0aGlzIGZ1bmN0aW9uIGp1c3QgaGFuZGxlcyByZXRyaWV2aW5nIGEgY2FjaGUgZW50cnkgdGhhdCB3ZSBjYW4gdXNlIHRvXG4gIC8vIHRyYWNrIHRoZSByZXZhbGlkYXRpb24uXG4gIC8vXG4gIC8vIFRoZSByZWFzb24gcmV2YWxpZGF0aW9ucyBhcmUgc3RvcmVkIGluIHRoZSBjYWNoZSBpcyBiZWNhdXNlIHdlIG5lZWQgdG8gYmVcbiAgLy8gYWJsZSB0byBkZWR1cGUgbXVsdGlwbGUgcmV2YWxpZGF0aW9uIHJlcXVlc3RzLiBUaGUgcmVhc29uIHRoZXkgaGF2ZSB0byBiZVxuICAvLyBoYW5kbGVkIHNwZWNpYWxseSBpcyBiZWNhdXNlIHdlIHNob3VsZG4ndCBvdmVyd3JpdGUgYSBcIm5vcm1hbFwiIGVudHJ5IGlmXG4gIC8vIG9uZSBleGlzdHMgYXQgdGhlIHNhbWUga2V5cGF0aC4gU28sIGZvciBlYWNoIGludGVybmFsIGNhY2hlIGxvY2F0aW9uLCB0aGVyZVxuICAvLyBpcyBhIHNwZWNpYWwgXCJyZXZhbGlkYXRpb25cIiBzbG90IHRoYXQgaXMgdXNlZCBzb2xlbHkgZm9yIHRoaXMgcHVycG9zZS5cbiAgLy9cbiAgLy8gWW91IGNhbiB0aGluayBvZiBpdCBhcyBpZiBhbGwgdGhlIHJldmFsaWRhdGlvbiBlbnRyaWVzIHdlcmUgc3RvcmVkIGluIGFcbiAgLy8gc2VwYXJhdGUgY2FjaGUgbWFwIGZyb20gdGhlIGNhbm9uaWNhbCBlbnRyaWVzLCBhbmQgdGhlbiB0cmFuc2ZlcmVkIHRvIHRoZVxuICAvLyBjYW5vbmljYWwgY2FjaGUgbWFwIG9uY2UgdGhlIHJlcXVlc3QgaXMgY29tcGxldGUg4oCUIHRoaXMgaXNuJ3QgaG93IGl0J3NcbiAgLy8gYWN0dWFsbHkgaW1wbGVtZW50ZWQsIHNpbmNlIGl0J3MgbW9yZSBlZmZpY2llbnQgdG8gc3RvcmUgdGhlbSBpbiB0aGUgc2FtZVxuICAvLyBkYXRhIHN0cnVjdHVyZSBhcyB0aGUgbm9ybWFsIGVudHJpZXMsIGJ1dCB0aGF0J3MgaG93IGl0J3MgbW9kZWxlZFxuICAvLyBjb25jZXB0dWFsbHkuXG5cbiAgLy8gVE9ETzogT25jZSB3ZSBpbXBsZW1lbnQgRmFsbGJhY2sgYmVoYXZpb3IgZm9yIHBhcmFtcywgd2hlcmUgYW4gZW50cnkgaXNcbiAgLy8gcmUta2V5ZWQgYmFzZWQgb24gcmVzcG9uc2UgaW5mb3JtYXRpb24sIHdlJ2xsIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlXG4gIC8vIHBvc3NpYmlsaXR5IHRoYXQgdGhlIGtleXBhdGggb2YgdGhlIHByZXZpb3VzIGVudHJ5IGlzIG1vcmUgZ2VuZXJpYyB0aGFuXG4gIC8vIHRoZSBrZXlwYXRoIG9mIHRoZSByZXZhbGlkYXRpbmcgZW50cnkuIEluIG90aGVyIHdvcmRzLCB0aGUgc2VydmVyIGNvdWxkXG4gIC8vIHJldHVybiBhIGxlc3MgZ2VuZXJpYyBlbnRyeSB1cG9uIHJldmFsaWRhdGlvbi4gRm9yIG5vdywgdGhvdWdoLCB0aGlzIGlzbid0XG4gIC8vIGEgY29uY2VybiBiZWNhdXNlIHRoZSBrZXlwYXRoIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgcHJlZmV0Y2ggc3RyYXRlZ3ksXG4gIC8vIG5vdCBvbiBkYXRhIGNvbnRhaW5lZCBpbiB0aGUgcmVzcG9uc2UuXG4gIGNvbnN0IGV4aXN0aW5nRW50cnkgPSByZWFkUmV2YWxpZGF0aW5nU2VnbWVudENhY2hlRW50cnkobm93LCB0cmVlLnZhcnlQYXRoKVxuICBpZiAoZXhpc3RpbmdFbnRyeSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBleGlzdGluZ0VudHJ5XG4gIH1cbiAgLy8gQ3JlYXRlIGEgcGVuZGluZyBlbnRyeSBhbmQgYWRkIGl0IHRvIHRoZSBjYWNoZS5cbiAgY29uc3QgdmFyeVBhdGhGb3JSZXF1ZXN0ID0gZ2V0U2VnbWVudFZhcnlQYXRoRm9yUmVxdWVzdChmZXRjaFN0cmF0ZWd5LCB0cmVlKVxuICBjb25zdCBwZW5kaW5nRW50cnkgPSBjcmVhdGVEZXRhY2hlZFNlZ21lbnRDYWNoZUVudHJ5KHJvdXRlLnN0YWxlQXQpXG4gIGNvbnN0IGlzUmV2YWxpZGF0aW9uID0gdHJ1ZVxuICBzZXRJbkNhY2hlTWFwKFxuICAgIHNlZ21lbnRDYWNoZU1hcCxcbiAgICB2YXJ5UGF0aEZvclJlcXVlc3QsXG4gICAgcGVuZGluZ0VudHJ5LFxuICAgIGlzUmV2YWxpZGF0aW9uXG4gIClcbiAgcmV0dXJuIHBlbmRpbmdFbnRyeVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb3ZlcndyaXRlUmV2YWxpZGF0aW5nU2VnbWVudENhY2hlRW50cnkoXG4gIGZldGNoU3RyYXRlZ3k6IEZldGNoU3RyYXRlZ3ksXG4gIHJvdXRlOiBGdWxmaWxsZWRSb3V0ZUNhY2hlRW50cnksXG4gIHRyZWU6IFJvdXRlVHJlZVxuKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gd2UndmUgYWxyZWFkeSBkZWNpZGVkIHRvIHJlcGxhY2UgYW4gZXhpc3RpbmdcbiAgLy8gcmV2YWxpZGF0aW9uIGVudHJ5LiBDcmVhdGUgYSBuZXcgZW50cnkgYW5kIHdyaXRlIGl0IGludG8gdGhlIGNhY2hlLFxuICAvLyBvdmVyd3JpdGluZyB0aGUgcHJldmlvdXMgdmFsdWUuXG4gIGNvbnN0IHZhcnlQYXRoRm9yUmVxdWVzdCA9IGdldFNlZ21lbnRWYXJ5UGF0aEZvclJlcXVlc3QoZmV0Y2hTdHJhdGVneSwgdHJlZSlcbiAgY29uc3QgcGVuZGluZ0VudHJ5ID0gY3JlYXRlRGV0YWNoZWRTZWdtZW50Q2FjaGVFbnRyeShyb3V0ZS5zdGFsZUF0KVxuICBjb25zdCBpc1JldmFsaWRhdGlvbiA9IHRydWVcbiAgc2V0SW5DYWNoZU1hcChcbiAgICBzZWdtZW50Q2FjaGVNYXAsXG4gICAgdmFyeVBhdGhGb3JSZXF1ZXN0LFxuICAgIHBlbmRpbmdFbnRyeSxcbiAgICBpc1JldmFsaWRhdGlvblxuICApXG4gIHJldHVybiBwZW5kaW5nRW50cnlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwc2VydFNlZ21lbnRFbnRyeShcbiAgbm93OiBudW1iZXIsXG4gIHZhcnlQYXRoOiBTZWdtZW50VmFyeVBhdGgsXG4gIGNhbmRpZGF0ZUVudHJ5OiBTZWdtZW50Q2FjaGVFbnRyeVxuKTogU2VnbWVudENhY2hlRW50cnkgfCBudWxsIHtcbiAgLy8gV2UgaGF2ZSBhIG5ldyBlbnRyeSB0aGF0IGhhcyBub3QgeWV0IGJlZW4gaW5zZXJ0ZWQgaW50byB0aGUgY2FjaGUuIEJlZm9yZVxuICAvLyB3ZSBkbyBzbywgd2UgbmVlZCB0byBjb25maXJtIHdoZXRoZXIgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoZSBleGlzdGluZ1xuICAvLyBlbnRyeSAoaWYgb25lIGV4aXN0cykuXG4gIC8vIFRPRE86IFdlIHNob3VsZCBub3QgdXBzZXJ0IGFuIGVudHJ5IGlmIGl0cyBrZXkgd2FzIGludmFsaWRhdGVkIGluIHRoZSB0aW1lXG4gIC8vIHNpbmNlIHRoZSByZXF1ZXN0IHdhcyBtYWRlLiBXZSBjYW4gZG8gdGhhdCBieSBwYXNzaW5nIHRoZSBcIm93bmVyXCIgZW50cnkgdG9cbiAgLy8gdGhpcyBmdW5jdGlvbiBhbmQgY29uZmlybWluZyBpdCdzIHRoZSBzYW1lIGFzIGBleGlzdGluZ0VudHJ5YC5cblxuICBpZiAoaXNWYWx1ZUV4cGlyZWQobm93LCBnZXRDdXJyZW50Q2FjaGVWZXJzaW9uKCksIGNhbmRpZGF0ZUVudHJ5KSkge1xuICAgIC8vIFRoZSBlbnRyeSBpcyBleHBpcmVkLiBXZSBjYW5ub3QgdXBzZXJ0IGl0LlxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBleGlzdGluZ0VudHJ5ID0gcmVhZFNlZ21lbnRDYWNoZUVudHJ5KG5vdywgdmFyeVBhdGgpXG4gIGlmIChleGlzdGluZ0VudHJ5ICE9PSBudWxsKSB7XG4gICAgLy8gRG9uJ3QgcmVwbGFjZSBhIG1vcmUgc3BlY2lmaWMgc2VnbWVudCB3aXRoIGEgbGVzcy1zcGVjaWZpYyBvbmUuIEEgY2FzZSB3aGVyZSB0aGlzXG4gICAgLy8gbWlnaHQgaGFwcGVuIGlzIGlmIHRoZSBleGlzdGluZyBzZWdtZW50IHdhcyBmZXRjaGVkIHZpYVxuICAgIC8vIGA8TGluayBwcmVmZXRjaD17dHJ1ZX0+YC5cbiAgICBpZiAoXG4gICAgICAvLyBXZSBmZXRjaGVkIHRoZSBuZXcgc2VnbWVudCB1c2luZyBhIGRpZmZlcmVudCwgbGVzcyBzcGVjaWZpYyBmZXRjaCBzdHJhdGVneVxuICAgICAgLy8gdGhhbiB0aGUgc2VnbWVudCB3ZSBhbHJlYWR5IGhhdmUgaW4gdGhlIGNhY2hlLCBzbyBpdCBjYW4ndCBoYXZlIG1vcmUgY29udGVudC5cbiAgICAgIChjYW5kaWRhdGVFbnRyeS5mZXRjaFN0cmF0ZWd5ICE9PSBleGlzdGluZ0VudHJ5LmZldGNoU3RyYXRlZ3kgJiZcbiAgICAgICAgIWNhbk5ld0ZldGNoU3RyYXRlZ3lQcm92aWRlTW9yZUNvbnRlbnQoXG4gICAgICAgICAgZXhpc3RpbmdFbnRyeS5mZXRjaFN0cmF0ZWd5LFxuICAgICAgICAgIGNhbmRpZGF0ZUVudHJ5LmZldGNoU3RyYXRlZ3lcbiAgICAgICAgKSkgfHxcbiAgICAgIC8vIFRoZSBleGlzdGluZyBlbnRyeSBpc24ndCBwYXJ0aWFsLCBidXQgdGhlIG5ldyBvbmUgaXMuXG4gICAgICAvLyAoVE9ETzogY2FuIHRoaXMgYmUgdHJ1ZSBpZiBgY2FuZGlkYXRlRW50cnkuZmV0Y2hTdHJhdGVneSA+PSBleGlzdGluZ0VudHJ5LmZldGNoU3RyYXRlZ3lgPylcbiAgICAgICghZXhpc3RpbmdFbnRyeS5pc1BhcnRpYWwgJiYgY2FuZGlkYXRlRW50cnkuaXNQYXJ0aWFsKVxuICAgICkge1xuICAgICAgLy8gV2UncmUgZ29pbmcgdG8gbGVhdmUgcmV2YWxpZGF0aW5nIGVudHJ5IGluIHRoZSBjYWNoZSBzbyB0aGF0IGl0IGRvZXNuJ3RcbiAgICAgIC8vIGdldCByZXZhbGlkYXRlZCBhZ2FpbiB1bm5lY2Vzc2FyaWx5LiBEb3duZ3JhZGUgdGhlIEZ1bGZpbGxlZCBlbnRyeSB0b1xuICAgICAgLy8gUmVqZWN0ZWQgYW5kIG51bGwgb3V0IHRoZSBkYXRhIHNvIGl0IGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC4gV2UgbGVhdmVcbiAgICAgIC8vIGBzdGFsZUF0YCBpbnRhY3QgdG8gcHJldmVudCBzdWJzZXF1ZW50IHJldmFsaWRhdGlvbiBhdHRlbXB0cyBvbmx5IHVudGlsXG4gICAgICAvLyB0aGUgZW50cnkgZXhwaXJlcy5cbiAgICAgIGNvbnN0IHJlamVjdGVkRW50cnk6IFJlamVjdGVkU2VnbWVudENhY2hlRW50cnkgPSBjYW5kaWRhdGVFbnRyeSBhcyBhbnlcbiAgICAgIHJlamVjdGVkRW50cnkuc3RhdHVzID0gRW50cnlTdGF0dXMuUmVqZWN0ZWRcbiAgICAgIHJlamVjdGVkRW50cnkubG9hZGluZyA9IG51bGxcbiAgICAgIHJlamVjdGVkRW50cnkucnNjID0gbnVsbFxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyBFdmljdCB0aGUgZXhpc3RpbmcgZW50cnkgZnJvbSB0aGUgY2FjaGUuXG4gICAgZGVsZXRlRnJvbUNhY2hlTWFwKGV4aXN0aW5nRW50cnkpXG4gIH1cblxuICBjb25zdCBpc1JldmFsaWRhdGlvbiA9IGZhbHNlXG4gIHNldEluQ2FjaGVNYXAoc2VnbWVudENhY2hlTWFwLCB2YXJ5UGF0aCwgY2FuZGlkYXRlRW50cnksIGlzUmV2YWxpZGF0aW9uKVxuICByZXR1cm4gY2FuZGlkYXRlRW50cnlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURldGFjaGVkU2VnbWVudENhY2hlRW50cnkoXG4gIHN0YWxlQXQ6IG51bWJlclxuKTogRW1wdHlTZWdtZW50Q2FjaGVFbnRyeSB7XG4gIGNvbnN0IGVtcHR5RW50cnk6IEVtcHR5U2VnbWVudENhY2hlRW50cnkgPSB7XG4gICAgc3RhdHVzOiBFbnRyeVN0YXR1cy5FbXB0eSxcbiAgICAvLyBEZWZhdWx0IHRvIGFzc3VtaW5nIHRoZSBmZXRjaCBzdHJhdGVneSB3aWxsIGJlIFBQUi4gVGhpcyB3aWxsIGJlIHVwZGF0ZWRcbiAgICAvLyB3aGVuIGEgZmV0Y2ggaXMgYWN0dWFsbHkgaW5pdGlhdGVkLlxuICAgIGZldGNoU3RyYXRlZ3k6IEZldGNoU3RyYXRlZ3kuUFBSLFxuICAgIHJzYzogbnVsbCxcbiAgICBsb2FkaW5nOiBudWxsLFxuICAgIGlzUGFydGlhbDogdHJ1ZSxcbiAgICBwcm9taXNlOiBudWxsLFxuXG4gICAgLy8gTWFwLXJlbGF0ZWQgZmllbGRzXG4gICAgcmVmOiBudWxsLFxuICAgIHNpemU6IDAsXG4gICAgc3RhbGVBdCxcbiAgICB2ZXJzaW9uOiAwLFxuICB9XG4gIHJldHVybiBlbXB0eUVudHJ5XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGdyYWRlVG9QZW5kaW5nU2VnbWVudChcbiAgZW1wdHlFbnRyeTogRW1wdHlTZWdtZW50Q2FjaGVFbnRyeSxcbiAgZmV0Y2hTdHJhdGVneTogRmV0Y2hTdHJhdGVneVxuKTogUGVuZGluZ1NlZ21lbnRDYWNoZUVudHJ5IHtcbiAgY29uc3QgcGVuZGluZ0VudHJ5OiBQZW5kaW5nU2VnbWVudENhY2hlRW50cnkgPSBlbXB0eUVudHJ5IGFzIGFueVxuICBwZW5kaW5nRW50cnkuc3RhdHVzID0gRW50cnlTdGF0dXMuUGVuZGluZ1xuICBwZW5kaW5nRW50cnkuZmV0Y2hTdHJhdGVneSA9IGZldGNoU3RyYXRlZ3lcblxuICBpZiAoZmV0Y2hTdHJhdGVneSA9PT0gRmV0Y2hTdHJhdGVneS5GdWxsKSB7XG4gICAgLy8gV2UgY2FuIGFzc3VtZSB0aGUgcmVzcG9uc2Ugd2lsbCBjb250YWluIHRoZSBmdWxsIHNlZ21lbnQgZGF0YS4gU2V0IHRoaXNcbiAgICAvLyB0byBmYWxzZSBzbyB3ZSBrbm93IGl0J3MgT0sgdG8gb21pdCB0aGlzIHNlZ21lbnQgZnJvbSBhbnkgbmF2aWdhdGlvblxuICAgIC8vIHJlcXVlc3RzIHRoYXQgbWF5IGhhcHBlbiB3aGlsZSB0aGUgZGF0YSBpcyBzdGlsbCBwZW5kaW5nLlxuICAgIHBlbmRpbmdFbnRyeS5pc1BhcnRpYWwgPSBmYWxzZVxuICB9XG5cbiAgLy8gU2V0IHRoZSB2ZXJzaW9uIGhlcmUsIHNpbmNlIHRoaXMgaXMgcmlnaHQgYmVmb3JlIHRoZSByZXF1ZXN0IGlzIGluaXRpYXRlZC5cbiAgLy8gVGhlIG5leHQgdGltZSB0aGUgZ2xvYmFsIGNhY2hlIHZlcnNpb24gaXMgaW5jcmVtZW50ZWQsIHRoZSBlbnRyeSB3aWxsXG4gIC8vIGVmZmVjdGl2ZWx5IGJlIGV2aWN0ZWQuIFRoaXMgaGFwcGVucyBiZWZvcmUgaW5pdGlhdGluZyB0aGUgcmVxdWVzdCwgcmF0aGVyXG4gIC8vIHRoYW4gd2hlbiByZWNlaXZpbmcgdGhlIHJlc3BvbnNlLCBiZWNhdXNlIGl0J3MgZ3VhcmFudGVlZCB0byBoYXBwZW5cbiAgLy8gYmVmb3JlIHRoZSBkYXRhIGlzIHJlYWQgb24gdGhlIHNlcnZlci5cbiAgcGVuZGluZ0VudHJ5LnZlcnNpb24gPSBnZXRDdXJyZW50Q2FjaGVWZXJzaW9uKClcbiAgcmV0dXJuIHBlbmRpbmdFbnRyeVxufVxuXG5mdW5jdGlvbiBwaW5nQmxvY2tlZFRhc2tzKGVudHJ5OiB7XG4gIGJsb2NrZWRUYXNrczogU2V0PFByZWZldGNoVGFzaz4gfCBudWxsXG59KTogdm9pZCB7XG4gIGNvbnN0IGJsb2NrZWRUYXNrcyA9IGVudHJ5LmJsb2NrZWRUYXNrc1xuICBpZiAoYmxvY2tlZFRhc2tzICE9PSBudWxsKSB7XG4gICAgZm9yIChjb25zdCB0YXNrIG9mIGJsb2NrZWRUYXNrcykge1xuICAgICAgcGluZ1ByZWZldGNoVGFzayh0YXNrKVxuICAgIH1cbiAgICBlbnRyeS5ibG9ja2VkVGFza3MgPSBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gZnVsZmlsbFJvdXRlQ2FjaGVFbnRyeShcbiAgZW50cnk6IFJvdXRlQ2FjaGVFbnRyeSxcbiAgdHJlZTogUm91dGVUcmVlLFxuICBtZXRhZGF0YVZhcnlQYXRoOiBQYWdlVmFyeVBhdGgsXG4gIHN0YWxlQXQ6IG51bWJlcixcbiAgY291bGRCZUludGVyY2VwdGVkOiBib29sZWFuLFxuICBjYW5vbmljYWxVcmw6IHN0cmluZyxcbiAgcmVuZGVyZWRTZWFyY2g6IE5vcm1hbGl6ZWRTZWFyY2gsXG4gIGlzUFBSRW5hYmxlZDogYm9vbGVhblxuKTogRnVsZmlsbGVkUm91dGVDYWNoZUVudHJ5IHtcbiAgLy8gVGhlIEhlYWQgaXMgbm90IGFjdHVhbGx5IHBhcnQgb2YgdGhlIHJvdXRlIHRyZWUsIGJ1dCBvdGhlciB0aGFuIHRoYXQsIGl0J3NcbiAgLy8gZmV0Y2hlZCBhbmQgY2FjaGVkIGxpa2UgYSBzZWdtZW50LiBTb21lIGZ1bmN0aW9ucyBleHBlY3QgYSBSb3V0ZVRyZWVcbiAgLy8gb2JqZWN0LCBzbyByYXRoZXIgdGhhbiBmb3JrIHRoZSBsb2dpYyBpbiBhbGwgdGhvc2UgcGxhY2VzLCB3ZSB1c2UgdGhpc1xuICAvLyBcImZha2VcIiBvbmUuXG4gIGNvbnN0IG1ldGFkYXRhOiBSb3V0ZVRyZWUgPSB7XG4gICAgcmVxdWVzdEtleTogSEVBRF9SRVFVRVNUX0tFWSxcbiAgICBzZWdtZW50OiBIRUFEX1JFUVVFU1RfS0VZLFxuICAgIHZhcnlQYXRoOiBtZXRhZGF0YVZhcnlQYXRoLFxuICAgIC8vIFRoZSBtZXRhZGF0YSBpc24ndCByZWFsbHkgYSBcInBhZ2VcIiAodGhvdWdoIGl0IGlzbid0IHJlYWxseSBhIFwic2VnbWVudFwiXG4gICAgLy8gZWl0aGVyKSBidXQgZm9yIHRoZSBwdXJwb3NlcyBvZiBob3cgdGhpcyBmaWVsZCBpcyB1c2VkLCBpdCBiZWhhdmVzIGxpa2VcbiAgICAvLyBvbmUuIElmIHRoaXMgbG9naWMgZXZlciBnZXRzIG1vcmUgY29tcGxleCB3ZSBjYW4gY2hhbmdlIHRoaXMgdG8gYW4gZW51bS5cbiAgICBpc1BhZ2U6IHRydWUsXG4gICAgc2xvdHM6IG51bGwsXG4gICAgaXNSb290TGF5b3V0OiBmYWxzZSxcbiAgICBoYXNMb2FkaW5nQm91bmRhcnk6IEhhc0xvYWRpbmdCb3VuZGFyeS5TdWJ0cmVlSGFzTm9Mb2FkaW5nQm91bmRhcnksXG4gICAgaGFzUnVudGltZVByZWZldGNoOiBmYWxzZSxcbiAgfVxuICBjb25zdCBmdWxmaWxsZWRFbnRyeTogRnVsZmlsbGVkUm91dGVDYWNoZUVudHJ5ID0gZW50cnkgYXMgYW55XG4gIGZ1bGZpbGxlZEVudHJ5LnN0YXR1cyA9IEVudHJ5U3RhdHVzLkZ1bGZpbGxlZFxuICBmdWxmaWxsZWRFbnRyeS50cmVlID0gdHJlZVxuICBmdWxmaWxsZWRFbnRyeS5tZXRhZGF0YSA9IG1ldGFkYXRhXG4gIGZ1bGZpbGxlZEVudHJ5LnN0YWxlQXQgPSBzdGFsZUF0XG4gIGZ1bGZpbGxlZEVudHJ5LmNvdWxkQmVJbnRlcmNlcHRlZCA9IGNvdWxkQmVJbnRlcmNlcHRlZFxuICBmdWxmaWxsZWRFbnRyeS5jYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxcbiAgZnVsZmlsbGVkRW50cnkucmVuZGVyZWRTZWFyY2ggPSByZW5kZXJlZFNlYXJjaFxuICBmdWxmaWxsZWRFbnRyeS5pc1BQUkVuYWJsZWQgPSBpc1BQUkVuYWJsZWRcbiAgcGluZ0Jsb2NrZWRUYXNrcyhlbnRyeSlcbiAgcmV0dXJuIGZ1bGZpbGxlZEVudHJ5XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGxTZWdtZW50Q2FjaGVFbnRyeShcbiAgc2VnbWVudENhY2hlRW50cnk6IFBlbmRpbmdTZWdtZW50Q2FjaGVFbnRyeSxcbiAgcnNjOiBSZWFjdC5SZWFjdE5vZGUsXG4gIGxvYWRpbmc6IExvYWRpbmdNb2R1bGVEYXRhIHwgUHJvbWlzZTxMb2FkaW5nTW9kdWxlRGF0YT4sXG4gIHN0YWxlQXQ6IG51bWJlcixcbiAgaXNQYXJ0aWFsOiBib29sZWFuXG4pOiBGdWxmaWxsZWRTZWdtZW50Q2FjaGVFbnRyeSB7XG4gIGNvbnN0IGZ1bGZpbGxlZEVudHJ5OiBGdWxmaWxsZWRTZWdtZW50Q2FjaGVFbnRyeSA9IHNlZ21lbnRDYWNoZUVudHJ5IGFzIGFueVxuICBmdWxmaWxsZWRFbnRyeS5zdGF0dXMgPSBFbnRyeVN0YXR1cy5GdWxmaWxsZWRcbiAgZnVsZmlsbGVkRW50cnkucnNjID0gcnNjXG4gIGZ1bGZpbGxlZEVudHJ5LmxvYWRpbmcgPSBsb2FkaW5nXG4gIGZ1bGZpbGxlZEVudHJ5LnN0YWxlQXQgPSBzdGFsZUF0XG4gIGZ1bGZpbGxlZEVudHJ5LmlzUGFydGlhbCA9IGlzUGFydGlhbFxuICAvLyBSZXNvbHZlIGFueSBsaXN0ZW5lcnMgdGhhdCB3ZXJlIHdhaXRpbmcgZm9yIHRoaXMgZGF0YS5cbiAgaWYgKHNlZ21lbnRDYWNoZUVudHJ5LnByb21pc2UgIT09IG51bGwpIHtcbiAgICBzZWdtZW50Q2FjaGVFbnRyeS5wcm9taXNlLnJlc29sdmUoZnVsZmlsbGVkRW50cnkpXG4gICAgLy8gRnJlZSB0aGUgcHJvbWlzZSBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgIGZ1bGZpbGxlZEVudHJ5LnByb21pc2UgPSBudWxsXG4gIH1cbiAgcmV0dXJuIGZ1bGZpbGxlZEVudHJ5XG59XG5cbmZ1bmN0aW9uIHJlamVjdFJvdXRlQ2FjaGVFbnRyeShcbiAgZW50cnk6IFBlbmRpbmdSb3V0ZUNhY2hlRW50cnksXG4gIHN0YWxlQXQ6IG51bWJlclxuKTogdm9pZCB7XG4gIGNvbnN0IHJlamVjdGVkRW50cnk6IFJlamVjdGVkUm91dGVDYWNoZUVudHJ5ID0gZW50cnkgYXMgYW55XG4gIHJlamVjdGVkRW50cnkuc3RhdHVzID0gRW50cnlTdGF0dXMuUmVqZWN0ZWRcbiAgcmVqZWN0ZWRFbnRyeS5zdGFsZUF0ID0gc3RhbGVBdFxuICBwaW5nQmxvY2tlZFRhc2tzKGVudHJ5KVxufVxuXG5mdW5jdGlvbiByZWplY3RTZWdtZW50Q2FjaGVFbnRyeShcbiAgZW50cnk6IFBlbmRpbmdTZWdtZW50Q2FjaGVFbnRyeSxcbiAgc3RhbGVBdDogbnVtYmVyXG4pOiB2b2lkIHtcbiAgY29uc3QgcmVqZWN0ZWRFbnRyeTogUmVqZWN0ZWRTZWdtZW50Q2FjaGVFbnRyeSA9IGVudHJ5IGFzIGFueVxuICByZWplY3RlZEVudHJ5LnN0YXR1cyA9IEVudHJ5U3RhdHVzLlJlamVjdGVkXG4gIHJlamVjdGVkRW50cnkuc3RhbGVBdCA9IHN0YWxlQXRcbiAgaWYgKGVudHJ5LnByb21pc2UgIT09IG51bGwpIHtcbiAgICAvLyBOT1RFOiBXZSBkb24ndCBjdXJyZW50bHkgcHJvcGFnYXRlIHRoZSByZWFzb24gdGhlIHByZWZldGNoIHdhcyBjYW5jZWxlZFxuICAgIC8vIGJ1dCB3ZSBjb3VsZCBieSBhY2NlcHRpbmcgYSBgcmVhc29uYCBhcmd1bWVudC5cbiAgICBlbnRyeS5wcm9taXNlLnJlc29sdmUobnVsbClcbiAgICBlbnRyeS5wcm9taXNlID0gbnVsbFxuICB9XG59XG5cbnR5cGUgUm91dGVUcmVlQWNjdW11bGF0b3IgPSB7XG4gIG1ldGFkYXRhVmFyeVBhdGg6IFBhZ2VWYXJ5UGF0aCB8IG51bGxcbn1cblxuZnVuY3Rpb24gY29udmVydFJvb3RUcmVlUHJlZmV0Y2hUb1JvdXRlVHJlZShcbiAgcm9vdFRyZWU6IFJvb3RUcmVlUHJlZmV0Y2gsXG4gIHJlbmRlcmVkUGF0aG5hbWU6IHN0cmluZyxcbiAgcmVuZGVyZWRTZWFyY2g6IE5vcm1hbGl6ZWRTZWFyY2gsXG4gIGFjYzogUm91dGVUcmVlQWNjdW11bGF0b3Jcbikge1xuICAvLyBSZW1vdmUgdHJhaWxpbmcgYW5kIGxlYWRpbmcgc2xhc2hlc1xuICBjb25zdCBwYXRobmFtZVBhcnRzID0gcmVuZGVyZWRQYXRobmFtZS5zcGxpdCgnLycpLmZpbHRlcigocCkgPT4gcCAhPT0gJycpXG4gIGNvbnN0IGluZGV4ID0gMFxuICBjb25zdCByb290U2VnbWVudCA9IFJPT1RfU0VHTUVOVF9SRVFVRVNUX0tFWVxuICByZXR1cm4gY29udmVydFRyZWVQcmVmZXRjaFRvUm91dGVUcmVlKFxuICAgIHJvb3RUcmVlLnRyZWUsXG4gICAgcm9vdFNlZ21lbnQsXG4gICAgbnVsbCxcbiAgICBST09UX1NFR01FTlRfUkVRVUVTVF9LRVksXG4gICAgcGF0aG5hbWVQYXJ0cyxcbiAgICBpbmRleCxcbiAgICByZW5kZXJlZFNlYXJjaCxcbiAgICBhY2NcbiAgKVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0VHJlZVByZWZldGNoVG9Sb3V0ZVRyZWUoXG4gIHByZWZldGNoOiBUcmVlUHJlZmV0Y2gsXG4gIHNlZ21lbnQ6IEZsaWdodFJvdXRlclN0YXRlU2VnbWVudCxcbiAgcGFydGlhbFZhcnlQYXRoOiBQYXJ0aWFsU2VnbWVudFZhcnlQYXRoIHwgbnVsbCxcbiAgcmVxdWVzdEtleTogU2VnbWVudFJlcXVlc3RLZXksXG4gIHBhdGhuYW1lUGFydHM6IEFycmF5PHN0cmluZz4sXG4gIHBhdGhuYW1lUGFydHNJbmRleDogbnVtYmVyLFxuICByZW5kZXJlZFNlYXJjaDogTm9ybWFsaXplZFNlYXJjaCxcbiAgYWNjOiBSb3V0ZVRyZWVBY2N1bXVsYXRvclxuKTogUm91dGVUcmVlIHtcbiAgLy8gQ29udmVydHMgdGhlIHJvdXRlIHRyZWUgc2VudCBieSB0aGUgc2VydmVyIGludG8gdGhlIGZvcm1hdCB1c2VkIGJ5IHRoZVxuICAvLyBjYWNoZS4gVGhlIGNhY2hlZCB2ZXJzaW9uIG9mIHRoZSB0cmVlIGluY2x1ZGVzIGFkZGl0aW9uYWwgZmllbGRzLCBzdWNoIGFzIGFcbiAgLy8gY2FjaGUga2V5IGZvciBlYWNoIHNlZ21lbnQuIFNpbmNlIHRoaXMgaXMgZnJlcXVlbnRseSBhY2Nlc3NlZCwgd2UgY29tcHV0ZVxuICAvLyBpdCBvbmNlIGluc3RlYWQgb2Ygb24gZXZlcnkgYWNjZXNzLiBUaGlzIHNhbWUgY2FjaGUga2V5IGlzIGFsc28gdXNlZCB0b1xuICAvLyByZXF1ZXN0IHRoZSBzZWdtZW50IGZyb20gdGhlIHNlcnZlci5cblxuICBsZXQgc2xvdHM6IHsgW3BhcmFsbGVsUm91dGVLZXk6IHN0cmluZ106IFJvdXRlVHJlZSB9IHwgbnVsbCA9IG51bGxcbiAgbGV0IGlzUGFnZTogYm9vbGVhblxuICBsZXQgdmFyeVBhdGg6IFNlZ21lbnRWYXJ5UGF0aFxuICBjb25zdCBwcmVmZXRjaFNsb3RzID0gcHJlZmV0Y2guc2xvdHNcbiAgaWYgKHByZWZldGNoU2xvdHMgIT09IG51bGwpIHtcbiAgICBpc1BhZ2UgPSBmYWxzZVxuICAgIHZhcnlQYXRoID0gZmluYWxpemVMYXlvdXRWYXJ5UGF0aChyZXF1ZXN0S2V5LCBwYXJ0aWFsVmFyeVBhdGgpXG5cbiAgICBzbG90cyA9IHt9XG4gICAgZm9yIChsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiBwcmVmZXRjaFNsb3RzKSB7XG4gICAgICBjb25zdCBjaGlsZFByZWZldGNoID0gcHJlZmV0Y2hTbG90c1twYXJhbGxlbFJvdXRlS2V5XVxuICAgICAgY29uc3QgY2hpbGRQYXJhbU5hbWUgPSBjaGlsZFByZWZldGNoLm5hbWVcbiAgICAgIGNvbnN0IGNoaWxkUGFyYW1UeXBlID0gY2hpbGRQcmVmZXRjaC5wYXJhbVR5cGVcbiAgICAgIGNvbnN0IGNoaWxkU2VydmVyU2VudFBhcmFtS2V5ID0gY2hpbGRQcmVmZXRjaC5wYXJhbUtleVxuXG4gICAgICBsZXQgY2hpbGREb2VzQXBwZWFySW5VUkw6IGJvb2xlYW5cbiAgICAgIGxldCBjaGlsZFNlZ21lbnQ6IEZsaWdodFJvdXRlclN0YXRlU2VnbWVudFxuICAgICAgbGV0IGNoaWxkUGFydGlhbFZhcnlQYXRoOiBQYXJ0aWFsU2VnbWVudFZhcnlQYXRoIHwgbnVsbFxuICAgICAgaWYgKGNoaWxkUGFyYW1UeXBlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgc2VnbWVudCBpcyBwYXJhbWV0ZXJpemVkLiBHZXQgdGhlIHBhcmFtIGZyb20gdGhlIHBhdGhuYW1lLlxuICAgICAgICBjb25zdCBjaGlsZFBhcmFtVmFsdWUgPSBwYXJzZUR5bmFtaWNQYXJhbUZyb21VUkxQYXJ0KFxuICAgICAgICAgIGNoaWxkUGFyYW1UeXBlLFxuICAgICAgICAgIHBhdGhuYW1lUGFydHMsXG4gICAgICAgICAgcGF0aG5hbWVQYXJ0c0luZGV4XG4gICAgICAgIClcblxuICAgICAgICAvLyBBc3NpZ24gYSBjYWNoZSBrZXkgdG8gdGhlIHNlZ21lbnQsIGJhc2VkIG9uIHRoZSBwYXJhbSB2YWx1ZS4gSW4gdGhlXG4gICAgICAgIC8vIHByZS1TZWdtZW50IENhY2hlIGltcGxlbWVudGF0aW9uLCB0aGUgc2VydmVyIGNvbXB1dGVzIHRoaXMgYW5kIHNlbmRzXG4gICAgICAgIC8vIGl0IGluIHRoZSBib2R5IG9mIHRoZSByZXNwb25zZS4gSW4gdGhlIFNlZ21lbnQgQ2FjaGUgaW1wbGVtZW50YXRpb24sXG4gICAgICAgIC8vIHRoZSBzZXJ2ZXIgc2VuZHMgYW4gZW1wdHkgc3RyaW5nIGFuZCB3ZSBmaWxsIGl0IGluIGhlcmUuXG5cbiAgICAgICAgLy8gVE9ETzogV2UncmUgaW50ZW50aW9uYWxseSBub3QgYWRkaW5nIHRoZSBzZWFyY2ggcGFyYW0gdG8gcGFnZVxuICAgICAgICAvLyBzZWdtZW50cyBoZXJlOyBpdCdzIHRyYWNrZWQgc2VwYXJhdGVseSBhbmQgYWRkZWQgYmFjayBkdXJpbmcgYSByZWFkLlxuICAgICAgICAvLyBUaGlzIHdvdWxkIGNsZWFyZXIgaWYgd2Ugd2FpdGVkIHRvIGNvbnN0cnVjdCB0aGUgc2VnbWVudCB1bnRpbCBpdCdzXG4gICAgICAgIC8vIHJlYWQgZnJvbSB0aGUgY2FjaGUsIHNpbmNlIHRoYXQncyBlZmZlY3RpdmVseSB3aGF0IHdlJ3JlXG4gICAgICAgIC8vIGRvaW5nIGFueXdheS5cbiAgICAgICAgY29uc3QgY2hpbGRQYXJhbUtleSA9XG4gICAgICAgICAgLy8gVGhlIHNlcnZlciBvbWl0cyB0aGlzIGZpZWxkIGZyb20gdGhlIHByZWZldGNoIHJlc3BvbnNlIHdoZW5cbiAgICAgICAgICAvLyBjYWNoZUNvbXBvbmVudHMgaXMgZW5hYmxlZC5cbiAgICAgICAgICBjaGlsZFNlcnZlclNlbnRQYXJhbUtleSAhPT0gbnVsbFxuICAgICAgICAgICAgPyBjaGlsZFNlcnZlclNlbnRQYXJhbUtleVxuICAgICAgICAgICAgOiAvLyBJZiBubyBwYXJhbSBrZXkgd2FzIHNlbnQsIHVzZSB0aGUgdmFsdWUgcGFyc2VkIG9uIHRoZSBjbGllbnQuXG4gICAgICAgICAgICAgIGdldENhY2hlS2V5Rm9yRHluYW1pY1BhcmFtKFxuICAgICAgICAgICAgICAgIGNoaWxkUGFyYW1WYWx1ZSxcbiAgICAgICAgICAgICAgICAnJyBhcyBOb3JtYWxpemVkU2VhcmNoXG4gICAgICAgICAgICAgIClcblxuICAgICAgICBjaGlsZFBhcnRpYWxWYXJ5UGF0aCA9IGFwcGVuZExheW91dFZhcnlQYXRoKFxuICAgICAgICAgIHBhcnRpYWxWYXJ5UGF0aCxcbiAgICAgICAgICBjaGlsZFBhcmFtS2V5XG4gICAgICAgIClcbiAgICAgICAgY2hpbGRTZWdtZW50ID0gW2NoaWxkUGFyYW1OYW1lLCBjaGlsZFBhcmFtS2V5LCBjaGlsZFBhcmFtVHlwZV1cbiAgICAgICAgY2hpbGREb2VzQXBwZWFySW5VUkwgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHNlZ21lbnQgZG9lcyBub3QgaGF2ZSBhIHBhcmFtLiBJbmhlcml0IHRoZSBwYXJ0aWFsIHZhcnkgcGF0aCBvZlxuICAgICAgICAvLyB0aGUgcGFyZW50LlxuICAgICAgICBjaGlsZFBhcnRpYWxWYXJ5UGF0aCA9IHBhcnRpYWxWYXJ5UGF0aFxuICAgICAgICBjaGlsZFNlZ21lbnQgPSBjaGlsZFBhcmFtTmFtZVxuICAgICAgICBjaGlsZERvZXNBcHBlYXJJblVSTCA9IGRvZXNTdGF0aWNTZWdtZW50QXBwZWFySW5VUkwoY2hpbGRQYXJhbU5hbWUpXG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgaW5jcmVtZW50IHRoZSBpbmRleCBpZiB0aGUgc2VnbWVudCBhcHBlYXJzIGluIHRoZSBVUkwuIElmIGl0J3MgYVxuICAgICAgLy8gXCJ2aXJ0dWFsXCIgc2VnbWVudCwgbGlrZSBhIHJvdXRlIGdyb3VwLCBpdCByZW1haW5zIHRoZSBzYW1lLlxuICAgICAgY29uc3QgY2hpbGRQYXRobmFtZVBhcnRzSW5kZXggPSBjaGlsZERvZXNBcHBlYXJJblVSTFxuICAgICAgICA/IHBhdGhuYW1lUGFydHNJbmRleCArIDFcbiAgICAgICAgOiBwYXRobmFtZVBhcnRzSW5kZXhcblxuICAgICAgY29uc3QgY2hpbGRSZXF1ZXN0S2V5UGFydCA9IGNyZWF0ZVNlZ21lbnRSZXF1ZXN0S2V5UGFydChjaGlsZFNlZ21lbnQpXG4gICAgICBjb25zdCBjaGlsZFJlcXVlc3RLZXkgPSBhcHBlbmRTZWdtZW50UmVxdWVzdEtleVBhcnQoXG4gICAgICAgIHJlcXVlc3RLZXksXG4gICAgICAgIHBhcmFsbGVsUm91dGVLZXksXG4gICAgICAgIGNoaWxkUmVxdWVzdEtleVBhcnRcbiAgICAgIClcbiAgICAgIHNsb3RzW3BhcmFsbGVsUm91dGVLZXldID0gY29udmVydFRyZWVQcmVmZXRjaFRvUm91dGVUcmVlKFxuICAgICAgICBjaGlsZFByZWZldGNoLFxuICAgICAgICBjaGlsZFNlZ21lbnQsXG4gICAgICAgIGNoaWxkUGFydGlhbFZhcnlQYXRoLFxuICAgICAgICBjaGlsZFJlcXVlc3RLZXksXG4gICAgICAgIHBhdGhuYW1lUGFydHMsXG4gICAgICAgIGNoaWxkUGF0aG5hbWVQYXJ0c0luZGV4LFxuICAgICAgICByZW5kZXJlZFNlYXJjaCxcbiAgICAgICAgYWNjXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChyZXF1ZXN0S2V5LmVuZHNXaXRoKFBBR0VfU0VHTUVOVF9LRVkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgcGFnZSBzZWdtZW50LlxuICAgICAgaXNQYWdlID0gdHJ1ZVxuICAgICAgdmFyeVBhdGggPSBmaW5hbGl6ZVBhZ2VWYXJ5UGF0aChcbiAgICAgICAgcmVxdWVzdEtleSxcbiAgICAgICAgcmVuZGVyZWRTZWFyY2gsXG4gICAgICAgIHBhcnRpYWxWYXJ5UGF0aFxuICAgICAgKVxuICAgICAgLy8gVGhlIG1ldGFkYXRhIFwic2VnbWVudFwiIGlzIG5vdCBwYXJ0IHRoZSByb3V0ZSB0cmVlLCBidXQgaXQgaGFzIHRoZSBzYW1lXG4gICAgICAvLyBjb25jZXB0dWFsIHBhcmFtcyBhcyBhIHBhZ2Ugc2VnbWVudC4gV3JpdGUgdGhlIHZhcnkgcGF0aCBpbnRvIHRoZVxuICAgICAgLy8gYWNjdW11bGF0b3Igb2JqZWN0LiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgcGFyYWxsZWwgcGFnZXMsIHdlIHVzZSB0aGVcbiAgICAgIC8vIGZpcnN0IG9uZS4gV2hpY2ggcGFnZSB3ZSBjaG9vc2UgaXMgYXJiaXRyYXJ5IGFzIGxvbmcgYXMgaXQnc1xuICAgICAgLy8gY29uc2lzdGVudGx5IHRoZSBzYW1lIG9uZSBldmVyeSB0aW1lIGV2ZXJ5IHRpbWUuIFNlZVxuICAgICAgLy8gZmluYWxpemVNZXRhZGF0YVZhcnlQYXRoIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBpZiAoYWNjLm1ldGFkYXRhVmFyeVBhdGggPT09IG51bGwpIHtcbiAgICAgICAgYWNjLm1ldGFkYXRhVmFyeVBhdGggPSBmaW5hbGl6ZU1ldGFkYXRhVmFyeVBhdGgoXG4gICAgICAgICAgcmVxdWVzdEtleSxcbiAgICAgICAgICByZW5kZXJlZFNlYXJjaCxcbiAgICAgICAgICBwYXJ0aWFsVmFyeVBhdGhcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGEgbGF5b3V0IHNlZ21lbnQuXG4gICAgICBpc1BhZ2UgPSBmYWxzZVxuICAgICAgdmFyeVBhdGggPSBmaW5hbGl6ZUxheW91dFZhcnlQYXRoKHJlcXVlc3RLZXksIHBhcnRpYWxWYXJ5UGF0aClcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlcXVlc3RLZXksXG4gICAgc2VnbWVudCxcbiAgICB2YXJ5UGF0aCxcbiAgICAvLyBUT0RPOiBDaGVhdGluZyB0aGUgdHlwZSBzeXN0ZW0gaGVyZSBhIGJpdCBiZWNhdXNlIFR5cGVTY3JpcHQgY2FuJ3QgdGVsbFxuICAgIC8vIHRoYXQgdGhlIHR5cGUgb2YgaXNQYWdlIGFuZCB2YXJ5UGF0aCBhcmUgY29uc2lzdGVudC4gVGhlIGZpeCB3b3VsZCBiZSB0b1xuICAgIC8vIGNyZWF0ZSBzZXBhcmF0ZSBjb25zdHJ1Y3RvcnMgYW5kIGNhbGwgdGhlIGFwcHJvcHJpYXRlIG9uZSBmcm9tIGVhY2ggb2ZcbiAgICAvLyB0aGUgYnJhbmNoZXMgYWJvdmUuIEp1c3Qgc2VlbXMgYSBiaXQgb3ZlcmtpbGwgb25seSBmb3Igb25lIGZpZWxkIHNvIEknbGxcbiAgICAvLyBsZWF2ZSBpdCBhcy1pcyBmb3Igbm93LiBJZiBpc1BhZ2Ugd2VyZSB3cm9uZyBpdCB3b3VsZCBicmVhayB0aGUgYmVoYXZpb3JcbiAgICAvLyBhbmQgd2UnZCBjYXRjaCBpdCBxdWlja2x5LCBhbnl3YXkuXG4gICAgaXNQYWdlOiBpc1BhZ2UgYXMgYm9vbGVhbiBhcyBhbnksXG4gICAgc2xvdHMsXG4gICAgaXNSb290TGF5b3V0OiBwcmVmZXRjaC5pc1Jvb3RMYXlvdXQsXG4gICAgLy8gVGhpcyBmaWVsZCBpcyBvbmx5IHJlbGV2YW50IHRvIGR5bmFtaWMgcm91dGVzLiBGb3IgYSBQUFIvc3RhdGljIHJvdXRlLFxuICAgIC8vIHRoZXJlJ3MgYWx3YXlzIHNvbWUgcGFydGlhbCBsb2FkaW5nIHN0YXRlIHdlIGNhbiBmZXRjaC5cbiAgICBoYXNMb2FkaW5nQm91bmRhcnk6IEhhc0xvYWRpbmdCb3VuZGFyeS5TZWdtZW50SGFzTG9hZGluZ0JvdW5kYXJ5LFxuICAgIGhhc1J1bnRpbWVQcmVmZXRjaDogcHJlZmV0Y2guaGFzUnVudGltZVByZWZldGNoLFxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRSb290RmxpZ2h0Um91dGVyU3RhdGVUb1JvdXRlVHJlZShcbiAgZmxpZ2h0Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICByZW5kZXJlZFNlYXJjaDogTm9ybWFsaXplZFNlYXJjaCxcbiAgYWNjOiBSb3V0ZVRyZWVBY2N1bXVsYXRvclxuKTogUm91dGVUcmVlIHtcbiAgcmV0dXJuIGNvbnZlcnRGbGlnaHRSb3V0ZXJTdGF0ZVRvUm91dGVUcmVlKFxuICAgIGZsaWdodFJvdXRlclN0YXRlLFxuICAgIFJPT1RfU0VHTUVOVF9SRVFVRVNUX0tFWSxcbiAgICBudWxsLFxuICAgIHJlbmRlcmVkU2VhcmNoLFxuICAgIGFjY1xuICApXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRGbGlnaHRSb3V0ZXJTdGF0ZVRvUm91dGVUcmVlKFxuICBmbGlnaHRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIHJlcXVlc3RLZXk6IFNlZ21lbnRSZXF1ZXN0S2V5LFxuICBwYXJlbnRQYXJ0aWFsVmFyeVBhdGg6IFBhcnRpYWxTZWdtZW50VmFyeVBhdGggfCBudWxsLFxuICByZW5kZXJlZFNlYXJjaDogTm9ybWFsaXplZFNlYXJjaCxcbiAgYWNjOiBSb3V0ZVRyZWVBY2N1bXVsYXRvclxuKTogUm91dGVUcmVlIHtcbiAgY29uc3Qgb3JpZ2luYWxTZWdtZW50ID0gZmxpZ2h0Um91dGVyU3RhdGVbMF1cblxuICBsZXQgc2VnbWVudDogRmxpZ2h0Um91dGVyU3RhdGVTZWdtZW50XG4gIGxldCBwYXJ0aWFsVmFyeVBhdGg6IFBhcnRpYWxTZWdtZW50VmFyeVBhdGggfCBudWxsXG4gIGxldCBpc1BhZ2U6IGJvb2xlYW5cbiAgbGV0IHZhcnlQYXRoOiBTZWdtZW50VmFyeVBhdGhcbiAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luYWxTZWdtZW50KSkge1xuICAgIGlzUGFnZSA9IGZhbHNlXG4gICAgY29uc3QgcGFyYW1DYWNoZUtleSA9IG9yaWdpbmFsU2VnbWVudFsxXVxuICAgIHBhcnRpYWxWYXJ5UGF0aCA9IGFwcGVuZExheW91dFZhcnlQYXRoKHBhcmVudFBhcnRpYWxWYXJ5UGF0aCwgcGFyYW1DYWNoZUtleSlcbiAgICB2YXJ5UGF0aCA9IGZpbmFsaXplTGF5b3V0VmFyeVBhdGgocmVxdWVzdEtleSwgcGFydGlhbFZhcnlQYXRoKVxuICAgIHNlZ21lbnQgPSBvcmlnaW5hbFNlZ21lbnRcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIHNlZ21lbnQgZG9lcyBub3QgaGF2ZSBhIHBhcmFtLiBJbmhlcml0IHRoZSBwYXJ0aWFsIHZhcnkgcGF0aCBvZlxuICAgIC8vIHRoZSBwYXJlbnQuXG4gICAgcGFydGlhbFZhcnlQYXRoID0gcGFyZW50UGFydGlhbFZhcnlQYXRoXG4gICAgaWYgKHJlcXVlc3RLZXkuZW5kc1dpdGgoUEFHRV9TRUdNRU5UX0tFWSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBwYWdlIHNlZ21lbnQuXG4gICAgICBpc1BhZ2UgPSB0cnVlXG5cbiAgICAgIC8vIFRoZSBuYXZpZ2F0aW9uIGltcGxlbWVudGF0aW9uIGV4cGVjdHMgdGhlIHNlYXJjaCBwYXJhbXMgdG8gYmUgaW5jbHVkZWRcbiAgICAgIC8vIGluIHRoZSBzZWdtZW50LiBIb3dldmVyLCBpbiB0aGUgY2FzZSBvZiBhIHN0YXRpYyByZXNwb25zZSwgdGhlIHNlYXJjaFxuICAgICAgLy8gcGFyYW1zIGFyZSBvbWl0dGVkLiBTbyB0aGUgY2xpZW50IG5lZWRzIHRvIGFkZCB0aGVtIGJhY2sgaW4gd2hlbiByZWFkaW5nXG4gICAgICAvLyBmcm9tIHRoZSBTZWdtZW50IENhY2hlLlxuICAgICAgLy9cbiAgICAgIC8vIEZvciBjb25zaXN0ZW5jeSwgd2UnbGwgZG8gdGhpcyBmb3IgZHluYW1pYyByZXNwb25zZXMsIHRvby5cbiAgICAgIC8vXG4gICAgICAvLyBUT0RPOiBXZSBzaG91bGQgbW92ZSBzZWFyY2ggcGFyYW1zIG91dCBvZiBGbGlnaHRSb3V0ZXJTdGF0ZSBhbmQgaGFuZGxlXG4gICAgICAvLyB0aGVtIGVudGlyZWx5IG9uIHRoZSBjbGllbnQsIHNpbWlsYXIgdG8gb3VyIHBsYW4gZm9yIGR5bmFtaWMgcGFyYW1zLlxuICAgICAgc2VnbWVudCA9IFBBR0VfU0VHTUVOVF9LRVlcbiAgICAgIHZhcnlQYXRoID0gZmluYWxpemVQYWdlVmFyeVBhdGgoXG4gICAgICAgIHJlcXVlc3RLZXksXG4gICAgICAgIHJlbmRlcmVkU2VhcmNoLFxuICAgICAgICBwYXJ0aWFsVmFyeVBhdGhcbiAgICAgIClcbiAgICAgIC8vIFRoZSBtZXRhZGF0YSBcInNlZ21lbnRcIiBpcyBub3QgcGFydCB0aGUgcm91dGUgdHJlZSwgYnV0IGl0IGhhcyB0aGUgc2FtZVxuICAgICAgLy8gY29uY2VwdHVhbCBwYXJhbXMgYXMgYSBwYWdlIHNlZ21lbnQuIFdyaXRlIHRoZSB2YXJ5IHBhdGggaW50byB0aGVcbiAgICAgIC8vIGFjY3VtdWxhdG9yIG9iamVjdC4gSWYgdGhlcmUgYXJlIG11bHRpcGxlIHBhcmFsbGVsIHBhZ2VzLCB3ZSB1c2UgdGhlXG4gICAgICAvLyBmaXJzdCBvbmUuIFdoaWNoIHBhZ2Ugd2UgY2hvb3NlIGlzIGFyYml0cmFyeSBhcyBsb25nIGFzIGl0J3NcbiAgICAgIC8vIGNvbnNpc3RlbnRseSB0aGUgc2FtZSBvbmUgZXZlcnkgdGltZSBldmVyeSB0aW1lLiBTZWVcbiAgICAgIC8vIGZpbmFsaXplTWV0YWRhdGFWYXJ5UGF0aCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgaWYgKGFjYy5tZXRhZGF0YVZhcnlQYXRoID09PSBudWxsKSB7XG4gICAgICAgIGFjYy5tZXRhZGF0YVZhcnlQYXRoID0gZmluYWxpemVNZXRhZGF0YVZhcnlQYXRoKFxuICAgICAgICAgIHJlcXVlc3RLZXksXG4gICAgICAgICAgcmVuZGVyZWRTZWFyY2gsXG4gICAgICAgICAgcGFydGlhbFZhcnlQYXRoXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhIGxheW91dCBzZWdtZW50LlxuICAgICAgaXNQYWdlID0gZmFsc2VcbiAgICAgIHNlZ21lbnQgPSBvcmlnaW5hbFNlZ21lbnRcbiAgICAgIHZhcnlQYXRoID0gZmluYWxpemVMYXlvdXRWYXJ5UGF0aChyZXF1ZXN0S2V5LCBwYXJ0aWFsVmFyeVBhdGgpXG4gICAgfVxuICB9XG5cbiAgbGV0IHNsb3RzOiB7IFtwYXJhbGxlbFJvdXRlS2V5OiBzdHJpbmddOiBSb3V0ZVRyZWUgfSB8IG51bGwgPSBudWxsXG5cbiAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSBmbGlnaHRSb3V0ZXJTdGF0ZVsxXVxuICBmb3IgKGxldCBwYXJhbGxlbFJvdXRlS2V5IGluIHBhcmFsbGVsUm91dGVzKSB7XG4gICAgY29uc3QgY2hpbGRSb3V0ZXJTdGF0ZSA9IHBhcmFsbGVsUm91dGVzW3BhcmFsbGVsUm91dGVLZXldXG4gICAgY29uc3QgY2hpbGRTZWdtZW50ID0gY2hpbGRSb3V0ZXJTdGF0ZVswXVxuICAgIC8vIFRPRE86IEV2ZW50dWFsbHksIHRoZSBwYXJhbSB2YWx1ZXMgd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3BvbnNlXG4gICAgLy8gZnJvbSB0aGUgc2VydmVyLiBXZSdsbCBpbnN0ZWFkIGZpbGwgdGhlbSBpbiBvbiB0aGUgY2xpZW50IGJ5IHBhcnNpbmdcbiAgICAvLyB0aGUgVVJMLiBUaGlzIGlzIHdoZXJlIHdlJ2xsIGRvIHRoYXQuXG4gICAgY29uc3QgY2hpbGRSZXF1ZXN0S2V5UGFydCA9IGNyZWF0ZVNlZ21lbnRSZXF1ZXN0S2V5UGFydChjaGlsZFNlZ21lbnQpXG4gICAgY29uc3QgY2hpbGRSZXF1ZXN0S2V5ID0gYXBwZW5kU2VnbWVudFJlcXVlc3RLZXlQYXJ0KFxuICAgICAgcmVxdWVzdEtleSxcbiAgICAgIHBhcmFsbGVsUm91dGVLZXksXG4gICAgICBjaGlsZFJlcXVlc3RLZXlQYXJ0XG4gICAgKVxuICAgIGNvbnN0IGNoaWxkVHJlZSA9IGNvbnZlcnRGbGlnaHRSb3V0ZXJTdGF0ZVRvUm91dGVUcmVlKFxuICAgICAgY2hpbGRSb3V0ZXJTdGF0ZSxcbiAgICAgIGNoaWxkUmVxdWVzdEtleSxcbiAgICAgIHBhcnRpYWxWYXJ5UGF0aCxcbiAgICAgIHJlbmRlcmVkU2VhcmNoLFxuICAgICAgYWNjXG4gICAgKVxuICAgIGlmIChzbG90cyA9PT0gbnVsbCkge1xuICAgICAgc2xvdHMgPSB7XG4gICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogY2hpbGRUcmVlLFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzbG90c1twYXJhbGxlbFJvdXRlS2V5XSA9IGNoaWxkVHJlZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmVxdWVzdEtleSxcbiAgICBzZWdtZW50LFxuICAgIHZhcnlQYXRoLFxuICAgIC8vIFRPRE86IENoZWF0aW5nIHRoZSB0eXBlIHN5c3RlbSBoZXJlIGEgYml0IGJlY2F1c2UgVHlwZVNjcmlwdCBjYW4ndCB0ZWxsXG4gICAgLy8gdGhhdCB0aGUgdHlwZSBvZiBpc1BhZ2UgYW5kIHZhcnlQYXRoIGFyZSBjb25zaXN0ZW50LiBUaGUgZml4IHdvdWxkIGJlIHRvXG4gICAgLy8gY3JlYXRlIHNlcGFyYXRlIGNvbnN0cnVjdG9ycyBhbmQgY2FsbCB0aGUgYXBwcm9wcmlhdGUgb25lIGZyb20gZWFjaCBvZlxuICAgIC8vIHRoZSBicmFuY2hlcyBhYm92ZS4gSnVzdCBzZWVtcyBhIGJpdCBvdmVya2lsbCBvbmx5IGZvciBvbmUgZmllbGQgc28gSSdsbFxuICAgIC8vIGxlYXZlIGl0IGFzLWlzIGZvciBub3cuIElmIGlzUGFnZSB3ZXJlIHdyb25nIGl0IHdvdWxkIGJyZWFrIHRoZSBiZWhhdmlvclxuICAgIC8vIGFuZCB3ZSdkIGNhdGNoIGl0IHF1aWNrbHksIGFueXdheS5cbiAgICBpc1BhZ2U6IGlzUGFnZSBhcyBib29sZWFuIGFzIGFueSxcbiAgICBzbG90cyxcbiAgICBpc1Jvb3RMYXlvdXQ6IGZsaWdodFJvdXRlclN0YXRlWzRdID09PSB0cnVlLFxuICAgIGhhc0xvYWRpbmdCb3VuZGFyeTpcbiAgICAgIGZsaWdodFJvdXRlclN0YXRlWzVdICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBmbGlnaHRSb3V0ZXJTdGF0ZVs1XVxuICAgICAgICA6IEhhc0xvYWRpbmdCb3VuZGFyeS5TdWJ0cmVlSGFzTm9Mb2FkaW5nQm91bmRhcnksXG5cbiAgICAvLyBOb24tc3RhdGljIHRyZWUgcmVzcG9uc2VzIGFyZSBvbmx5IHVzZWQgYnkgYXBwcyB0aGF0IGhhdmVuJ3QgYWRvcHRlZFxuICAgIC8vIENhY2hlIENvbXBvbmVudHMuIFNvIHRoaXMgaXMgYWx3YXlzIGZhbHNlLlxuICAgIGhhc1J1bnRpbWVQcmVmZXRjaDogZmFsc2UsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSb3V0ZVRyZWVUb0ZsaWdodFJvdXRlclN0YXRlKFxuICByb3V0ZVRyZWU6IFJvdXRlVHJlZVxuKTogRmxpZ2h0Um91dGVyU3RhdGUge1xuICBjb25zdCBwYXJhbGxlbFJvdXRlczogUmVjb3JkPHN0cmluZywgRmxpZ2h0Um91dGVyU3RhdGU+ID0ge31cbiAgaWYgKHJvdXRlVHJlZS5zbG90cyAhPT0gbnVsbCkge1xuICAgIGZvciAoY29uc3QgcGFyYWxsZWxSb3V0ZUtleSBpbiByb3V0ZVRyZWUuc2xvdHMpIHtcbiAgICAgIHBhcmFsbGVsUm91dGVzW3BhcmFsbGVsUm91dGVLZXldID0gY29udmVydFJvdXRlVHJlZVRvRmxpZ2h0Um91dGVyU3RhdGUoXG4gICAgICAgIHJvdXRlVHJlZS5zbG90c1twYXJhbGxlbFJvdXRlS2V5XVxuICAgICAgKVxuICAgIH1cbiAgfVxuICBjb25zdCBmbGlnaHRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUgPSBbXG4gICAgcm91dGVUcmVlLnNlZ21lbnQsXG4gICAgcGFyYWxsZWxSb3V0ZXMsXG4gICAgbnVsbCxcbiAgICBudWxsLFxuICAgIHJvdXRlVHJlZS5pc1Jvb3RMYXlvdXQsXG4gIF1cbiAgcmV0dXJuIGZsaWdodFJvdXRlclN0YXRlXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFJvdXRlT25DYWNoZU1pc3MoXG4gIGVudHJ5OiBQZW5kaW5nUm91dGVDYWNoZUVudHJ5LFxuICB0YXNrOiBQcmVmZXRjaFRhc2ssXG4gIGtleTogUm91dGVDYWNoZUtleVxuKTogUHJvbWlzZTxQcmVmZXRjaFN1YnRhc2tSZXN1bHQ8bnVsbD4gfCBudWxsPiB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgYWxsb3dlZCB0byB1c2UgYXN5bmMvYXdhaXQgYmVjYXVzZSBpdCBjb250YWlucyB0aGUgYWN0dWFsXG4gIC8vIGZldGNoIHRoYXQgZ2V0cyBpc3N1ZWQgb24gYSBjYWNoZSBtaXNzLiBOb3RpY2UgaXQgd3JpdGVzIHRoZSByZXN1bHQgdG8gdGhlXG4gIC8vIGNhY2hlIGVudHJ5IGRpcmVjdGx5LCByYXRoZXIgdGhhbiByZXR1cm4gZGF0YSB0aGF0IGlzIHRoZW4gd3JpdHRlbiBieVxuICAvLyB0aGUgY2FsbGVyLlxuICBjb25zdCBwYXRobmFtZSA9IGtleS5wYXRobmFtZVxuICBjb25zdCBzZWFyY2ggPSBrZXkuc2VhcmNoXG4gIGNvbnN0IG5leHRVcmwgPSBrZXkubmV4dFVybFxuICBjb25zdCBzZWdtZW50UGF0aCA9ICcvX3RyZWUnIGFzIFNlZ21lbnRSZXF1ZXN0S2V5XG5cbiAgY29uc3QgaGVhZGVyczogUmVxdWVzdEhlYWRlcnMgPSB7XG4gICAgW1JTQ19IRUFERVJdOiAnMScsXG4gICAgW05FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUl06ICcxJyxcbiAgICBbTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVJdOiBzZWdtZW50UGF0aCxcbiAgfVxuICBpZiAobmV4dFVybCAhPT0gbnVsbCkge1xuICAgIGhlYWRlcnNbTkVYVF9VUkxdID0gbmV4dFVybFxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhdGhuYW1lICsgc2VhcmNoLCBsb2NhdGlvbi5vcmlnaW4pXG4gICAgbGV0IHJlc3BvbnNlXG4gICAgbGV0IHVybEFmdGVyUmVkaXJlY3RzXG4gICAgaWYgKGlzT3V0cHV0RXhwb3J0TW9kZSkge1xuICAgICAgLy8gSW4gb3V0cHV0OiBcImV4cG9ydFwiIG1vZGUsIHdlIGNhbid0IHVzZSBoZWFkZXJzIHRvIHJlcXVlc3QgYSBwYXJ0aWN1bGFyXG4gICAgICAvLyBzZWdtZW50LiBJbnN0ZWFkLCB3ZSBlbmNvZGUgdGhlIGV4dHJhIHJlcXVlc3QgaW5mb3JtYXRpb24gaW50byB0aGUgVVJMLlxuICAgICAgLy8gVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgXCJwdWJsaWNcIiBpbnRlcmZhY2Ugb2YgdGhlIGFwcDsgaXQncyBhbiBpbnRlcm5hbFxuICAgICAgLy8gTmV4dC5qcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgdGhhdCB0aGUgYXBwIGRldmVsb3BlciBzaG91bGQgbm90IG5lZWQgdG9cbiAgICAgIC8vIGNvbmNlcm4gdGhlbXNlbHZlcyB3aXRoLlxuICAgICAgLy9cbiAgICAgIC8vIEZvciBleGFtcGxlLCB0byByZXF1ZXN0IGEgc2VnbWVudDpcbiAgICAgIC8vXG4gICAgICAvLyAgIFBhdGggcGFzc2VkIHRvIDxMaW5rPjogICAvcGF0aC90by9wYWdlXG4gICAgICAvLyAgIFBhdGggcGFzc2VkIHRvIGZldGNoOiAgICAvcGF0aC90by9wYWdlL19fbmV4dC1zZWdtZW50cy9fdHJlZVxuICAgICAgLy9cbiAgICAgIC8vICAgKFRoaXMgaXMgbm90IHRoZSBleGFjdCBwcm90b2NvbCwganVzdCBhbiBpbGx1c3RyYXRpb24uKVxuICAgICAgLy9cbiAgICAgIC8vIEJlZm9yZSB3ZSBkbyB0aGF0LCB0aG91Z2gsIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgcmVkaXJlY3RzLiBFdmVuIGluXG4gICAgICAvLyBvdXRwdXQ6IFwiZXhwb3J0XCIgbW9kZSwgYSBwcm94eSBtaWdodCByZWRpcmVjdCB0aGUgcGFnZSB0byBhIGRpZmZlcmVudFxuICAgICAgLy8gbG9jYXRpb24sIGJ1dCB3ZSBzaG91bGRuJ3QgYXNzdW1lIG9yIGV4cGVjdCB0aGF0IHRoZXkgYWxzbyByZWRpcmVjdCBhbGxcbiAgICAgIC8vIHRoZSBzZWdtZW50IGZpbGVzLCB0b28uXG4gICAgICAvL1xuICAgICAgLy8gVG8gY2hlY2sgd2hldGhlciB0aGUgcGFnZSBpcyByZWRpcmVjdGVkLCBwcmV2aW91c2x5IHdlIHBlcmZvcm0gYSByYW5nZVxuICAgICAgLy8gcmVxdWVzdCBvZiA2NCBieXRlcyBvZiB0aGUgSFRNTCBkb2N1bWVudCB0byBjaGVjayBpZiB0aGUgdGFyZ2V0IHBhZ2VcbiAgICAgIC8vIGlzIHBhcnQgb2YgdGhpcyBhcHAgKGJ5IGNoZWNraW5nIGlmIGJ1aWxkIGlkIG1hdGNoZXMpLiBPbmx5IGlmIHRoZSB0YXJnZXRcbiAgICAgIC8vIHBhZ2UgaXMgcGFydCBvZiB0aGlzIGFwcCBkbyB3ZSBkZXRlcm1pbmUgdGhlIGZpbmFsIGNhbm9uaWNhbCBVUkwuXG4gICAgICAvL1xuICAgICAgLy8gSG93ZXZlciwgYXMgbWVudGlvbmVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9wdWxsLzg1OTAzLFxuICAgICAgLy8gc29tZSBwb3B1bGFyIHN0YXRpYyBob3N0aW5nIHByb3ZpZGVycyAobGlrZSBDbG91ZGZsYXJlIFBhZ2VzIG9yIFJlbmRlci5jb20pXG4gICAgICAvLyBkbyBub3Qgc3VwcG9ydCByYW5nZSByZXF1ZXN0cywgaW4gdGhlIHdvcnN0IGNhc2UsIHRoZSBlbnRpcmUgSFRNTCBpbnN0ZWFkXG4gICAgICAvLyBvZiA2NCBieXRlcyBjb3VsZCBiZSByZXR1cm5lZCwgd2hpY2ggaXMgd2FzdGVmdWwuXG4gICAgICAvL1xuICAgICAgLy8gU28gaW5zdGVhZCwgd2UgZHJvcHMgdGhlIGNoZWNrIGZvciBidWlsZCBpZCBoZXJlLCBhbmQgc2ltcGx5IHBlcmZvcm1cbiAgICAgIC8vIGEgSEVBRCByZXF1ZXN0IHRvIHJlamVjdHMgMXh4LzR4eC81eHggcmVzcG9uc2VzLCBhbmQgdGhlbiBkZXRlcm1pbmUgdGhlXG4gICAgICAvLyBmaW5hbCBVUkwgYWZ0ZXIgcmVkaXJlY3RzLlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IFdlIGNvdWxkIGVtYmVkIHRoZSByb3V0ZSB0cmVlIGludG8gdGhlIEhUTUwgZG9jdW1lbnQsIHRvIGF2b2lkXG4gICAgICAvLyBhIHNlY29uZCByZXF1ZXN0LiBXZSdyZSBub3QgZG9pbmcgdGhhdCBjdXJyZW50bHkgYmVjYXVzZSBpdCB3b3VsZCBtYWtlXG4gICAgICAvLyB0aGUgSFRNTCBkb2N1bWVudCBsYXJnZXIgYW5kIGFmZmVjdCBub3JtYWwgcGFnZSBsb2Fkcy5cbiAgICAgIGNvbnN0IGhlYWRSZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6ICdIRUFEJyxcbiAgICAgIH0pXG4gICAgICBpZiAoaGVhZFJlc3BvbnNlLnN0YXR1cyA8IDIwMCB8fCBoZWFkUmVzcG9uc2Uuc3RhdHVzID49IDQwMCkge1xuICAgICAgICAvLyBUaGUgdGFyZ2V0IHBhZ2UgcmVzcG9uZGVkIHcvbyBhIHN1Y2Nlc3NmdWwgc3RhdHVzIGNvZGVcbiAgICAgICAgLy8gQ291bGQgYmUgYSBXQUYgc2VydmluZyBhIDQwMywgb3IgYSA1eHggZnJvbSBhIGJhY2tlbmRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGNhbid0IHVzZSBoZWFkUmVzcG9uc2Uub2sgaGVyZSwgYmVjYXVzZVxuICAgICAgICAvLyBSZXNwb25zZSNvayByZXR1cm5zIGBmYWxzZWAgd2l0aCAzeHggcmVzcG9uc2VzLlxuICAgICAgICByZWplY3RSb3V0ZUNhY2hlRW50cnkoZW50cnksIERhdGUubm93KCkgKyAxMCAqIDEwMDApXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIHVybEFmdGVyUmVkaXJlY3RzID0gaGVhZFJlc3BvbnNlLnJlZGlyZWN0ZWRcbiAgICAgICAgPyBuZXcgVVJMKGhlYWRSZXNwb25zZS51cmwpXG4gICAgICAgIDogdXJsXG5cbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hQcmVmZXRjaFJlc3BvbnNlKFxuICAgICAgICBhZGRTZWdtZW50UGF0aFRvVXJsSW5PdXRwdXRFeHBvcnRNb2RlKHVybEFmdGVyUmVkaXJlY3RzLCBzZWdtZW50UGF0aCksXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gXCJTZXJ2ZXJcIiBtb2RlLiBXZSBjYW4gdXNlIHJlcXVlc3QgaGVhZGVycyBpbnN0ZWFkIG9mIHRoZSBwYXRobmFtZS5cbiAgICAgIC8vIFRPRE86IFRoZSBldmVudHVhbCBwbGFuIGlzIHRvIGdldCByaWQgb2Ygb3VyIGN1c3RvbSByZXF1ZXN0IGhlYWRlcnMgYW5kXG4gICAgICAvLyBlbmNvZGUgZXZlcnl0aGluZyBpbnRvIHRoZSBVUkwsIHVzaW5nIGEgc2ltaWxhciBzdHJhdGVneSB0byB0aGVcbiAgICAgIC8vIFwib3V0cHV0OiBleHBvcnRcIiBibG9jayBhYm92ZS5cbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hQcmVmZXRjaFJlc3BvbnNlKHVybCwgaGVhZGVycylcbiAgICAgIHVybEFmdGVyUmVkaXJlY3RzID1cbiAgICAgICAgcmVzcG9uc2UgIT09IG51bGwgJiYgcmVzcG9uc2UucmVkaXJlY3RlZCA/IG5ldyBVUkwocmVzcG9uc2UudXJsKSA6IHVybFxuICAgIH1cblxuICAgIGlmIChcbiAgICAgICFyZXNwb25zZSB8fFxuICAgICAgIXJlc3BvbnNlLm9rIHx8XG4gICAgICAvLyAyMDQgaXMgYSBDYWNoZSBtaXNzLiBUaG91Z2ggdGhlb3JldGljYWxseSB0aGlzIHNob3VsZG4ndCBoYXBwZW4gd2hlblxuICAgICAgLy8gUFBSIGlzIGVuYWJsZWQsIGJlY2F1c2Ugd2UgYWx3YXlzIHJlc3BvbmQgdG8gcm91dGUgdHJlZSByZXF1ZXN0cywgZXZlblxuICAgICAgLy8gaWYgaXQgbmVlZHMgdG8gYmUgYmxvY2tpbmdseSBnZW5lcmF0ZWQgb24gZGVtYW5kLlxuICAgICAgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDQgfHxcbiAgICAgICFyZXNwb25zZS5ib2R5XG4gICAgKSB7XG4gICAgICAvLyBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYW4gZXJyb3IsIG9yIHdpdGggYSBtaXNzLiBXZSBzaG91bGQgc3RpbGwgY2FjaGVcbiAgICAgIC8vIHRoZSByZXNwb25zZSwgYnV0IHdlIGNhbiB0cnkgYWdhaW4gYWZ0ZXIgMTAgc2Vjb25kcy5cbiAgICAgIHJlamVjdFJvdXRlQ2FjaGVFbnRyeShlbnRyeSwgRGF0ZS5ub3coKSArIDEwICogMTAwMClcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gVE9ETzogVGhlIGNhbm9uaWNhbCBVUkwgaXMgdGhlIGhyZWYgd2l0aG91dCB0aGUgb3JpZ2luLiBJIHRoaW5rXG4gICAgLy8gaGlzdG9yaWNhbGx5IHRoZSByZWFzb24gZm9yIHRoaXMgaXMgYmVjYXVzZSB0aGUgaW5pdGlhbCBjYW5vbmljYWwgVVJMXG4gICAgLy8gZ2V0cyBwYXNzZWQgYXMgYSBwcm9wIHRvIHRoZSB0b3AtbGV2ZWwgUmVhY3QgY29tcG9uZW50LCB3aGljaCBtZWFucyBpdFxuICAgIC8vIG5lZWRzIHRvIGJlIGNvbXB1dGVkIGR1cmluZyBTU1IuIElmIGl0IHdlcmUgdG8gaW5jbHVkZSB0aGUgb3JpZ2luLCBpdFxuICAgIC8vIHdvdWxkIG5lZWQgdG8gYWx3YXlzIGJlIHNhbWUgYXMgbG9jYXRpb24ub3JpZ2luIG9uIHRoZSBjbGllbnQsIHRvIHByZXZlbnRcbiAgICAvLyBhIGh5ZHJhdGlvbiBtaXNtYXRjaC4gVG8gc2lkZXN0ZXAgdGhpcyBjb21wbGV4aXR5LCB3ZSBvbWl0IHRoZSBvcmlnaW4uXG4gICAgLy9cbiAgICAvLyBIb3dldmVyLCBzaW5jZSB0aGlzIGlzIG5laXRoZXIgYSBuYXRpdmUgVVJMIG9iamVjdCBub3IgYSBmdWxseSBxdWFsaWZpZWRcbiAgICAvLyBVUkwgc3RyaW5nLCB3ZSBuZWVkIHRvIGJlIGNhcmVmdWwgYWJvdXQgaG93IHdlIHVzZSBpdC4gVG8gcHJldmVudCBzdWJ0bGVcbiAgICAvLyBtaXN0YWtlcywgd2Ugc2hvdWxkIGNyZWF0ZSBhIHNwZWNpYWwgdHlwZSBmb3IgaXQsIGluc3RlYWQgb2YganVzdCBzdHJpbmcuXG4gICAgLy8gT3IsIHdlIHNob3VsZCBqdXN0IHVzZSBhIChyZWFkb25seSkgVVJMIG9iamVjdCBpbnN0ZWFkLiBUaGUgdHlwZSBvZiB0aGVcbiAgICAvLyBwcm9wIHRoYXQgd2UgcGFzcyB0byBzZWVkIHRoZSBpbml0aWFsIHN0YXRlIGRvZXMgbm90IG5lZWQgdG8gYmUgdGhlIHNhbWVcbiAgICAvLyB0eXBlIGFzIHRoZSBzdGF0ZSBpdHNlbGYuXG4gICAgY29uc3QgY2Fub25pY2FsVXJsID0gY3JlYXRlSHJlZkZyb21VcmwodXJsQWZ0ZXJSZWRpcmVjdHMpXG5cbiAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSByZXNwb25zZSB2YXJpZXMgYmFzZWQgb24gdGhlIE5leHQtVXJsIGhlYWRlci5cbiAgICBjb25zdCB2YXJ5SGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3ZhcnknKVxuICAgIGNvbnN0IGNvdWxkQmVJbnRlcmNlcHRlZCA9XG4gICAgICB2YXJ5SGVhZGVyICE9PSBudWxsICYmIHZhcnlIZWFkZXIuaW5jbHVkZXMoTkVYVF9VUkwpXG5cbiAgICAvLyBUcmFjayB3aGVuIHRoZSBuZXR3b3JrIGNvbm5lY3Rpb24gY2xvc2VzLlxuICAgIGNvbnN0IGNsb3NlZCA9IGNyZWF0ZVByb21pc2VXaXRoUmVzb2x2ZXJzPHZvaWQ+KClcblxuICAgIC8vIFRoaXMgY2hlY2tzIHdoZXRoZXIgdGhlIHJlc3BvbnNlIHdhcyBzZXJ2ZWQgZnJvbSB0aGUgcGVyLXNlZ21lbnQgY2FjaGUsXG4gICAgLy8gcmF0aGVyIHRoYW4gdGhlIG9sZCBwcmVmZXRjaGluZyBmbG93LiBJZiBpdCBmYWlscywgaXQgaW1wbGllcyB0aGF0IFBQUlxuICAgIC8vIGlzIGRpc2FibGVkIG9uIHRoaXMgcm91dGUuXG4gICAgY29uc3Qgcm91dGVJc1BQUkVuYWJsZWQgPVxuICAgICAgcmVzcG9uc2UuaGVhZGVycy5nZXQoTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSKSA9PT0gJzInIHx8XG4gICAgICAvLyBJbiBvdXRwdXQ6IFwiZXhwb3J0XCIgbW9kZSwgd2UgY2FuJ3QgcmVseSBvbiByZXNwb25zZSBoZWFkZXJzLiBCdXQgaWYgd2VcbiAgICAgIC8vIHJlY2VpdmUgYSB3ZWxsLWZvcm1lZCByZXNwb25zZSwgd2UgY2FuIGFzc3VtZSBpdCdzIGEgc3RhdGljIHJlc3BvbnNlLFxuICAgICAgLy8gYmVjYXVzZSBhbGwgZGF0YSBpcyBzdGF0aWMgaW4gdGhpcyBtb2RlLlxuICAgICAgaXNPdXRwdXRFeHBvcnRNb2RlXG5cbiAgICBpZiAocm91dGVJc1BQUkVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IHByZWZldGNoU3RyZWFtID0gY3JlYXRlUHJlZmV0Y2hSZXNwb25zZVN0cmVhbShcbiAgICAgICAgcmVzcG9uc2UuYm9keSxcbiAgICAgICAgY2xvc2VkLnJlc29sdmUsXG4gICAgICAgIGZ1bmN0aW9uIG9uUmVzcG9uc2VTaXplVXBkYXRlKHNpemUpIHtcbiAgICAgICAgICBzZXRTaXplSW5DYWNoZU1hcChlbnRyeSwgc2l6ZSlcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgY29uc3Qgc2VydmVyRGF0YSA9IGF3YWl0IGNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW08Um9vdFRyZWVQcmVmZXRjaD4oXG4gICAgICAgIHByZWZldGNoU3RyZWFtLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApXG4gICAgICBpZiAoc2VydmVyRGF0YS5idWlsZElkICE9PSBnZXRBcHBCdWlsZElkKCkpIHtcbiAgICAgICAgLy8gVGhlIHNlcnZlciBidWlsZCBkb2VzIG5vdCBtYXRjaCB0aGUgY2xpZW50LiBUcmVhdCBhcyBhIDQwNC4gRHVyaW5nXG4gICAgICAgIC8vIGFuIGFjdHVhbCBuYXZpZ2F0aW9uLCB0aGUgcm91dGVyIHdpbGwgdHJpZ2dlciBhbiBNUEEgbmF2aWdhdGlvbi5cbiAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgbW92aW5nIHRoZSBidWlsZCBJRCB0byBhIHJlc3BvbnNlIGhlYWRlciBzbyB3ZSBjYW4gY2hlY2tcbiAgICAgICAgLy8gaXQgYmVmb3JlIGRlY29kaW5nIHRoZSByZXNwb25zZSwgYW5kIHNvIHRoZXJlJ3Mgb25lIHdheSBvZiBjaGVja2luZ1xuICAgICAgICAvLyBhY3Jvc3MgYWxsIHJlc3BvbnNlIHR5cGVzLlxuICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgY2FjaGUgdGhlIGZhY3QgdGhhdCB0aGlzIGlzIGFuIE1QQSBuYXZpZ2F0aW9uLlxuICAgICAgICByZWplY3RSb3V0ZUNhY2hlRW50cnkoZW50cnksIERhdGUubm93KCkgKyAxMCAqIDEwMDApXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgcGFyYW1zIHRoYXQgd2VyZSB1c2VkIHRvIHJlbmRlciB0aGUgdGFyZ2V0IHBhZ2UuIFRoZXNlIG1heVxuICAgICAgLy8gYmUgZGlmZmVyZW50IGZyb20gdGhlIHBhcmFtcyBpbiB0aGUgcmVxdWVzdCBVUkwsIGlmIHRoZSBwYWdlXG4gICAgICAvLyB3YXMgcmV3cml0dGVuLlxuICAgICAgY29uc3QgcmVuZGVyZWRQYXRobmFtZSA9IGdldFJlbmRlcmVkUGF0aG5hbWUocmVzcG9uc2UpXG4gICAgICBjb25zdCByZW5kZXJlZFNlYXJjaCA9IGdldFJlbmRlcmVkU2VhcmNoKHJlc3BvbnNlKVxuXG4gICAgICAvLyBDb252ZXJ0IHRoZSBzZXJ2ZXItc2VudCBkYXRhIGludG8gdGhlIFJvdXRlVHJlZSBmb3JtYXQgdXNlZCBieSB0aGVcbiAgICAgIC8vIGNsaWVudCBjYWNoZS5cbiAgICAgIC8vXG4gICAgICAvLyBEdXJpbmcgdGhpcyB0cmF2ZXJzYWwsIHdlIGFjY3VtdWxhdGUgYWRkaXRpb25hbCBkYXRhIGludG8gdGhpc1xuICAgICAgLy8gXCJhY2N1bXVsYXRvclwiIG9iamVjdC5cbiAgICAgIGNvbnN0IGFjYzogUm91dGVUcmVlQWNjdW11bGF0b3IgPSB7IG1ldGFkYXRhVmFyeVBhdGg6IG51bGwgfVxuICAgICAgY29uc3Qgcm91dGVUcmVlID0gY29udmVydFJvb3RUcmVlUHJlZmV0Y2hUb1JvdXRlVHJlZShcbiAgICAgICAgc2VydmVyRGF0YSxcbiAgICAgICAgcmVuZGVyZWRQYXRobmFtZSxcbiAgICAgICAgcmVuZGVyZWRTZWFyY2gsXG4gICAgICAgIGFjY1xuICAgICAgKVxuICAgICAgY29uc3QgbWV0YWRhdGFWYXJ5UGF0aCA9IGFjYy5tZXRhZGF0YVZhcnlQYXRoXG4gICAgICBpZiAobWV0YWRhdGFWYXJ5UGF0aCA9PT0gbnVsbCkge1xuICAgICAgICByZWplY3RSb3V0ZUNhY2hlRW50cnkoZW50cnksIERhdGUubm93KCkgKyAxMCAqIDEwMDApXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YWxlVGltZU1zID0gZ2V0U3RhbGVUaW1lTXMoc2VydmVyRGF0YS5zdGFsZVRpbWUpXG4gICAgICBmdWxmaWxsUm91dGVDYWNoZUVudHJ5KFxuICAgICAgICBlbnRyeSxcbiAgICAgICAgcm91dGVUcmVlLFxuICAgICAgICBtZXRhZGF0YVZhcnlQYXRoLFxuICAgICAgICBEYXRlLm5vdygpICsgc3RhbGVUaW1lTXMsXG4gICAgICAgIGNvdWxkQmVJbnRlcmNlcHRlZCxcbiAgICAgICAgY2Fub25pY2FsVXJsLFxuICAgICAgICByZW5kZXJlZFNlYXJjaCxcbiAgICAgICAgcm91dGVJc1BQUkVuYWJsZWRcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUFBSIGlzIG5vdCBlbmFibGVkIGZvciB0aGlzIHJvdXRlLiBUaGUgc2VydmVyIHJlc3BvbmRzIHdpdGggYVxuICAgICAgLy8gZGlmZmVyZW50IGZvcm1hdCAoRmxpZ2h0Um91dGVyU3RhdGUpIHRoYXQgd2UgbmVlZCB0byBjb252ZXJ0LlxuICAgICAgLy8gVE9ETzogV2Ugd2lsbCB1bmlmeSB0aGUgcmVzcG9uc2VzIGV2ZW50dWFsbHkuIEknbSBrZWVwaW5nIHRoZSB0eXBlc1xuICAgICAgLy8gc2VwYXJhdGUgZm9yIG5vdyBiZWNhdXNlIEZsaWdodFJvdXRlclN0YXRlIGhhcyBzbyBtYW55XG4gICAgICAvLyBvdmVybG9hZGVkIGNvbmNlcm5zLlxuICAgICAgY29uc3QgcHJlZmV0Y2hTdHJlYW0gPSBjcmVhdGVQcmVmZXRjaFJlc3BvbnNlU3RyZWFtKFxuICAgICAgICByZXNwb25zZS5ib2R5LFxuICAgICAgICBjbG9zZWQucmVzb2x2ZSxcbiAgICAgICAgZnVuY3Rpb24gb25SZXNwb25zZVNpemVVcGRhdGUoc2l6ZSkge1xuICAgICAgICAgIHNldFNpemVJbkNhY2hlTWFwKGVudHJ5LCBzaXplKVxuICAgICAgICB9XG4gICAgICApXG4gICAgICBjb25zdCBzZXJ2ZXJEYXRhID1cbiAgICAgICAgYXdhaXQgY3JlYXRlRnJvbU5leHRSZWFkYWJsZVN0cmVhbTxOYXZpZ2F0aW9uRmxpZ2h0UmVzcG9uc2U+KFxuICAgICAgICAgIHByZWZldGNoU3RyZWFtLFxuICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgKVxuICAgICAgaWYgKHNlcnZlckRhdGEuYiAhPT0gZ2V0QXBwQnVpbGRJZCgpKSB7XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgYnVpbGQgZG9lcyBub3QgbWF0Y2ggdGhlIGNsaWVudC4gVHJlYXQgYXMgYSA0MDQuIER1cmluZ1xuICAgICAgICAvLyBhbiBhY3R1YWwgbmF2aWdhdGlvbiwgdGhlIHJvdXRlciB3aWxsIHRyaWdnZXIgYW4gTVBBIG5hdmlnYXRpb24uXG4gICAgICAgIC8vIFRPRE86IENvbnNpZGVyIG1vdmluZyB0aGUgYnVpbGQgSUQgdG8gYSByZXNwb25zZSBoZWFkZXIgc28gd2UgY2FuIGNoZWNrXG4gICAgICAgIC8vIGl0IGJlZm9yZSBkZWNvZGluZyB0aGUgcmVzcG9uc2UsIGFuZCBzbyB0aGVyZSdzIG9uZSB3YXkgb2YgY2hlY2tpbmdcbiAgICAgICAgLy8gYWNyb3NzIGFsbCByZXNwb25zZSB0eXBlcy5cbiAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIGNhY2hlIHRoZSBmYWN0IHRoYXQgdGhpcyBpcyBhbiBNUEEgbmF2aWdhdGlvbi5cbiAgICAgICAgcmVqZWN0Um91dGVDYWNoZUVudHJ5KGVudHJ5LCBEYXRlLm5vdygpICsgMTAgKiAxMDAwKVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICB3cml0ZUR5bmFtaWNUcmVlUmVzcG9uc2VJbnRvQ2FjaGUoXG4gICAgICAgIERhdGUubm93KCksXG4gICAgICAgIHRhc2ssXG4gICAgICAgIC8vIFRoZSBub24tUFBSIHJlc3BvbnNlIGZvcm1hdCBpcyB3aGF0IHdlJ2QgZ2V0IGlmIHdlIHByZWZldGNoZWQgdGhlc2Ugc2VnbWVudHNcbiAgICAgICAgLy8gdXNpbmcgdGhlIExvYWRpbmdCb3VuZGFyeSBmZXRjaCBzdHJhdGVneSwgc28gbWFyayB0aGVpciBjYWNoZSBlbnRyaWVzIGFjY29yZGluZ2x5LlxuICAgICAgICBGZXRjaFN0cmF0ZWd5LkxvYWRpbmdCb3VuZGFyeSxcbiAgICAgICAgcmVzcG9uc2UgYXMgUlNDUmVzcG9uc2U8TmF2aWdhdGlvbkZsaWdodFJlc3BvbnNlPixcbiAgICAgICAgc2VydmVyRGF0YSxcbiAgICAgICAgZW50cnksXG4gICAgICAgIGNvdWxkQmVJbnRlcmNlcHRlZCxcbiAgICAgICAgY2Fub25pY2FsVXJsLFxuICAgICAgICByb3V0ZUlzUFBSRW5hYmxlZFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICghY291bGRCZUludGVyY2VwdGVkKSB7XG4gICAgICAvLyBUaGlzIHJvdXRlIHdpbGwgbmV2ZXIgYmUgaW50ZXJjZXB0ZWQuIFNvIHdlIGNhbiB1c2UgdGhpcyBlbnRyeSBmb3IgYWxsXG4gICAgICAvLyByZXF1ZXN0cyB0byB0aGlzIHJvdXRlLCByZWdhcmRsZXNzIG9mIHRoZSBOZXh0LVVybCBoZWFkZXIuIFRoaXMgd29ya3NcbiAgICAgIC8vIGJlY2F1c2Ugd2hlbiByZWFkaW5nIHRoZSBjYWNoZSB3ZSBhbHdheXMgY2hlY2sgZm9yIGEgdmFsaWRcbiAgICAgIC8vIG5vbi1pbnRlcmNlcHRlZCBlbnRyeSBmaXJzdC5cblxuICAgICAgLy8gUmUta2V5IHRoZSBlbnRyeS4gVGhlIGBzZXRgIGltcGxlbWVudGF0aW9uIGhhbmRsZXMgcmVtb3ZpbmcgaXQgZnJvbVxuICAgICAgLy8gaXRzIHByZXZpb3VzIHBvc2l0aW9uIGluIHRoZSBjYWNoZS4gV2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyB0b1xuICAgICAgLy8gdXBkYXRlIHRoZSBMUlUsIGJlY2F1c2UgdGhlIGVudHJ5IGlzIGFscmVhZHkgaW4gaXQuXG4gICAgICAvLyBUT0RPOiBUcmVhdCB0aGlzIGFzIGFuIHVwc2VydCDigJQgc2hvdWxkIGNoZWNrIGlmIGFuIGVudHJ5IGFscmVhZHlcbiAgICAgIC8vIGV4aXN0cyBhdCB0aGUgbmV3IGtleXBhdGgsIGFuZCBpZiBzbywgd2hldGhlciB3ZSBzaG91bGQga2VlcCB0aGF0XG4gICAgICAvLyBvbmUgaW5zdGVhZC5cbiAgICAgIGNvbnN0IGZ1bGZpbGxlZFZhcnlQYXRoOiBSb3V0ZVZhcnlQYXRoID0gZ2V0RnVsZmlsbGVkUm91dGVWYXJ5UGF0aChcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCxcbiAgICAgICAgbmV4dFVybCxcbiAgICAgICAgY291bGRCZUludGVyY2VwdGVkXG4gICAgICApXG4gICAgICBjb25zdCBpc1JldmFsaWRhdGlvbiA9IGZhbHNlXG4gICAgICBzZXRJbkNhY2hlTWFwKHJvdXRlQ2FjaGVNYXAsIGZ1bGZpbGxlZFZhcnlQYXRoLCBlbnRyeSwgaXNSZXZhbGlkYXRpb24pXG4gICAgfVxuICAgIC8vIFJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBuZXR3b3JrIGNvbm5lY3Rpb24gY2xvc2VzLCBzb1xuICAgIC8vIHRoZSBzY2hlZHVsZXIgY2FuIHRyYWNrIHRoZSBudW1iZXIgb2YgY29uY3VycmVudCBuZXR3b3JrIGNvbm5lY3Rpb25zLlxuICAgIHJldHVybiB7IHZhbHVlOiBudWxsLCBjbG9zZWQ6IGNsb3NlZC5wcm9taXNlIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBFaXRoZXIgdGhlIGNvbm5lY3Rpb24gaXRzZWxmIGZhaWxlZCwgb3Igc29tZXRoaW5nIGJhZCBoYXBwZW5lZCB3aGlsZVxuICAgIC8vIGRlY29kaW5nIHRoZSByZXNwb25zZS5cbiAgICByZWplY3RSb3V0ZUNhY2hlRW50cnkoZW50cnksIERhdGUubm93KCkgKyAxMCAqIDEwMDApXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hTZWdtZW50T25DYWNoZU1pc3MoXG4gIHJvdXRlOiBGdWxmaWxsZWRSb3V0ZUNhY2hlRW50cnksXG4gIHNlZ21lbnRDYWNoZUVudHJ5OiBQZW5kaW5nU2VnbWVudENhY2hlRW50cnksXG4gIHJvdXRlS2V5OiBSb3V0ZUNhY2hlS2V5LFxuICB0cmVlOiBSb3V0ZVRyZWVcbik6IFByb21pc2U8UHJlZmV0Y2hTdWJ0YXNrUmVzdWx0PEZ1bGZpbGxlZFNlZ21lbnRDYWNoZUVudHJ5PiB8IG51bGw+IHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBhbGxvd2VkIHRvIHVzZSBhc3luYy9hd2FpdCBiZWNhdXNlIGl0IGNvbnRhaW5zIHRoZSBhY3R1YWxcbiAgLy8gZmV0Y2ggdGhhdCBnZXRzIGlzc3VlZCBvbiBhIGNhY2hlIG1pc3MuIE5vdGljZSBpdCB3cml0ZXMgdGhlIHJlc3VsdCB0byB0aGVcbiAgLy8gY2FjaGUgZW50cnkgZGlyZWN0bHksIHJhdGhlciB0aGFuIHJldHVybiBkYXRhIHRoYXQgaXMgdGhlbiB3cml0dGVuIGJ5XG4gIC8vIHRoZSBjYWxsZXIuXG4gIC8vXG4gIC8vIFNlZ21lbnQgZmV0Y2hlcyBhcmUgbm9uLWJsb2NraW5nIHNvIHdlIGRvbid0IG5lZWQgdG8gcGluZyB0aGUgc2NoZWR1bGVyXG4gIC8vIG9uIGNvbXBsZXRpb24uXG5cbiAgLy8gVXNlIHRoZSBjYW5vbmljYWwgVVJMIHRvIHJlcXVlc3QgdGhlIHNlZ21lbnQsIG5vdCB0aGUgb3JpZ2luYWwgVVJMLiBUaGVzZVxuICAvLyBhcmUgdXN1YWxseSB0aGUgc2FtZSwgYnV0IHRoZSBjYW5vbmljYWwgVVJMIHdpbGwgYmUgZGlmZmVyZW50IGlmIHRoZSByb3V0ZVxuICAvLyB0cmVlIHJlc3BvbnNlIHdhcyByZWRpcmVjdGVkLiBUbyBhdm9pZCBhbiBleHRyYSB3YXRlcmZhbGwgb24gZXZlcnkgc2VnbWVudFxuICAvLyByZXF1ZXN0LCB3ZSBwYXNzIHRoZSByZWRpcmVjdGVkIFVSTCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBvbmUuXG4gIGNvbnN0IHVybCA9IG5ldyBVUkwocm91dGUuY2Fub25pY2FsVXJsLCBsb2NhdGlvbi5vcmlnaW4pXG4gIGNvbnN0IG5leHRVcmwgPSByb3V0ZUtleS5uZXh0VXJsXG5cbiAgY29uc3QgcmVxdWVzdEtleSA9IHRyZWUucmVxdWVzdEtleVxuICBjb25zdCBub3JtYWxpemVkUmVxdWVzdEtleSA9XG4gICAgcmVxdWVzdEtleSA9PT0gUk9PVF9TRUdNRU5UX1JFUVVFU1RfS0VZXG4gICAgICA/IC8vIFRoZSByb290IHNlZ21lbnQgaXMgYSBzcGVjaWFsIGNhc2UuIFRvIHNpbXBsaWZ5IHRoZSBzZXJ2ZXItc2lkZVxuICAgICAgICAvLyBoYW5kbGluZyBvZiB0aGVzZSByZXF1ZXN0cywgd2UgZW5jb2RlIHRoZSByb290IHNlZ21lbnQgcGF0aCBhc1xuICAgICAgICAvLyBgX2luZGV4YCBpbnN0ZWFkIG9mIGFzIGFuIGVtcHR5IHN0cmluZy4gVGhpcyBzaG91bGQgYmUgdHJlYXRlZCBhc1xuICAgICAgICAvLyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgYW5kIG5vdCBhcyBhIHN0YWJsZSBwYXJ0IG9mIHRoZSBwcm90b2NvbC5cbiAgICAgICAgLy8gSXQganVzdCBuZWVkcyB0byBtYXRjaCB0aGUgZXF1aXZhbGVudCBsb2dpYyB0aGF0IGhhcHBlbnMgd2hlblxuICAgICAgICAvLyBwcmVyZW5kZXJpbmcgdGhlIHJlc3BvbnNlcy4gSXQgc2hvdWxkIG5vdCBsZWFrIG91dHNpZGUgb2YgTmV4dC5qcy5cbiAgICAgICAgKCcvX2luZGV4JyBhcyBTZWdtZW50UmVxdWVzdEtleSlcbiAgICAgIDogcmVxdWVzdEtleVxuXG4gIGNvbnN0IGhlYWRlcnM6IFJlcXVlc3RIZWFkZXJzID0ge1xuICAgIFtSU0NfSEVBREVSXTogJzEnLFxuICAgIFtORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVJdOiAnMScsXG4gICAgW05FWFRfUk9VVEVSX1NFR01FTlRfUFJFRkVUQ0hfSEVBREVSXTogbm9ybWFsaXplZFJlcXVlc3RLZXksXG4gIH1cbiAgaWYgKG5leHRVcmwgIT09IG51bGwpIHtcbiAgICBoZWFkZXJzW05FWFRfVVJMXSA9IG5leHRVcmxcbiAgfVxuXG4gIGNvbnN0IHJlcXVlc3RVcmwgPSBpc091dHB1dEV4cG9ydE1vZGVcbiAgICA/IC8vIEluIG91dHB1dDogXCJleHBvcnRcIiBtb2RlLCB3ZSBuZWVkIHRvIGFkZCB0aGUgc2VnbWVudCBwYXRoIHRvIHRoZSBVUkwuXG4gICAgICBhZGRTZWdtZW50UGF0aFRvVXJsSW5PdXRwdXRFeHBvcnRNb2RlKHVybCwgbm9ybWFsaXplZFJlcXVlc3RLZXkpXG4gICAgOiB1cmxcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoUHJlZmV0Y2hSZXNwb25zZShyZXF1ZXN0VXJsLCBoZWFkZXJzKVxuICAgIGlmIChcbiAgICAgICFyZXNwb25zZSB8fFxuICAgICAgIXJlc3BvbnNlLm9rIHx8XG4gICAgICByZXNwb25zZS5zdGF0dXMgPT09IDIwNCB8fCAvLyBDYWNoZSBtaXNzXG4gICAgICAvLyBUaGlzIGNoZWNrcyB3aGV0aGVyIHRoZSByZXNwb25zZSB3YXMgc2VydmVkIGZyb20gdGhlIHBlci1zZWdtZW50IGNhY2hlLFxuICAgICAgLy8gcmF0aGVyIHRoYW4gdGhlIG9sZCBwcmVmZXRjaGluZyBmbG93LiBJZiBpdCBmYWlscywgaXQgaW1wbGllcyB0aGF0IFBQUlxuICAgICAgLy8gaXMgZGlzYWJsZWQgb24gdGhpcyByb3V0ZS4gVGhlb3JldGljYWxseSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgIC8vIGJlY2F1c2Ugd2Ugb25seSBpc3N1ZSByZXF1ZXN0cyBmb3Igc2VnbWVudHMgb25jZSB3ZSd2ZSB2ZXJpZmllZCB0aGF0XG4gICAgICAvLyB0aGUgcm91dGUgc3VwcG9ydHMgUFBSLlxuICAgICAgKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KE5FWFRfRElEX1BPU1RQT05FX0hFQURFUikgIT09ICcyJyAmJlxuICAgICAgICAvLyBJbiBvdXRwdXQ6IFwiZXhwb3J0XCIgbW9kZSwgd2UgY2FuJ3QgcmVseSBvbiByZXNwb25zZSBoZWFkZXJzLiBCdXQgaWZcbiAgICAgICAgLy8gd2UgcmVjZWl2ZSBhIHdlbGwtZm9ybWVkIHJlc3BvbnNlLCB3ZSBjYW4gYXNzdW1lIGl0J3MgYSBzdGF0aWNcbiAgICAgICAgLy8gcmVzcG9uc2UsIGJlY2F1c2UgYWxsIGRhdGEgaXMgc3RhdGljIGluIHRoaXMgbW9kZS5cbiAgICAgICAgIWlzT3V0cHV0RXhwb3J0TW9kZSkgfHxcbiAgICAgICFyZXNwb25zZS5ib2R5XG4gICAgKSB7XG4gICAgICAvLyBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYW4gZXJyb3IsIG9yIHdpdGggYSBtaXNzLiBXZSBzaG91bGQgc3RpbGwgY2FjaGVcbiAgICAgIC8vIHRoZSByZXNwb25zZSwgYnV0IHdlIGNhbiB0cnkgYWdhaW4gYWZ0ZXIgMTAgc2Vjb25kcy5cbiAgICAgIHJlamVjdFNlZ21lbnRDYWNoZUVudHJ5KHNlZ21lbnRDYWNoZUVudHJ5LCBEYXRlLm5vdygpICsgMTAgKiAxMDAwKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyBUcmFjayB3aGVuIHRoZSBuZXR3b3JrIGNvbm5lY3Rpb24gY2xvc2VzLlxuICAgIGNvbnN0IGNsb3NlZCA9IGNyZWF0ZVByb21pc2VXaXRoUmVzb2x2ZXJzPHZvaWQ+KClcblxuICAgIC8vIFdyYXAgdGhlIG9yaWdpbmFsIHN0cmVhbSBpbiBhIG5ldyBzdHJlYW0gdGhhdCBuZXZlciBjbG9zZXMuIFRoYXQgd2F5IHRoZVxuICAgIC8vIEZsaWdodCBjbGllbnQgZG9lc24ndCBlcnJvciBpZiB0aGVyZSdzIGEgaGFuZ2luZyBwcm9taXNlLlxuICAgIGNvbnN0IHByZWZldGNoU3RyZWFtID0gY3JlYXRlUHJlZmV0Y2hSZXNwb25zZVN0cmVhbShcbiAgICAgIHJlc3BvbnNlLmJvZHksXG4gICAgICBjbG9zZWQucmVzb2x2ZSxcbiAgICAgIGZ1bmN0aW9uIG9uUmVzcG9uc2VTaXplVXBkYXRlKHNpemUpIHtcbiAgICAgICAgc2V0U2l6ZUluQ2FjaGVNYXAoc2VnbWVudENhY2hlRW50cnksIHNpemUpXG4gICAgICB9XG4gICAgKVxuICAgIGNvbnN0IHNlcnZlckRhdGEgPSBhd2FpdCAoY3JlYXRlRnJvbU5leHRSZWFkYWJsZVN0cmVhbShcbiAgICAgIHByZWZldGNoU3RyZWFtLFxuICAgICAgaGVhZGVyc1xuICAgICkgYXMgUHJvbWlzZTxTZWdtZW50UHJlZmV0Y2g+KVxuICAgIGlmIChzZXJ2ZXJEYXRhLmJ1aWxkSWQgIT09IGdldEFwcEJ1aWxkSWQoKSkge1xuICAgICAgLy8gVGhlIHNlcnZlciBidWlsZCBkb2VzIG5vdCBtYXRjaCB0aGUgY2xpZW50LiBUcmVhdCBhcyBhIDQwNC4gRHVyaW5nXG4gICAgICAvLyBhbiBhY3R1YWwgbmF2aWdhdGlvbiwgdGhlIHJvdXRlciB3aWxsIHRyaWdnZXIgYW4gTVBBIG5hdmlnYXRpb24uXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciBtb3ZpbmcgdGhlIGJ1aWxkIElEIHRvIGEgcmVzcG9uc2UgaGVhZGVyIHNvIHdlIGNhbiBjaGVja1xuICAgICAgLy8gaXQgYmVmb3JlIGRlY29kaW5nIHRoZSByZXNwb25zZSwgYW5kIHNvIHRoZXJlJ3Mgb25lIHdheSBvZiBjaGVja2luZ1xuICAgICAgLy8gYWNyb3NzIGFsbCByZXNwb25zZSB0eXBlcy5cbiAgICAgIHJlamVjdFNlZ21lbnRDYWNoZUVudHJ5KHNlZ21lbnRDYWNoZUVudHJ5LCBEYXRlLm5vdygpICsgMTAgKiAxMDAwKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBmdWxmaWxsU2VnbWVudENhY2hlRW50cnkoXG4gICAgICAgIHNlZ21lbnRDYWNoZUVudHJ5LFxuICAgICAgICBzZXJ2ZXJEYXRhLnJzYyxcbiAgICAgICAgc2VydmVyRGF0YS5sb2FkaW5nLFxuICAgICAgICAvLyBUT0RPOiBUaGUgc2VydmVyIGRvZXMgbm90IGN1cnJlbnRseSBwcm92aWRlIHBlci1zZWdtZW50IHN0YWxlIHRpbWUuXG4gICAgICAgIC8vIFNvIHdlIHVzZSB0aGUgc3RhbGUgdGltZSBvZiB0aGUgcm91dGUuXG4gICAgICAgIHJvdXRlLnN0YWxlQXQsXG4gICAgICAgIHNlcnZlckRhdGEuaXNQYXJ0aWFsXG4gICAgICApLFxuICAgICAgLy8gUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIG5ldHdvcmsgY29ubmVjdGlvbiBjbG9zZXMsIHNvXG4gICAgICAvLyB0aGUgc2NoZWR1bGVyIGNhbiB0cmFjayB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgbmV0d29yayBjb25uZWN0aW9ucy5cbiAgICAgIGNsb3NlZDogY2xvc2VkLnByb21pc2UsXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIEVpdGhlciB0aGUgY29ubmVjdGlvbiBpdHNlbGYgZmFpbGVkLCBvciBzb21ldGhpbmcgYmFkIGhhcHBlbmVkIHdoaWxlXG4gICAgLy8gZGVjb2RpbmcgdGhlIHJlc3BvbnNlLlxuICAgIHJlamVjdFNlZ21lbnRDYWNoZUVudHJ5KHNlZ21lbnRDYWNoZUVudHJ5LCBEYXRlLm5vdygpICsgMTAgKiAxMDAwKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoU2VnbWVudFByZWZldGNoZXNVc2luZ0R5bmFtaWNSZXF1ZXN0KFxuICB0YXNrOiBQcmVmZXRjaFRhc2ssXG4gIHJvdXRlOiBGdWxmaWxsZWRSb3V0ZUNhY2hlRW50cnksXG4gIGZldGNoU3RyYXRlZ3k6XG4gICAgfCBGZXRjaFN0cmF0ZWd5LkxvYWRpbmdCb3VuZGFyeVxuICAgIHwgRmV0Y2hTdHJhdGVneS5QUFJSdW50aW1lXG4gICAgfCBGZXRjaFN0cmF0ZWd5LkZ1bGwsXG4gIGR5bmFtaWNSZXF1ZXN0VHJlZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIHNwYXduZWRFbnRyaWVzOiBNYXA8U2VnbWVudFJlcXVlc3RLZXksIFBlbmRpbmdTZWdtZW50Q2FjaGVFbnRyeT5cbik6IFByb21pc2U8UHJlZmV0Y2hTdWJ0YXNrUmVzdWx0PG51bGw+IHwgbnVsbD4ge1xuICBjb25zdCBrZXkgPSB0YXNrLmtleVxuICBjb25zdCB1cmwgPSBuZXcgVVJMKHJvdXRlLmNhbm9uaWNhbFVybCwgbG9jYXRpb24ub3JpZ2luKVxuICBjb25zdCBuZXh0VXJsID0ga2V5Lm5leHRVcmxcblxuICBpZiAoXG4gICAgc3Bhd25lZEVudHJpZXMuc2l6ZSA9PT0gMSAmJlxuICAgIHNwYXduZWRFbnRyaWVzLmhhcyhyb3V0ZS5tZXRhZGF0YS5yZXF1ZXN0S2V5KVxuICApIHtcbiAgICAvLyBUaGUgb25seSB0aGluZyBwZW5kaW5nIGlzIHRoZSBoZWFkLiBJbnN0cnVjdCB0aGUgc2VydmVyIHRvXG4gICAgLy8gc2tpcCBvdmVyIGV2ZXJ5dGhpbmcgZWxzZS5cbiAgICBkeW5hbWljUmVxdWVzdFRyZWUgPSBNZXRhZGF0YU9ubHlSZXF1ZXN0VHJlZVxuICB9XG5cbiAgY29uc3QgaGVhZGVyczogUmVxdWVzdEhlYWRlcnMgPSB7XG4gICAgW1JTQ19IRUFERVJdOiAnMScsXG4gICAgW05FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSXTpcbiAgICAgIHByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QoZHluYW1pY1JlcXVlc3RUcmVlKSxcbiAgfVxuICBpZiAobmV4dFVybCAhPT0gbnVsbCkge1xuICAgIGhlYWRlcnNbTkVYVF9VUkxdID0gbmV4dFVybFxuICB9XG4gIHN3aXRjaCAoZmV0Y2hTdHJhdGVneSkge1xuICAgIGNhc2UgRmV0Y2hTdHJhdGVneS5GdWxsOiB7XG4gICAgICAvLyBXZSBvbWl0IHRoZSBwcmVmZXRjaCBoZWFkZXIgZnJvbSBhIGZ1bGwgcHJlZmV0Y2ggYmVjYXVzZSBpdCdzIGVzc2VudGlhbGx5XG4gICAgICAvLyBqdXN0IGEgbmF2aWdhdGlvbiByZXF1ZXN0IHRoYXQgaGFwcGVucyBhaGVhZCBvZiB0aW1lIOKAlCBpdCBzaG91bGQgaW5jbHVkZVxuICAgICAgLy8gYWxsIHRoZSBzYW1lIGRhdGEgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSBGZXRjaFN0cmF0ZWd5LlBQUlJ1bnRpbWU6IHtcbiAgICAgIGhlYWRlcnNbTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSXSA9ICcyJ1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSBGZXRjaFN0cmF0ZWd5LkxvYWRpbmdCb3VuZGFyeToge1xuICAgICAgaGVhZGVyc1tORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVJdID0gJzEnXG4gICAgICBicmVha1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBmZXRjaFN0cmF0ZWd5IHNhdGlzZmllcyBuZXZlclxuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFByZWZldGNoUmVzcG9uc2UodXJsLCBoZWFkZXJzKVxuICAgIGlmICghcmVzcG9uc2UgfHwgIXJlc3BvbnNlLm9rIHx8ICFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAvLyBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYW4gZXJyb3IsIG9yIHdpdGggYSBtaXNzLiBXZSBzaG91bGQgc3RpbGwgY2FjaGVcbiAgICAgIC8vIHRoZSByZXNwb25zZSwgYnV0IHdlIGNhbiB0cnkgYWdhaW4gYWZ0ZXIgMTAgc2Vjb25kcy5cbiAgICAgIHJlamVjdFNlZ21lbnRFbnRyaWVzSWZTdGlsbFBlbmRpbmcoc3Bhd25lZEVudHJpZXMsIERhdGUubm93KCkgKyAxMCAqIDEwMDApXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IHJlbmRlcmVkU2VhcmNoID0gZ2V0UmVuZGVyZWRTZWFyY2gocmVzcG9uc2UpXG4gICAgaWYgKHJlbmRlcmVkU2VhcmNoICE9PSByb3V0ZS5yZW5kZXJlZFNlYXJjaCkge1xuICAgICAgLy8gVGhlIHNlYXJjaCBwYXJhbXMgdGhhdCB3ZXJlIHVzZWQgdG8gcmVuZGVyIHRoZSB0YXJnZXQgcGFnZSBhcmVcbiAgICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBzZWFyY2ggcGFyYW1zIGluIHRoZSByZXF1ZXN0IFVSTC4gVGhpcyBvbmx5IGhhcHBlbnNcbiAgICAgIC8vIHdoZW4gdGhlcmUncyBhIGR5bmFtaWMgcmV3cml0ZSBpbiBiZXR3ZWVuIHRoZSB0cmVlIHByZWZldGNoIGFuZCB0aGVcbiAgICAgIC8vIGRhdGEgcHJlZmV0Y2guXG4gICAgICAvLyBUT0RPOiBGb3Igbm93LCBzaW5jZSB0aGlzIGlzIGFuIGVkZ2UgY2FzZSwgd2UgcmVqZWN0IHRoZSBwcmVmZXRjaCwgYnV0XG4gICAgICAvLyB0aGUgcHJvcGVyIHdheSB0byBoYW5kbGUgdGhpcyBpcyB0byBldmljdCB0aGUgc3RhbGUgcm91dGUgdHJlZSBlbnRyeVxuICAgICAgLy8gdGhlbiBmaWxsIHRoZSBjYWNoZSB3aXRoIHRoZSBuZXcgcmVzcG9uc2UuXG4gICAgICByZWplY3RTZWdtZW50RW50cmllc0lmU3RpbGxQZW5kaW5nKHNwYXduZWRFbnRyaWVzLCBEYXRlLm5vdygpICsgMTAgKiAxMDAwKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyBUcmFjayB3aGVuIHRoZSBuZXR3b3JrIGNvbm5lY3Rpb24gY2xvc2VzLlxuICAgIGNvbnN0IGNsb3NlZCA9IGNyZWF0ZVByb21pc2VXaXRoUmVzb2x2ZXJzPHZvaWQ+KClcblxuICAgIGxldCBmdWxmaWxsZWRFbnRyaWVzOiBBcnJheTxGdWxmaWxsZWRTZWdtZW50Q2FjaGVFbnRyeT4gfCBudWxsID0gbnVsbFxuICAgIGNvbnN0IHByZWZldGNoU3RyZWFtID0gY3JlYXRlUHJlZmV0Y2hSZXNwb25zZVN0cmVhbShcbiAgICAgIHJlc3BvbnNlLmJvZHksXG4gICAgICBjbG9zZWQucmVzb2x2ZSxcbiAgICAgIGZ1bmN0aW9uIG9uUmVzcG9uc2VTaXplVXBkYXRlKHRvdGFsQnl0ZXNSZWNlaXZlZFNvRmFyKSB7XG4gICAgICAgIC8vIFdoZW4gcHJvY2Vzc2luZyBhIGR5bmFtaWMgcmVzcG9uc2UsIHdlIGRvbid0IGtub3cgaG93IGxhcmdlIGVhY2hcbiAgICAgICAgLy8gaW5kaXZpZHVhbCBzZWdtZW50IGlzLCBzbyBhcHByb3hpbWF0ZSBieSBhc3NpZ2luZyBlYWNoIHNlZ21lbnRcbiAgICAgICAgLy8gdGhlIGF2ZXJhZ2Ugb2YgdGhlIHRvdGFsIHJlc3BvbnNlIHNpemUuXG4gICAgICAgIGlmIChmdWxmaWxsZWRFbnRyaWVzID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSGF2ZW4ndCByZWNlaXZlZCBlbm91Z2ggZGF0YSB5ZXQgdG8ga25vdyB3aGljaCBzZWdtZW50c1xuICAgICAgICAgIC8vIHdlcmUgaW5jbHVkZWQuXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXZlcmFnZVNpemUgPSB0b3RhbEJ5dGVzUmVjZWl2ZWRTb0ZhciAvIGZ1bGZpbGxlZEVudHJpZXMubGVuZ3RoXG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZnVsZmlsbGVkRW50cmllcykge1xuICAgICAgICAgIHNldFNpemVJbkNhY2hlTWFwKGVudHJ5LCBhdmVyYWdlU2l6ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcbiAgICBjb25zdCBzZXJ2ZXJEYXRhID0gYXdhaXQgKGNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0oXG4gICAgICBwcmVmZXRjaFN0cmVhbSxcbiAgICAgIGhlYWRlcnNcbiAgICApIGFzIFByb21pc2U8TmF2aWdhdGlvbkZsaWdodFJlc3BvbnNlPilcblxuICAgIGNvbnN0IGlzUmVzcG9uc2VQYXJ0aWFsID1cbiAgICAgIGZldGNoU3RyYXRlZ3kgPT09IEZldGNoU3RyYXRlZ3kuUFBSUnVudGltZVxuICAgICAgICA/IC8vIEEgcnVudGltZSBwcmVmZXRjaCBtYXkgaGF2ZSBob2xlcy5cbiAgICAgICAgICBzZXJ2ZXJEYXRhLnJwPy5bMF0gPT09IHRydWVcbiAgICAgICAgOiAvLyBGdWxsIGFuZCBMb2FkaW5nQm91bmRhcnkgcHJlZmV0Y2hlcyBjYW5ub3QgaGF2ZSBob2xlcy5cbiAgICAgICAgICAvLyAoZXZlbiBpZiB3ZSBkaWQgc2V0IHRoZSBwcmVmZXRjaCBoZWFkZXIsIHdlIG9ubHkgdXNlIHRoaXMgY29kZXBhdGggZm9yIG5vbi1QUFItZW5hYmxlZCByb3V0ZXMpXG4gICAgICAgICAgZmFsc2VcblxuICAgIC8vIEFzaWRlIGZyb20gd3JpdGluZyB0aGUgZGF0YSBpbnRvIHRoZSBjYWNoZSwgdGhpcyBmdW5jdGlvbiBhbHNvIHJldHVybnNcbiAgICAvLyB0aGUgZW50cmllcyB0aGF0IHdlcmUgZnVsZmlsbGVkLCBzbyB3ZSBjYW4gc3RyZWFtaW5nbHkgdXBkYXRlIHRoZWlyIHNpemVzXG4gICAgLy8gaW4gdGhlIExSVSBhcyBtb3JlIGRhdGEgY29tZXMgaW4uXG4gICAgZnVsZmlsbGVkRW50cmllcyA9IHdyaXRlRHluYW1pY1JlbmRlclJlc3BvbnNlSW50b0NhY2hlKFxuICAgICAgRGF0ZS5ub3coKSxcbiAgICAgIHRhc2ssXG4gICAgICBmZXRjaFN0cmF0ZWd5LFxuICAgICAgcmVzcG9uc2UgYXMgUlNDUmVzcG9uc2U8TmF2aWdhdGlvbkZsaWdodFJlc3BvbnNlPixcbiAgICAgIHNlcnZlckRhdGEsXG4gICAgICBpc1Jlc3BvbnNlUGFydGlhbCxcbiAgICAgIHJvdXRlLFxuICAgICAgc3Bhd25lZEVudHJpZXNcbiAgICApXG5cbiAgICAvLyBSZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgbmV0d29yayBjb25uZWN0aW9uIGNsb3Nlcywgc29cbiAgICAvLyB0aGUgc2NoZWR1bGVyIGNhbiB0cmFjayB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgbmV0d29yayBjb25uZWN0aW9ucy5cbiAgICByZXR1cm4geyB2YWx1ZTogbnVsbCwgY2xvc2VkOiBjbG9zZWQucHJvbWlzZSB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0U2VnbWVudEVudHJpZXNJZlN0aWxsUGVuZGluZyhzcGF3bmVkRW50cmllcywgRGF0ZS5ub3coKSArIDEwICogMTAwMClcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlRHluYW1pY1RyZWVSZXNwb25zZUludG9DYWNoZShcbiAgbm93OiBudW1iZXIsXG4gIHRhc2s6IFByZWZldGNoVGFzayxcbiAgZmV0Y2hTdHJhdGVneTpcbiAgICB8IEZldGNoU3RyYXRlZ3kuTG9hZGluZ0JvdW5kYXJ5XG4gICAgfCBGZXRjaFN0cmF0ZWd5LlBQUlJ1bnRpbWVcbiAgICB8IEZldGNoU3RyYXRlZ3kuRnVsbCxcbiAgcmVzcG9uc2U6IFJTQ1Jlc3BvbnNlPE5hdmlnYXRpb25GbGlnaHRSZXNwb25zZT4sXG4gIHNlcnZlckRhdGE6IE5hdmlnYXRpb25GbGlnaHRSZXNwb25zZSxcbiAgZW50cnk6IFBlbmRpbmdSb3V0ZUNhY2hlRW50cnksXG4gIGNvdWxkQmVJbnRlcmNlcHRlZDogYm9vbGVhbixcbiAgY2Fub25pY2FsVXJsOiBzdHJpbmcsXG4gIHJvdXRlSXNQUFJFbmFibGVkOiBib29sZWFuXG4pIHtcbiAgLy8gR2V0IHRoZSBVUkwgdGhhdCB3YXMgdXNlZCB0byByZW5kZXIgdGhlIHRhcmdldCBwYWdlLiBUaGlzIG1heSBiZSBkaWZmZXJlbnRcbiAgLy8gZnJvbSB0aGUgVVJMIGluIHRoZSByZXF1ZXN0IFVSTCwgaWYgdGhlIHBhZ2Ugd2FzIHJld3JpdHRlbi5cbiAgY29uc3QgcmVuZGVyZWRTZWFyY2ggPSBnZXRSZW5kZXJlZFNlYXJjaChyZXNwb25zZSlcblxuICBjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YVJlc3VsdCA9IG5vcm1hbGl6ZUZsaWdodERhdGEoc2VydmVyRGF0YS5mKVxuICBpZiAoXG4gICAgLy8gQSBzdHJpbmcgcmVzdWx0IG1lYW5zIG5hdmlnYXRpbmcgdG8gdGhpcyByb3V0ZSB3aWxsIHJlc3VsdCBpbiBhblxuICAgIC8vIE1QQSBuYXZpZ2F0aW9uLlxuICAgIHR5cGVvZiBub3JtYWxpemVkRmxpZ2h0RGF0YVJlc3VsdCA9PT0gJ3N0cmluZycgfHxcbiAgICBub3JtYWxpemVkRmxpZ2h0RGF0YVJlc3VsdC5sZW5ndGggIT09IDFcbiAgKSB7XG4gICAgcmVqZWN0Um91dGVDYWNoZUVudHJ5KGVudHJ5LCBub3cgKyAxMCAqIDEwMDApXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgZmxpZ2h0RGF0YSA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhUmVzdWx0WzBdXG4gIGlmICghZmxpZ2h0RGF0YS5pc1Jvb3RSZW5kZXIpIHtcbiAgICAvLyBVbmV4cGVjdGVkIHJlc3BvbnNlIGZvcm1hdC5cbiAgICByZWplY3RSb3V0ZUNhY2hlRW50cnkoZW50cnksIG5vdyArIDEwICogMTAwMClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGZsaWdodFJvdXRlclN0YXRlID0gZmxpZ2h0RGF0YS50cmVlXG4gIC8vIEZvciBydW50aW1lIHByZWZldGNoZXMsIHN0YWxlIHRpbWUgaXMgaW4gdGhlIHBheWxvYWQgYXQgcnBbMV0uXG4gIC8vIEZvciBvdGhlciByZXNwb25zZXMsIGZhbGwgYmFjayB0byB0aGUgaGVhZGVyLlxuICBjb25zdCBzdGFsZVRpbWVTZWNvbmRzID1cbiAgICB0eXBlb2Ygc2VydmVyRGF0YS5ycD8uWzFdID09PSAnbnVtYmVyJ1xuICAgICAgPyBzZXJ2ZXJEYXRhLnJwWzFdXG4gICAgICA6IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KE5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSKSA/PyAnJywgMTApXG4gIGNvbnN0IHN0YWxlVGltZU1zID0gIWlzTmFOKHN0YWxlVGltZVNlY29uZHMpXG4gICAgPyBnZXRTdGFsZVRpbWVNcyhzdGFsZVRpbWVTZWNvbmRzKVxuICAgIDogU1RBVElDX1NUQUxFVElNRV9NU1xuXG4gIC8vIElmIHRoZSByZXNwb25zZSBjb250YWlucyBkeW5hbWljIGhvbGVzLCB0aGVuIHdlIG11c3QgY29uc2VydmF0aXZlbHkgYXNzdW1lXG4gIC8vIHRoYXQgYW55IGluZGl2aWR1YWwgc2VnbWVudCBtaWdodCBjb250YWluIGR5bmFtaWMgaG9sZXMsIGFuZCBhbHNvIHRoZVxuICAvLyBoZWFkLiBJZiBpdCBkaWQgbm90IGNvbnRhaW4gZHluYW1pYyBob2xlcywgdGhlbiB3ZSBjYW4gYXNzdW1lIGV2ZXJ5IHNlZ21lbnRcbiAgLy8gYW5kIHRoZSBoZWFkIGlzIGNvbXBsZXRlbHkgc3RhdGljLlxuICBjb25zdCBpc1Jlc3BvbnNlUGFydGlhbCA9XG4gICAgcmVzcG9uc2UuaGVhZGVycy5nZXQoTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSKSA9PT0gJzEnXG5cbiAgLy8gQ29udmVydCB0aGUgc2VydmVyLXNlbnQgZGF0YSBpbnRvIHRoZSBSb3V0ZVRyZWUgZm9ybWF0IHVzZWQgYnkgdGhlXG4gIC8vIGNsaWVudCBjYWNoZS5cbiAgLy9cbiAgLy8gRHVyaW5nIHRoaXMgdHJhdmVyc2FsLCB3ZSBhY2N1bXVsYXRlIGFkZGl0aW9uYWwgZGF0YSBpbnRvIHRoaXNcbiAgLy8gXCJhY2N1bXVsYXRvclwiIG9iamVjdC5cbiAgY29uc3QgYWNjOiBSb3V0ZVRyZWVBY2N1bXVsYXRvciA9IHsgbWV0YWRhdGFWYXJ5UGF0aDogbnVsbCB9XG4gIGNvbnN0IHJvdXRlVHJlZSA9IGNvbnZlcnRSb290RmxpZ2h0Um91dGVyU3RhdGVUb1JvdXRlVHJlZShcbiAgICBmbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgICByZW5kZXJlZFNlYXJjaCxcbiAgICBhY2NcbiAgKVxuICBjb25zdCBtZXRhZGF0YVZhcnlQYXRoID0gYWNjLm1ldGFkYXRhVmFyeVBhdGhcbiAgaWYgKG1ldGFkYXRhVmFyeVBhdGggPT09IG51bGwpIHtcbiAgICByZWplY3RSb3V0ZUNhY2hlRW50cnkoZW50cnksIG5vdyArIDEwICogMTAwMClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGZ1bGZpbGxlZEVudHJ5ID0gZnVsZmlsbFJvdXRlQ2FjaGVFbnRyeShcbiAgICBlbnRyeSxcbiAgICByb3V0ZVRyZWUsXG4gICAgbWV0YWRhdGFWYXJ5UGF0aCxcbiAgICBub3cgKyBzdGFsZVRpbWVNcyxcbiAgICBjb3VsZEJlSW50ZXJjZXB0ZWQsXG4gICAgY2Fub25pY2FsVXJsLFxuICAgIHJlbmRlcmVkU2VhcmNoLFxuICAgIHJvdXRlSXNQUFJFbmFibGVkXG4gIClcblxuICAvLyBJZiB0aGUgc2VydmVyIHNlbnQgc2VnbWVudCBkYXRhIGFzIHBhcnQgb2YgdGhlIHJlc3BvbnNlLCB3ZSBzaG91bGQgd3JpdGVcbiAgLy8gaXQgaW50byB0aGUgY2FjaGUgdG8gcHJldmVudCBhIHNlY29uZCwgcmVkdW5kYW50IHByZWZldGNoIHJlcXVlc3QuXG4gIC8vXG4gIC8vIFRPRE86IFdoZW4gYGNsaWVudFNlZ21lbnRDYWNoZWAgaXMgZW5hYmxlZCwgdGhlIHNlcnZlciBkb2VzIG5vdCBpbmNsdWRlXG4gIC8vIHNlZ21lbnQgZGF0YSB3aGVuIHJlc3BvbmRpbmcgdG8gYSByb3V0ZSB0cmVlIHByZWZldGNoIHJlcXVlc3QuIEhvd2V2ZXIsXG4gIC8vIHdoZW4gYGNsaWVudFNlZ21lbnRDYWNoZWAgaXMgc2V0IHRvIFwiY2xpZW50LW9ubHlcIiwgYW5kIFBQUiBpcyBlbmFibGVkIChvclxuICAvLyB0aGUgcGFnZSBpcyBmdWxseSBzdGF0aWMpLCB0aGUgbm9ybWFsIGNoZWNrIGlzIGJ5cGFzc2VkIGFuZCB0aGUgc2VydmVyXG4gIC8vIHJlc3BvbmRzIHdpdGggdGhlIGZ1bGwgcGFnZS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzaXR1YXRpb24gdW50aWwgd2UgY2FuXG4gIC8vIHJlbW92ZSB0aGUgXCJjbGllbnQtb25seVwiIG9wdGlvbi4gVGhlbiwgd2UgY2FuIGRlbGV0ZSB0aGlzIGZ1bmN0aW9uIGNhbGwuXG4gIHdyaXRlRHluYW1pY1JlbmRlclJlc3BvbnNlSW50b0NhY2hlKFxuICAgIG5vdyxcbiAgICB0YXNrLFxuICAgIGZldGNoU3RyYXRlZ3ksXG4gICAgcmVzcG9uc2UsXG4gICAgc2VydmVyRGF0YSxcbiAgICBpc1Jlc3BvbnNlUGFydGlhbCxcbiAgICBmdWxmaWxsZWRFbnRyeSxcbiAgICBudWxsXG4gIClcbn1cblxuZnVuY3Rpb24gcmVqZWN0U2VnbWVudEVudHJpZXNJZlN0aWxsUGVuZGluZyhcbiAgZW50cmllczogTWFwPFNlZ21lbnRSZXF1ZXN0S2V5LCBTZWdtZW50Q2FjaGVFbnRyeT4sXG4gIHN0YWxlQXQ6IG51bWJlclxuKTogQXJyYXk8RnVsZmlsbGVkU2VnbWVudENhY2hlRW50cnk+IHtcbiAgY29uc3QgZnVsZmlsbGVkRW50cmllcyA9IFtdXG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcy52YWx1ZXMoKSkge1xuICAgIGlmIChlbnRyeS5zdGF0dXMgPT09IEVudHJ5U3RhdHVzLlBlbmRpbmcpIHtcbiAgICAgIHJlamVjdFNlZ21lbnRDYWNoZUVudHJ5KGVudHJ5LCBzdGFsZUF0KVxuICAgIH0gZWxzZSBpZiAoZW50cnkuc3RhdHVzID09PSBFbnRyeVN0YXR1cy5GdWxmaWxsZWQpIHtcbiAgICAgIGZ1bGZpbGxlZEVudHJpZXMucHVzaChlbnRyeSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bGZpbGxlZEVudHJpZXNcbn1cblxuZnVuY3Rpb24gd3JpdGVEeW5hbWljUmVuZGVyUmVzcG9uc2VJbnRvQ2FjaGUoXG4gIG5vdzogbnVtYmVyLFxuICB0YXNrOiBQcmVmZXRjaFRhc2ssXG4gIGZldGNoU3RyYXRlZ3k6XG4gICAgfCBGZXRjaFN0cmF0ZWd5LkxvYWRpbmdCb3VuZGFyeVxuICAgIHwgRmV0Y2hTdHJhdGVneS5QUFJSdW50aW1lXG4gICAgfCBGZXRjaFN0cmF0ZWd5LkZ1bGwsXG4gIHJlc3BvbnNlOiBSU0NSZXNwb25zZTxOYXZpZ2F0aW9uRmxpZ2h0UmVzcG9uc2U+LFxuICBzZXJ2ZXJEYXRhOiBOYXZpZ2F0aW9uRmxpZ2h0UmVzcG9uc2UsXG4gIGlzUmVzcG9uc2VQYXJ0aWFsOiBib29sZWFuLFxuICByb3V0ZTogRnVsZmlsbGVkUm91dGVDYWNoZUVudHJ5LFxuICBzcGF3bmVkRW50cmllczogTWFwPFNlZ21lbnRSZXF1ZXN0S2V5LCBQZW5kaW5nU2VnbWVudENhY2hlRW50cnk+IHwgbnVsbFxuKTogQXJyYXk8RnVsZmlsbGVkU2VnbWVudENhY2hlRW50cnk+IHwgbnVsbCB7XG4gIGlmIChzZXJ2ZXJEYXRhLmIgIT09IGdldEFwcEJ1aWxkSWQoKSkge1xuICAgIC8vIFRoZSBzZXJ2ZXIgYnVpbGQgZG9lcyBub3QgbWF0Y2ggdGhlIGNsaWVudC4gVHJlYXQgYXMgYSA0MDQuIER1cmluZ1xuICAgIC8vIGFuIGFjdHVhbCBuYXZpZ2F0aW9uLCB0aGUgcm91dGVyIHdpbGwgdHJpZ2dlciBhbiBNUEEgbmF2aWdhdGlvbi5cbiAgICAvLyBUT0RPOiBDb25zaWRlciBtb3ZpbmcgdGhlIGJ1aWxkIElEIHRvIGEgcmVzcG9uc2UgaGVhZGVyIHNvIHdlIGNhbiBjaGVja1xuICAgIC8vIGl0IGJlZm9yZSBkZWNvZGluZyB0aGUgcmVzcG9uc2UsIGFuZCBzbyB0aGVyZSdzIG9uZSB3YXkgb2YgY2hlY2tpbmdcbiAgICAvLyBhY3Jvc3MgYWxsIHJlc3BvbnNlIHR5cGVzLlxuICAgIGlmIChzcGF3bmVkRW50cmllcyAhPT0gbnVsbCkge1xuICAgICAgcmVqZWN0U2VnbWVudEVudHJpZXNJZlN0aWxsUGVuZGluZyhzcGF3bmVkRW50cmllcywgbm93ICsgMTAgKiAxMDAwKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgZmxpZ2h0RGF0YXMgPSBub3JtYWxpemVGbGlnaHREYXRhKHNlcnZlckRhdGEuZilcbiAgaWYgKHR5cGVvZiBmbGlnaHREYXRhcyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUaGlzIG1lYW5zIG5hdmlnYXRpbmcgdG8gdGhpcyByb3V0ZSB3aWxsIHJlc3VsdCBpbiBhbiBNUEEgbmF2aWdhdGlvbi5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgY2FjaGUgdGhpcywgdG9vLCBzbyB0aGF0IHRoZSBNUEEgbmF2aWdhdGlvbiBpcyBpbW1lZGlhdGUuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIEZvciBydW50aW1lIHByZWZldGNoZXMsIHN0YWxlIHRpbWUgaXMgaW4gdGhlIHBheWxvYWQgYXQgcnBbMV0uXG4gIC8vIEZvciBvdGhlciByZXNwb25zZXMsIGZhbGwgYmFjayB0byB0aGUgaGVhZGVyLlxuICBjb25zdCBzdGFsZVRpbWVTZWNvbmRzID1cbiAgICB0eXBlb2Ygc2VydmVyRGF0YS5ycD8uWzFdID09PSAnbnVtYmVyJ1xuICAgICAgPyBzZXJ2ZXJEYXRhLnJwWzFdXG4gICAgICA6IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KE5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSKSA/PyAnJywgMTApXG4gIGNvbnN0IHN0YWxlVGltZU1zID0gIWlzTmFOKHN0YWxlVGltZVNlY29uZHMpXG4gICAgPyBnZXRTdGFsZVRpbWVNcyhzdGFsZVRpbWVTZWNvbmRzKVxuICAgIDogU1RBVElDX1NUQUxFVElNRV9NU1xuICBjb25zdCBzdGFsZUF0ID0gbm93ICsgc3RhbGVUaW1lTXNcblxuICBmb3IgKGNvbnN0IGZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YXMpIHtcbiAgICBjb25zdCBzZWVkRGF0YSA9IGZsaWdodERhdGEuc2VlZERhdGFcbiAgICBpZiAoc2VlZERhdGEgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoZSBkYXRhIHNlbnQgYnkgdGhlIHNlcnZlciByZXByZXNlbnRzIG9ubHkgYSBzdWJ0cmVlIG9mIHRoZSBhcHAuIFdlXG4gICAgICAvLyBuZWVkIHRvIGZpbmQgdGhlIHBhcnQgb2YgdGhlIHRhc2sgdHJlZSB0aGF0IG1hdGNoZXMgdGhlIHJlc3BvbnNlLlxuICAgICAgLy9cbiAgICAgIC8vIHNlZ21lbnRQYXRoIHJlcHJlc2VudHMgdGhlIHBhcmVudCBwYXRoIG9mIHN1YnRyZWUuIEl0J3MgYSByZXBlYXRpbmdcbiAgICAgIC8vIHBhdHRlcm4gb2YgcGFyYWxsZWwgcm91dGUga2V5IGFuZCBzZWdtZW50OlxuICAgICAgLy9cbiAgICAgIC8vICAgW3N0cmluZywgU2VnbWVudCwgc3RyaW5nLCBTZWdtZW50LCBzdHJpbmcsIFNlZ21lbnQsIC4uLl1cbiAgICAgIGNvbnN0IHNlZ21lbnRQYXRoID0gZmxpZ2h0RGF0YS5zZWdtZW50UGF0aFxuICAgICAgbGV0IHRyZWUgPSByb3V0ZS50cmVlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRQYXRoLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHBhcmFsbGVsUm91dGVLZXk6IHN0cmluZyA9IHNlZ21lbnRQYXRoW2ldXG4gICAgICAgIGlmICh0cmVlPy5zbG90cz8uW3BhcmFsbGVsUm91dGVLZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0cmVlID0gdHJlZS5zbG90c1twYXJhbGxlbFJvdXRlS2V5XVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzcGF3bmVkRW50cmllcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVqZWN0U2VnbWVudEVudHJpZXNJZlN0aWxsUGVuZGluZyhzcGF3bmVkRW50cmllcywgbm93ICsgMTAgKiAxMDAwKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdyaXRlU2VlZERhdGFJbnRvQ2FjaGUoXG4gICAgICAgIG5vdyxcbiAgICAgICAgdGFzayxcbiAgICAgICAgZmV0Y2hTdHJhdGVneSxcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHRyZWUsXG4gICAgICAgIHN0YWxlQXQsXG4gICAgICAgIHNlZWREYXRhLFxuICAgICAgICBpc1Jlc3BvbnNlUGFydGlhbCxcbiAgICAgICAgc3Bhd25lZEVudHJpZXNcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBoZWFkID0gZmxpZ2h0RGF0YS5oZWFkXG4gICAgaWYgKGhlYWQgIT09IG51bGwpIHtcbiAgICAgIGZ1bGZpbGxFbnRyeVNwYXduZWRCeVJ1bnRpbWVQcmVmZXRjaChcbiAgICAgICAgbm93LFxuICAgICAgICBmZXRjaFN0cmF0ZWd5LFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgaGVhZCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZmxpZ2h0RGF0YS5pc0hlYWRQYXJ0aWFsLFxuICAgICAgICBzdGFsZUF0LFxuICAgICAgICByb3V0ZS5tZXRhZGF0YSxcbiAgICAgICAgc3Bhd25lZEVudHJpZXNcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgLy8gQW55IGVudHJ5IHRoYXQncyBzdGlsbCBwZW5kaW5nIHdhcyBpbnRlbnRpb25hbGx5IG5vdCByZW5kZXJlZCBieSB0aGVcbiAgLy8gc2VydmVyLCBiZWNhdXNlIGl0IHdhcyBpbnNpZGUgdGhlIGxvYWRpbmcgYm91bmRhcnkuIE1hcmsgdGhlbSBhcyByZWplY3RlZFxuICAvLyBzbyB3ZSBrbm93IG5vdCB0byBmZXRjaCB0aGVtIGFnYWluLlxuICAvLyBUT0RPOiBJZiBQUFIgaXMgZW5hYmxlZCBvbiBzb21lIHJvdXRlcyBidXQgbm90IG90aGVycywgdGhlbiBpdCdzIHBvc3NpYmxlXG4gIC8vIHRoYXQgYSBkaWZmZXJlbnQgcGFnZSBpcyBhYmxlIHRvIGRvIGEgcGVyLXNlZ21lbnQgcHJlZmV0Y2ggb2Ygb25lIG9mIHRoZVxuICAvLyBzZWdtZW50cyB3ZSdyZSBtYXJraW5nIGFzIHJlamVjdGVkIGhlcmUuIFdlIHNob3VsZCBtYXJrIG9uIHRoZSBzZWdtZW50XG4gIC8vIHNvbWVob3cgdGhhdCB0aGUgcmVhc29uIGZvciB0aGUgcmVqZWN0aW9uIGlzIGJlY2F1c2Ugb2YgYSBub24tUFBSIHByZWZldGNoLlxuICAvLyBUaGF0IHdheSBhIHBlci1zZWdtZW50IHByZWZldGNoIGtub3dzIHRvIGRpc3JlZ2FyZCB0aGUgcmVqZWN0aW9uLlxuICBpZiAoc3Bhd25lZEVudHJpZXMgIT09IG51bGwpIHtcbiAgICBjb25zdCBmdWxmaWxsZWRFbnRyaWVzID0gcmVqZWN0U2VnbWVudEVudHJpZXNJZlN0aWxsUGVuZGluZyhcbiAgICAgIHNwYXduZWRFbnRyaWVzLFxuICAgICAgbm93ICsgMTAgKiAxMDAwXG4gICAgKVxuICAgIHJldHVybiBmdWxmaWxsZWRFbnRyaWVzXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gd3JpdGVTZWVkRGF0YUludG9DYWNoZShcbiAgbm93OiBudW1iZXIsXG4gIHRhc2s6IFByZWZldGNoVGFzayxcbiAgZmV0Y2hTdHJhdGVneTpcbiAgICB8IEZldGNoU3RyYXRlZ3kuTG9hZGluZ0JvdW5kYXJ5XG4gICAgfCBGZXRjaFN0cmF0ZWd5LlBQUlJ1bnRpbWVcbiAgICB8IEZldGNoU3RyYXRlZ3kuRnVsbCxcbiAgcm91dGU6IEZ1bGZpbGxlZFJvdXRlQ2FjaGVFbnRyeSxcbiAgdHJlZTogUm91dGVUcmVlLFxuICBzdGFsZUF0OiBudW1iZXIsXG4gIHNlZWREYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSxcbiAgaXNSZXNwb25zZVBhcnRpYWw6IGJvb2xlYW4sXG4gIGVudHJpZXNPd25lZEJ5Q3VycmVudFRhc2s6IE1hcDxcbiAgICBTZWdtZW50UmVxdWVzdEtleSxcbiAgICBQZW5kaW5nU2VnbWVudENhY2hlRW50cnlcbiAgPiB8IG51bGxcbikge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gd3JpdGUgdGhlIHJlc3VsdCBvZiBhIHJ1bnRpbWUgc2VydmVyIHJlcXVlc3RcbiAgLy8gKENhY2hlTm9kZVNlZWREYXRhKSBpbnRvIHRoZSBwcmVmZXRjaCBjYWNoZS5cbiAgY29uc3QgcnNjID0gc2VlZERhdGFbMF1cbiAgY29uc3QgbG9hZGluZyA9IHNlZWREYXRhWzJdXG4gIGNvbnN0IGlzUGFydGlhbCA9IHJzYyA9PT0gbnVsbCB8fCBpc1Jlc3BvbnNlUGFydGlhbFxuICBmdWxmaWxsRW50cnlTcGF3bmVkQnlSdW50aW1lUHJlZmV0Y2goXG4gICAgbm93LFxuICAgIGZldGNoU3RyYXRlZ3ksXG4gICAgcm91dGUsXG4gICAgcnNjLFxuICAgIGxvYWRpbmcsXG4gICAgaXNQYXJ0aWFsLFxuICAgIHN0YWxlQXQsXG4gICAgdHJlZSxcbiAgICBlbnRyaWVzT3duZWRCeUN1cnJlbnRUYXNrXG4gIClcblxuICAvLyBSZWN1cnNpdmVseSB3cml0ZSB0aGUgY2hpbGQgZGF0YSBpbnRvIHRoZSBjYWNoZS5cbiAgY29uc3Qgc2xvdHMgPSB0cmVlLnNsb3RzXG4gIGlmIChzbG90cyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlZWREYXRhQ2hpbGRyZW4gPSBzZWVkRGF0YVsxXVxuICAgIGZvciAoY29uc3QgcGFyYWxsZWxSb3V0ZUtleSBpbiBzbG90cykge1xuICAgICAgY29uc3QgY2hpbGRUcmVlID0gc2xvdHNbcGFyYWxsZWxSb3V0ZUtleV1cbiAgICAgIGNvbnN0IGNoaWxkU2VlZERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCB8IHZvaWQgPVxuICAgICAgICBzZWVkRGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgICBpZiAoY2hpbGRTZWVkRGF0YSAhPT0gbnVsbCAmJiBjaGlsZFNlZWREYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd3JpdGVTZWVkRGF0YUludG9DYWNoZShcbiAgICAgICAgICBub3csXG4gICAgICAgICAgdGFzayxcbiAgICAgICAgICBmZXRjaFN0cmF0ZWd5LFxuICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgIGNoaWxkVHJlZSxcbiAgICAgICAgICBzdGFsZUF0LFxuICAgICAgICAgIGNoaWxkU2VlZERhdGEsXG4gICAgICAgICAgaXNSZXNwb25zZVBhcnRpYWwsXG4gICAgICAgICAgZW50cmllc093bmVkQnlDdXJyZW50VGFza1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGxFbnRyeVNwYXduZWRCeVJ1bnRpbWVQcmVmZXRjaChcbiAgbm93OiBudW1iZXIsXG4gIGZldGNoU3RyYXRlZ3k6XG4gICAgfCBGZXRjaFN0cmF0ZWd5LkxvYWRpbmdCb3VuZGFyeVxuICAgIHwgRmV0Y2hTdHJhdGVneS5QUFJSdW50aW1lXG4gICAgfCBGZXRjaFN0cmF0ZWd5LkZ1bGwsXG4gIHJvdXRlOiBGdWxmaWxsZWRSb3V0ZUNhY2hlRW50cnksXG4gIHJzYzogUmVhY3QuUmVhY3ROb2RlLFxuICBsb2FkaW5nOiBMb2FkaW5nTW9kdWxlRGF0YSB8IFByb21pc2U8TG9hZGluZ01vZHVsZURhdGE+LFxuICBpc1BhcnRpYWw6IGJvb2xlYW4sXG4gIHN0YWxlQXQ6IG51bWJlcixcbiAgdHJlZTogUm91dGVUcmVlLFxuICBlbnRyaWVzT3duZWRCeUN1cnJlbnRUYXNrOiBNYXA8XG4gICAgU2VnbWVudFJlcXVlc3RLZXksXG4gICAgUGVuZGluZ1NlZ21lbnRDYWNoZUVudHJ5XG4gID4gfCBudWxsXG4pIHtcbiAgLy8gV2Ugc2hvdWxkIG9ubHkgd3JpdGUgaW50byBjYWNoZSBlbnRyaWVzIHRoYXQgYXJlIG93bmVkIGJ5IHVzLiBPciBjcmVhdGVcbiAgLy8gYSBuZXcgb25lIGFuZCB3cml0ZSBpbnRvIHRoYXQuIFdlIG11c3QgbmV2ZXIgd3JpdGUgb3ZlciBhbiBlbnRyeSB0aGF0IHdhc1xuICAvLyBjcmVhdGVkIGJ5IGEgZGlmZmVyZW50IHRhc2ssIGJlY2F1c2UgdGhhdCBjYXVzZXMgZGF0YSByYWNlcy5cbiAgY29uc3Qgb3duZWRFbnRyeSA9XG4gICAgZW50cmllc093bmVkQnlDdXJyZW50VGFzayAhPT0gbnVsbFxuICAgICAgPyBlbnRyaWVzT3duZWRCeUN1cnJlbnRUYXNrLmdldCh0cmVlLnJlcXVlc3RLZXkpXG4gICAgICA6IHVuZGVmaW5lZFxuICBpZiAob3duZWRFbnRyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZnVsZmlsbFNlZ21lbnRDYWNoZUVudHJ5KG93bmVkRW50cnksIHJzYywgbG9hZGluZywgc3RhbGVBdCwgaXNQYXJ0aWFsKVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbWF0Y2hpbmcgZW50cnkuIEF0dGVtcHQgdG8gY3JlYXRlIGEgbmV3IG9uZS5cbiAgICBjb25zdCBwb3NzaWJseU5ld0VudHJ5ID0gcmVhZE9yQ3JlYXRlU2VnbWVudENhY2hlRW50cnkoXG4gICAgICBub3csXG4gICAgICBmZXRjaFN0cmF0ZWd5LFxuICAgICAgcm91dGUsXG4gICAgICB0cmVlXG4gICAgKVxuICAgIGlmIChwb3NzaWJseU5ld0VudHJ5LnN0YXR1cyA9PT0gRW50cnlTdGF0dXMuRW1wdHkpIHtcbiAgICAgIC8vIENvbmZpcm1lZCB0aGlzIGlzIGEgbmV3IGVudHJ5LiBXZSBjYW4gZnVsZmlsbCBpdC5cbiAgICAgIGNvbnN0IG5ld0VudHJ5ID0gcG9zc2libHlOZXdFbnRyeVxuICAgICAgZnVsZmlsbFNlZ21lbnRDYWNoZUVudHJ5KFxuICAgICAgICB1cGdyYWRlVG9QZW5kaW5nU2VnbWVudChuZXdFbnRyeSwgZmV0Y2hTdHJhdGVneSksXG4gICAgICAgIHJzYyxcbiAgICAgICAgbG9hZGluZyxcbiAgICAgICAgc3RhbGVBdCxcbiAgICAgICAgaXNQYXJ0aWFsXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlIHdhcyBhbHJlYWR5IGFuIGVudHJ5IGluIHRoZSBjYWNoZS4gQnV0IHdlIG1heSBiZSBhYmxlIHRvXG4gICAgICAvLyByZXBsYWNlIGl0IHdpdGggdGhlIG5ldyBvbmUgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgY29uc3QgbmV3RW50cnkgPSBmdWxmaWxsU2VnbWVudENhY2hlRW50cnkoXG4gICAgICAgIHVwZ3JhZGVUb1BlbmRpbmdTZWdtZW50KFxuICAgICAgICAgIGNyZWF0ZURldGFjaGVkU2VnbWVudENhY2hlRW50cnkoc3RhbGVBdCksXG4gICAgICAgICAgZmV0Y2hTdHJhdGVneVxuICAgICAgICApLFxuICAgICAgICByc2MsXG4gICAgICAgIGxvYWRpbmcsXG4gICAgICAgIHN0YWxlQXQsXG4gICAgICAgIGlzUGFydGlhbFxuICAgICAgKVxuICAgICAgdXBzZXJ0U2VnbWVudEVudHJ5KFxuICAgICAgICBub3csXG4gICAgICAgIGdldFNlZ21lbnRWYXJ5UGF0aEZvclJlcXVlc3QoZmV0Y2hTdHJhdGVneSwgdHJlZSksXG4gICAgICAgIG5ld0VudHJ5XG4gICAgICApXG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUHJlZmV0Y2hSZXNwb25zZTxUPihcbiAgdXJsOiBVUkwsXG4gIGhlYWRlcnM6IFJlcXVlc3RIZWFkZXJzXG4pOiBQcm9taXNlPFJTQ1Jlc3BvbnNlPFQ+IHwgbnVsbD4ge1xuICBjb25zdCBmZXRjaFByaW9yaXR5ID0gJ2xvdydcbiAgLy8gV2hlbiBpc3N1aW5nIGEgcHJlZmV0Y2ggcmVxdWVzdCwgZG9uJ3QgaW1tZWRpYXRlbHkgZGVjb2RlIHRoZSByZXNwb25zZTsgd2VcbiAgLy8gdXNlIHRoZSBsb3dlciBsZXZlbCBgY3JlYXRlRnJvbVJlc3BvbnNlYCBBUEkgaW5zdGVhZCBiZWNhdXNlIHdlIG5lZWQgdG8gZG9cbiAgLy8gc29tZSBleHRyYSBwcm9jZXNzaW5nIG9mIHRoZSByZXNwb25zZSBzdHJlYW0uIFNlZVxuICAvLyBgY3JlYXRlUHJlZmV0Y2hSZXNwb25zZVN0cmVhbWAgZm9yIG1vcmUgZGV0YWlscy5cbiAgY29uc3Qgc2hvdWxkSW1tZWRpYXRlbHlEZWNvZGUgPSBmYWxzZVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNyZWF0ZUZldGNoPFQ+KFxuICAgIHVybCxcbiAgICBoZWFkZXJzLFxuICAgIGZldGNoUHJpb3JpdHksXG4gICAgc2hvdWxkSW1tZWRpYXRlbHlEZWNvZGVcbiAgKVxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIENoZWNrIHRoZSBjb250ZW50IHR5cGVcbiAgaWYgKGlzT3V0cHV0RXhwb3J0TW9kZSkge1xuICAgIC8vIEluIG91dHB1dDogXCJleHBvcnRcIiBtb2RlLCB3ZSByZWxheGVkIGFib3V0IHRoZSBjb250ZW50IHR5cGUsIHNpbmNlIGl0J3NcbiAgICAvLyBub3QgTmV4dC5qcyB0aGF0J3Mgc2VydmluZyB0aGUgcmVzcG9uc2UuIElmIHRoZSBzdGF0dXMgaXMgT0ssIGFzc3VtZSB0aGVcbiAgICAvLyByZXNwb25zZSBpcyB2YWxpZC4gSWYgaXQncyBub3QgYSB2YWxpZCByZXNwb25zZSwgdGhlIEZsaWdodCBjbGllbnQgd29uJ3RcbiAgICAvLyBiZSBhYmxlIHRvIGRlY29kZSBpdCwgYW5kIHdlJ2xsIHRyZWF0IGl0IGFzIGEgbWlzcy5cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKVxuICAgIGNvbnN0IGlzRmxpZ2h0UmVzcG9uc2UgPVxuICAgICAgY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuc3RhcnRzV2l0aChSU0NfQ09OVEVOVF9UWVBFX0hFQURFUilcbiAgICBpZiAoIWlzRmxpZ2h0UmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG4gIHJldHVybiByZXNwb25zZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQcmVmZXRjaFJlc3BvbnNlU3RyZWFtKFxuICBvcmlnaW5hbEZsaWdodFN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4sXG4gIG9uU3RyZWFtQ2xvc2U6ICgpID0+IHZvaWQsXG4gIG9uUmVzcG9uc2VTaXplVXBkYXRlOiAoc2l6ZTogbnVtYmVyKSA9PiB2b2lkXG4pOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PiB7XG4gIC8vIFdoZW4gUFBSIGlzIGVuYWJsZWQsIHByZWZldGNoIHN0cmVhbXMgbWF5IGNvbnRhaW4gcmVmZXJlbmNlcyB0aGF0IG5ldmVyXG4gIC8vIHJlc29sdmUsIGJlY2F1c2UgdGhhdCdzIGhvdyB3ZSBlbmNvZGUgZHluYW1pYyBkYXRhIGFjY2Vzcy4gSW4gdGhlIGRlY29kZWRcbiAgLy8gb2JqZWN0IHJldHVybmVkIGJ5IHRoZSBGbGlnaHQgY2xpZW50LCB0aGVzZSBhcmUgcmVpZmllZCBpbnRvIGhhbmdpbmdcbiAgLy8gcHJvbWlzZXMgdGhhdCBzdXNwZW5kIGR1cmluZyByZW5kZXIsIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHdoYXQgd2Ugd2FudC5cbiAgLy8gVGhlIFVJIHJlc29sdmVzIHdoZW4gaXQgc3dpdGNoZXMgdG8gdGhlIGR5bmFtaWMgZGF0YSBzdHJlYW1cbiAgLy8gKHZpYSB1c2VEZWZlcnJlZFZhbHVlKGR5bmFtaWMsIHN0YXRpYykpLlxuICAvL1xuICAvLyBIb3dldmVyLCB0aGUgRmxpZ2h0IGltcGxlbWVudGF0aW9uIGN1cnJlbnRseSBlcnJvcnMgaWYgdGhlIHNlcnZlciBjbG9zZXNcbiAgLy8gdGhlIHJlc3BvbnNlIGJlZm9yZSBhbGwgdGhlIHJlZmVyZW5jZXMgYXJlIHJlc29sdmVkLiBBcyBhIGNoZWF0IHRvIHdvcmtcbiAgLy8gYXJvdW5kIHRoaXMsIHdlIHdyYXAgdGhlIG9yaWdpbmFsIHN0cmVhbSBpbiBhIG5ldyBzdHJlYW0gdGhhdCBuZXZlciBjbG9zZXMsXG4gIC8vIGFuZCB0aGVyZWZvcmUgZG9lc24ndCBlcnJvci5cbiAgLy9cbiAgLy8gV2hpbGUgcHJvY2Vzc2luZyB0aGUgb3JpZ2luYWwgc3RyZWFtLCB3ZSBhbHNvIGluY3JlbWVudGFsbHkgdXBkYXRlIHRoZSBzaXplXG4gIC8vIG9mIHRoZSBjYWNoZSBlbnRyeSBpbiB0aGUgTFJVLlxuICBsZXQgdG90YWxCeXRlTGVuZ3RoID0gMFxuICBjb25zdCByZWFkZXIgPSBvcmlnaW5hbEZsaWdodFN0cmVhbS5nZXRSZWFkZXIoKVxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKClcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgLy8gUGFzcyB0byB0aGUgdGFyZ2V0IHN0cmVhbSBhbmQga2VlcCBjb25zdW1pbmcgdGhlIEZsaWdodCByZXNwb25zZVxuICAgICAgICAgIC8vIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpXG5cbiAgICAgICAgICAvLyBJbmNyZW1lbnRhbGx5IHVwZGF0ZSB0aGUgc2l6ZSBvZiB0aGUgY2FjaGUgZW50cnkgaW4gdGhlIExSVS5cbiAgICAgICAgICAvLyBOT1RFOiBTaW5jZSBwcmVmZXRjaCByZXNwb25zZXMgYXJlIGRlbGl2ZXJlZCBpbiBhIHNpbmdsZSBjaHVuayxcbiAgICAgICAgICAvLyBpdCdzIG5vdCByZWFsbHkgbmVjZXNzYXJ5IHRvIGRvIHRoaXMgc3RyZWFtaW5nbHksIGJ1dCBJJ20gZG9pbmcgaXRcbiAgICAgICAgICAvLyBhbnl3YXkgaW4gY2FzZSB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgICB0b3RhbEJ5dGVMZW5ndGggKz0gdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgICAgIG9uUmVzcG9uc2VTaXplVXBkYXRlKHRvdGFsQnl0ZUxlbmd0aClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgc3RyZWFtIGhhcyBjbG9zZWQuIEV4aXQsIGJ1dCBpbnRlbnRpb25hbGx5IGRvIG5vdCBjbG9zZVxuICAgICAgICAvLyB0aGUgdGFyZ2V0IHN0cmVhbS4gV2UgZG8gbm90aWZ5IHRoZSBjYWxsZXIsIHRob3VnaC5cbiAgICAgICAgb25TdHJlYW1DbG9zZSgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGFkZFNlZ21lbnRQYXRoVG9VcmxJbk91dHB1dEV4cG9ydE1vZGUoXG4gIHVybDogVVJMLFxuICBzZWdtZW50UGF0aDogU2VnbWVudFJlcXVlc3RLZXlcbik6IFVSTCB7XG4gIGlmIChpc091dHB1dEV4cG9ydE1vZGUpIHtcbiAgICAvLyBJbiBvdXRwdXQ6IFwiZXhwb3J0XCIgbW9kZSwgd2UgY2Fubm90IHVzZSBhIGhlYWRlciB0byBlbmNvZGUgdGhlIHNlZ21lbnRcbiAgICAvLyBwYXRoLiBJbnN0ZWFkLCB3ZSBhcHBlbmQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgcGF0aG5hbWUuXG4gICAgY29uc3Qgc3RhdGljVXJsID0gbmV3IFVSTCh1cmwpXG4gICAgY29uc3Qgcm91dGVEaXIgPSBzdGF0aWNVcmwucGF0aG5hbWUuZW5kc1dpdGgoJy8nKVxuICAgICAgPyBzdGF0aWNVcmwucGF0aG5hbWUuc2xpY2UoMCwgLTEpXG4gICAgICA6IHN0YXRpY1VybC5wYXRobmFtZVxuICAgIGNvbnN0IHN0YXRpY0V4cG9ydEZpbGVuYW1lID1cbiAgICAgIGNvbnZlcnRTZWdtZW50UGF0aFRvU3RhdGljRXhwb3J0RmlsZW5hbWUoc2VnbWVudFBhdGgpXG4gICAgc3RhdGljVXJsLnBhdGhuYW1lID0gYCR7cm91dGVEaXJ9LyR7c3RhdGljRXhwb3J0RmlsZW5hbWV9YFxuICAgIHJldHVybiBzdGF0aWNVcmxcbiAgfVxuICByZXR1cm4gdXJsXG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIG5ldyBmZXRjaCBzdHJhdGVneSBpcyBsaWtlbHkgdG8gcHJvdmlkZSBtb3JlIGNvbnRlbnQgdGhhbiB0aGUgb2xkIG9uZS5cbiAqXG4gKiBHZW5lcmFsbHksIHdoZW4gYW4gYXBwIHVzZXMgZHluYW1pYyBkYXRhLCBhIFwibW9yZSBzcGVjaWZpY1wiIGZldGNoIHN0cmF0ZWd5IGlzIGV4cGVjdGVkIHRvIHByb3ZpZGUgbW9yZSBjb250ZW50OlxuICogLSBgTG9hZGluZ0JvdW5kYXJ5YCBvbmx5IHByb3ZpZGVzIHN0YXRpYyBsYXlvdXRzXG4gKiAtIGBQUFJgIGNhbiBwcm92aWRlIHNoZWxscyBmb3IgZWFjaCBzZWdtZW50IChldmVuIGZvciBzZWdtZW50cyB0aGF0IHVzZSBkeW5hbWljIGRhdGEpXG4gKiAtIGBQUFJSdW50aW1lYCBjYW4gYWRkaXRpb25hbGx5IGluY2x1ZGUgY29udGVudCB0aGF0IHVzZXMgc2VhcmNoUGFyYW1zLCBwYXJhbXMsIG9yIGNvb2tpZXNcbiAqIC0gYEZ1bGxgIGluY2x1ZGVzIGFsbCB0aGUgY29udGVudCwgZXZlbiBpZiBpdCB1c2VzIGR5bmFtaWMgZGF0YVxuICpcbiAqIEhvd2V2ZXIsIGl0J3MgcG9zc2libGUgdGhhdCBhIG1vcmUgc3BlY2lmaWMgZmV0Y2ggc3RyYXRlZ3kgKndvbid0KiBnaXZlIHVzIG1vcmUgY29udGVudCBpZjpcbiAqIC0gYSBzZWdtZW50IGlzIGZ1bGx5IHN0YXRpY1xuICogICAodGhlbiwgYFBQUmAvYFBQUlJ1bnRpbWVgL2BGdWxsYCB3aWxsIGFsbCB5aWVsZCBlcXVpdmFsZW50IHJlc3VsdHMpXG4gKiAtIHByb3ZpZGluZyBzZWFyY2hQYXJhbXMvcGFyYW1zL2Nvb2tpZXMgZG9lc24ndCByZXZlYWwgYW55IG1vcmUgY29udGVudCwgZS5nLiBiZWNhdXNlIG9mIGFuIGBhd2FpdCBjb25uZWN0aW9uKClgXG4gKiAgICh0aGVuLCBgUFBSYCBhbmQgYFBQUlJ1bnRpbWVgIHdpbGwgeWllbGQgZXF1aXZhbGVudCByZXN1bHRzLCBvbmx5IGBGdWxsYCB3aWxsIGdpdmUgdXMgbW9yZSlcbiAqIEJlY2F1c2Ugb2YgdGhpcywgd2hlbiBjb21wYXJpbmcgdHdvIHNlZ21lbnRzLCB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiB0aGUgZXhpc3Rpbmcgc2VnbWVudCBpcyBwYXJ0aWFsLlxuICogSWYgaXQncyBub3QgcGFydGlhbCwgdGhlbiB0aGVyZSdzIG5vIG5lZWQgdG8gcHJlZmV0Y2ggaXQgYWdhaW4sIGV2ZW4gdXNpbmcgYSBcIm1vcmUgc3BlY2lmaWNcIiBzdHJhdGVneS5cbiAqIFRoZXJlJ3MgY3VycmVudGx5IG5vIHdheSB0byBrbm93IGlmIGBQUFJSdW50aW1lYCB3aWxsIHlpZWxkIG1vcmUgZGF0YSB0aGF0IGBQUFJgLCBzbyB3ZSBoYXZlIHRvIGFzc3VtZSBpdCB3aWxsLlxuICpcbiAqIEFsc28gbm90ZSB0aGF0LCBpbiBwcmFjdGljZSwgd2UgZG9uJ3QgZXhwZWN0IHRvIGJlIGNvbXBhcmluZyBgTG9hZGluZ0JvdW5kYXJ5YCB0byBgUFBSYC9gUFBSUnVudGltZWAsXG4gKiBiZWNhdXNlIGEgbm9uLVBQUi1lbmFibGVkIHJvdXRlIHdvdWxkbid0IGV2ZXIgdXNlIHRoZSBsYXR0ZXIgc3RyYXRlZ2llcy4gSXQgbWlnaHQgaG93ZXZlciB1c2UgYEZ1bGxgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FuTmV3RmV0Y2hTdHJhdGVneVByb3ZpZGVNb3JlQ29udGVudChcbiAgY3VycmVudFN0cmF0ZWd5OiBGZXRjaFN0cmF0ZWd5LFxuICBuZXdTdHJhdGVneTogRmV0Y2hTdHJhdGVneVxuKTogYm9vbGVhbiB7XG4gIHJldHVybiBjdXJyZW50U3RyYXRlZ3kgPCBuZXdTdHJhdGVneVxufVxuIl0sIm5hbWVzIjpbIkVudHJ5U3RhdHVzIiwiY2FuTmV3RmV0Y2hTdHJhdGVneVByb3ZpZGVNb3JlQ29udGVudCIsImNvbnZlcnRSb3V0ZVRyZWVUb0ZsaWdodFJvdXRlclN0YXRlIiwiY3JlYXRlRGV0YWNoZWRTZWdtZW50Q2FjaGVFbnRyeSIsImZldGNoUm91dGVPbkNhY2hlTWlzcyIsImZldGNoU2VnbWVudE9uQ2FjaGVNaXNzIiwiZmV0Y2hTZWdtZW50UHJlZmV0Y2hlc1VzaW5nRHluYW1pY1JlcXVlc3QiLCJnZXRDdXJyZW50Q2FjaGVWZXJzaW9uIiwiZ2V0U3RhbGVUaW1lTXMiLCJvdmVyd3JpdGVSZXZhbGlkYXRpbmdTZWdtZW50Q2FjaGVFbnRyeSIsInBpbmdJbnZhbGlkYXRpb25MaXN0ZW5lcnMiLCJyZWFkT3JDcmVhdGVSZXZhbGlkYXRpbmdTZWdtZW50RW50cnkiLCJyZWFkT3JDcmVhdGVSb3V0ZUNhY2hlRW50cnkiLCJyZWFkT3JDcmVhdGVTZWdtZW50Q2FjaGVFbnRyeSIsInJlYWRSb3V0ZUNhY2hlRW50cnkiLCJyZWFkU2VnbWVudENhY2hlRW50cnkiLCJyZXF1ZXN0T3B0aW1pc3RpY1JvdXRlQ2FjaGVFbnRyeSIsInJldmFsaWRhdGVFbnRpcmVDYWNoZSIsInVwZ3JhZGVUb1BlbmRpbmdTZWdtZW50IiwidXBzZXJ0U2VnbWVudEVudHJ5Iiwid2FpdEZvclNlZ21lbnRDYWNoZUVudHJ5Iiwic3RhbGVUaW1lU2Vjb25kcyIsIk1hdGgiLCJtYXgiLCJpc091dHB1dEV4cG9ydE1vZGUiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJfX05FWFRfQ09ORklHX09VVFBVVCIsIk1ldGFkYXRhT25seVJlcXVlc3RUcmVlIiwicm91dGVDYWNoZU1hcCIsImNyZWF0ZUNhY2hlTWFwIiwic2VnbWVudENhY2hlTWFwIiwiaW52YWxpZGF0aW9uTGlzdGVuZXJzIiwiY3VycmVudENhY2hlVmVyc2lvbiIsIm5leHRVcmwiLCJ0cmVlIiwic3RhcnRSZXZhbGlkYXRpb25Db29sZG93biIsInBpbmdWaXNpYmxlTGlua3MiLCJhdHRhY2hJbnZhbGlkYXRpb25MaXN0ZW5lciIsInRhc2siLCJvbkludmFsaWRhdGUiLCJTZXQiLCJhZGQiLCJub3RpZnlJbnZhbGlkYXRpb25MaXN0ZW5lciIsImVycm9yIiwicmVwb3J0RXJyb3IiLCJjb25zb2xlIiwidGFza3MiLCJpc1ByZWZldGNoVGFza0RpcnR5Iiwibm93Iiwia2V5IiwidmFyeVBhdGgiLCJnZXRSb3V0ZVZhcnlQYXRoIiwicGF0aG5hbWUiLCJzZWFyY2giLCJpc1JldmFsaWRhdGlvbiIsImdldEZyb21DYWNoZU1hcCIsInJlYWRSZXZhbGlkYXRpbmdTZWdtZW50Q2FjaGVFbnRyeSIsInBlbmRpbmdFbnRyeSIsInByb21pc2VXaXRoUmVzb2x2ZXJzIiwicHJvbWlzZSIsImNyZWF0ZVByb21pc2VXaXRoUmVzb2x2ZXJzIiwiZXhpc3RpbmdFbnRyeSIsImNhbm9uaWNhbFVybCIsInN0YXR1cyIsImJsb2NrZWRUYXNrcyIsIm1ldGFkYXRhIiwiY291bGRCZUludGVyY2VwdGVkIiwiaXNQUFJFbmFibGVkIiwicmVuZGVyZWRTZWFyY2giLCJyZWYiLCJzaXplIiwic3RhbGVBdCIsIkluZmluaXR5IiwidmVyc2lvbiIsInNldEluQ2FjaGVNYXAiLCJyZXF1ZXN0ZWRVcmwiLCJyZXF1ZXN0ZWRTZWFyY2giLCJ1cmxXaXRob3V0U2VhcmNoUGFyYW1zIiwiVVJMIiwicm91dGVXaXRoTm9TZWFyY2hQYXJhbXMiLCJjcmVhdGVQcmVmZXRjaFJlcXVlc3RLZXkiLCJocmVmIiwiY2Fub25pY2FsVXJsRm9yUm91dGVXaXRoTm9TZWFyY2hQYXJhbXMiLCJvcmlnaW4iLCJvcHRpbWlzdGljQ2Fub25pY2FsU2VhcmNoIiwib3B0aW1pc3RpY1JlbmRlcmVkU2VhcmNoIiwib3B0aW1pc3RpY1VybCIsImxvY2F0aW9uIiwib3B0aW1pc3RpY0Nhbm9uaWNhbFVybCIsImNyZWF0ZUhyZWZGcm9tVXJsIiwib3B0aW1pc3RpY1JvdXRlVHJlZSIsImNyZWF0ZU9wdGltaXN0aWNSb3V0ZVRyZWUiLCJvcHRpbWlzdGljTWV0YWRhdGFUcmVlIiwib3B0aW1pc3RpY0VudHJ5IiwibmV3UmVuZGVyZWRTZWFyY2giLCJjbG9uZWRTbG90cyIsIm9yaWdpbmFsU2xvdHMiLCJzbG90cyIsInBhcmFsbGVsUm91dGVLZXkiLCJjaGlsZFRyZWUiLCJpc1BhZ2UiLCJyZXF1ZXN0S2V5Iiwic2VnbWVudCIsImNsb25lUGFnZVZhcnlQYXRoV2l0aE5ld1NlYXJjaFBhcmFtcyIsImlzUm9vdExheW91dCIsImhhc0xvYWRpbmdCb3VuZGFyeSIsImhhc1J1bnRpbWVQcmVmZXRjaCIsImZldGNoU3RyYXRlZ3kiLCJyb3V0ZSIsInZhcnlQYXRoRm9yUmVxdWVzdCIsImdldFNlZ21lbnRWYXJ5UGF0aEZvclJlcXVlc3QiLCJjYW5kaWRhdGVFbnRyeSIsImlzVmFsdWVFeHBpcmVkIiwiaXNQYXJ0aWFsIiwicmVqZWN0ZWRFbnRyeSIsImxvYWRpbmciLCJyc2MiLCJkZWxldGVGcm9tQ2FjaGVNYXAiLCJlbXB0eUVudHJ5IiwiRmV0Y2hTdHJhdGVneSIsIlBQUiIsIkZ1bGwiLCJwaW5nQmxvY2tlZFRhc2tzIiwiZW50cnkiLCJwaW5nUHJlZmV0Y2hUYXNrIiwiZnVsZmlsbFJvdXRlQ2FjaGVFbnRyeSIsIm1ldGFkYXRhVmFyeVBhdGgiLCJIRUFEX1JFUVVFU1RfS0VZIiwiSGFzTG9hZGluZ0JvdW5kYXJ5IiwiU3VidHJlZUhhc05vTG9hZGluZ0JvdW5kYXJ5IiwiZnVsZmlsbGVkRW50cnkiLCJmdWxmaWxsU2VnbWVudENhY2hlRW50cnkiLCJzZWdtZW50Q2FjaGVFbnRyeSIsInJlc29sdmUiLCJyZWplY3RSb3V0ZUNhY2hlRW50cnkiLCJyZWplY3RTZWdtZW50Q2FjaGVFbnRyeSIsImNvbnZlcnRSb290VHJlZVByZWZldGNoVG9Sb3V0ZVRyZWUiLCJyb290VHJlZSIsInJlbmRlcmVkUGF0aG5hbWUiLCJhY2MiLCJwYXRobmFtZVBhcnRzIiwic3BsaXQiLCJmaWx0ZXIiLCJwIiwiaW5kZXgiLCJyb290U2VnbWVudCIsIlJPT1RfU0VHTUVOVF9SRVFVRVNUX0tFWSIsImNvbnZlcnRUcmVlUHJlZmV0Y2hUb1JvdXRlVHJlZSIsInByZWZldGNoIiwicGFydGlhbFZhcnlQYXRoIiwicGF0aG5hbWVQYXJ0c0luZGV4IiwicHJlZmV0Y2hTbG90cyIsImZpbmFsaXplTGF5b3V0VmFyeVBhdGgiLCJjaGlsZFByZWZldGNoIiwiY2hpbGRQYXJhbU5hbWUiLCJuYW1lIiwiY2hpbGRQYXJhbVR5cGUiLCJwYXJhbVR5cGUiLCJjaGlsZFNlcnZlclNlbnRQYXJhbUtleSIsInBhcmFtS2V5IiwiY2hpbGREb2VzQXBwZWFySW5VUkwiLCJjaGlsZFNlZ21lbnQiLCJjaGlsZFBhcnRpYWxWYXJ5UGF0aCIsImNoaWxkUGFyYW1WYWx1ZSIsInBhcnNlRHluYW1pY1BhcmFtRnJvbVVSTFBhcnQiLCJjaGlsZFBhcmFtS2V5IiwiZ2V0Q2FjaGVLZXlGb3JEeW5hbWljUGFyYW0iLCJhcHBlbmRMYXlvdXRWYXJ5UGF0aCIsImRvZXNTdGF0aWNTZWdtZW50QXBwZWFySW5VUkwiLCJjaGlsZFBhdGhuYW1lUGFydHNJbmRleCIsImNoaWxkUmVxdWVzdEtleVBhcnQiLCJjcmVhdGVTZWdtZW50UmVxdWVzdEtleVBhcnQiLCJjaGlsZFJlcXVlc3RLZXkiLCJhcHBlbmRTZWdtZW50UmVxdWVzdEtleVBhcnQiLCJlbmRzV2l0aCIsIlBBR0VfU0VHTUVOVF9LRVkiLCJmaW5hbGl6ZVBhZ2VWYXJ5UGF0aCIsImZpbmFsaXplTWV0YWRhdGFWYXJ5UGF0aCIsIlNlZ21lbnRIYXNMb2FkaW5nQm91bmRhcnkiLCJjb252ZXJ0Um9vdEZsaWdodFJvdXRlclN0YXRlVG9Sb3V0ZVRyZWUiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsImNvbnZlcnRGbGlnaHRSb3V0ZXJTdGF0ZVRvUm91dGVUcmVlIiwicGFyZW50UGFydGlhbFZhcnlQYXRoIiwib3JpZ2luYWxTZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5IiwicGFyYW1DYWNoZUtleSIsInBhcmFsbGVsUm91dGVzIiwiY2hpbGRSb3V0ZXJTdGF0ZSIsInVuZGVmaW5lZCIsInJvdXRlVHJlZSIsInNlZ21lbnRQYXRoIiwiaGVhZGVycyIsIlJTQ19IRUFERVIiLCJORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVIiLCJORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUiIsIk5FWFRfVVJMIiwidXJsIiwicmVzcG9uc2UiLCJ1cmxBZnRlclJlZGlyZWN0cyIsImhlYWRSZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiRGF0ZSIsInJlZGlyZWN0ZWQiLCJmZXRjaFByZWZldGNoUmVzcG9uc2UiLCJhZGRTZWdtZW50UGF0aFRvVXJsSW5PdXRwdXRFeHBvcnRNb2RlIiwib2siLCJib2R5IiwidmFyeUhlYWRlciIsImdldCIsImluY2x1ZGVzIiwiY2xvc2VkIiwicm91dGVJc1BQUkVuYWJsZWQiLCJORVhUX0RJRF9QT1NUUE9ORV9IRUFERVIiLCJwcmVmZXRjaFN0cmVhbSIsImNyZWF0ZVByZWZldGNoUmVzcG9uc2VTdHJlYW0iLCJvblJlc3BvbnNlU2l6ZVVwZGF0ZSIsInNldFNpemVJbkNhY2hlTWFwIiwic2VydmVyRGF0YSIsImNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0iLCJidWlsZElkIiwiZ2V0QXBwQnVpbGRJZCIsImdldFJlbmRlcmVkUGF0aG5hbWUiLCJnZXRSZW5kZXJlZFNlYXJjaCIsInN0YWxlVGltZU1zIiwic3RhbGVUaW1lIiwiYiIsIndyaXRlRHluYW1pY1RyZWVSZXNwb25zZUludG9DYWNoZSIsIkxvYWRpbmdCb3VuZGFyeSIsImZ1bGZpbGxlZFZhcnlQYXRoIiwiZ2V0RnVsZmlsbGVkUm91dGVWYXJ5UGF0aCIsInZhbHVlIiwicm91dGVLZXkiLCJub3JtYWxpemVkUmVxdWVzdEtleSIsInJlcXVlc3RVcmwiLCJkeW5hbWljUmVxdWVzdFRyZWUiLCJzcGF3bmVkRW50cmllcyIsImhhcyIsIk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSIiwicHJlcGFyZUZsaWdodFJvdXRlclN0YXRlRm9yUmVxdWVzdCIsIlBQUlJ1bnRpbWUiLCJyZWplY3RTZWdtZW50RW50cmllc0lmU3RpbGxQZW5kaW5nIiwiZnVsZmlsbGVkRW50cmllcyIsInRvdGFsQnl0ZXNSZWNlaXZlZFNvRmFyIiwiYXZlcmFnZVNpemUiLCJsZW5ndGgiLCJpc1Jlc3BvbnNlUGFydGlhbCIsInJwIiwid3JpdGVEeW5hbWljUmVuZGVyUmVzcG9uc2VJbnRvQ2FjaGUiLCJub3JtYWxpemVkRmxpZ2h0RGF0YVJlc3VsdCIsIm5vcm1hbGl6ZUZsaWdodERhdGEiLCJmIiwiZmxpZ2h0RGF0YSIsImlzUm9vdFJlbmRlciIsInBhcnNlSW50IiwiTkVYVF9ST1VURVJfU1RBTEVfVElNRV9IRUFERVIiLCJpc05hTiIsIlNUQVRJQ19TVEFMRVRJTUVfTVMiLCJlbnRyaWVzIiwidmFsdWVzIiwicHVzaCIsImZsaWdodERhdGFzIiwic2VlZERhdGEiLCJpIiwid3JpdGVTZWVkRGF0YUludG9DYWNoZSIsImhlYWQiLCJmdWxmaWxsRW50cnlTcGF3bmVkQnlSdW50aW1lUHJlZmV0Y2giLCJpc0hlYWRQYXJ0aWFsIiwiZW50cmllc093bmVkQnlDdXJyZW50VGFzayIsInNlZWREYXRhQ2hpbGRyZW4iLCJjaGlsZFNlZWREYXRhIiwib3duZWRFbnRyeSIsInBvc3NpYmx5TmV3RW50cnkiLCJuZXdFbnRyeSIsImZldGNoUHJpb3JpdHkiLCJzaG91bGRJbW1lZGlhdGVseURlY29kZSIsImNyZWF0ZUZldGNoIiwiY29udGVudFR5cGUiLCJpc0ZsaWdodFJlc3BvbnNlIiwic3RhcnRzV2l0aCIsIlJTQ19DT05URU5UX1RZUEVfSEVBREVSIiwib3JpZ2luYWxGbGlnaHRTdHJlYW0iLCJvblN0cmVhbUNsb3NlIiwidG90YWxCeXRlTGVuZ3RoIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiUmVhZGFibGVTdHJlYW0iLCJwdWxsIiwiY29udHJvbGxlciIsImRvbmUiLCJyZWFkIiwiZW5xdWV1ZSIsImJ5dGVMZW5ndGgiLCJzdGF0aWNVcmwiLCJyb3V0ZURpciIsInNsaWNlIiwic3RhdGljRXhwb3J0RmlsZW5hbWUiLCJjb252ZXJ0U2VnbWVudFBhdGhUb1N0YXRpY0V4cG9ydEZpbGVuYW1lIiwiY3VycmVudFN0cmF0ZWd5IiwibmV3U3RyYXRlZ3kiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache/cache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache/lru.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/segment-cache/lru.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    deleteFromLru: function() {\n        return deleteFromLru;\n    },\n    lruPut: function() {\n        return lruPut;\n    },\n    updateLruSize: function() {\n        return updateLruSize;\n    }\n});\nconst _cachemap = __webpack_require__(/*! ./cache-map */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache/cache-map.js\");\n// We use an LRU for memory management. We must update this whenever we add or\n// remove a new cache entry, or when an entry changes size.\nlet head = null;\nlet didScheduleCleanup = false;\nlet lruSize = 0;\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxLruSize = 50 * 1024 * 1024 // 50 MB\n;\nfunction lruPut(node) {\n    if (head === node) {\n        // Already at the head\n        return;\n    }\n    const prev = node.prev;\n    const next = node.next;\n    if (next === null || prev === null) {\n        // This is an insertion\n        lruSize += node.size;\n        // Whenever we add an entry, we need to check if we've exceeded the\n        // max size. We don't evict entries immediately; they're evicted later in\n        // an asynchronous task.\n        ensureCleanupIsScheduled();\n    } else {\n        // This is a move. Remove from its current position.\n        prev.next = next;\n        next.prev = prev;\n    }\n    // Move to the front of the list\n    if (head === null) {\n        // This is the first entry\n        node.prev = node;\n        node.next = node;\n    } else {\n        // Add to the front of the list\n        const tail = head.prev;\n        node.prev = tail;\n        // In practice, this is never null, but that isn't encoded in the type\n        if (tail !== null) {\n            tail.next = node;\n        }\n        node.next = head;\n        head.prev = node;\n    }\n    head = node;\n}\nfunction updateLruSize(node, newNodeSize) {\n    // This is a separate function from `put` so that we can resize the entry\n    // regardless of whether it's currently being tracked by the LRU.\n    const prevNodeSize = node.size;\n    node.size = newNodeSize;\n    if (node.next === null) {\n        // This entry is not currently being tracked by the LRU.\n        return;\n    }\n    // Update the total LRU size\n    lruSize = lruSize - prevNodeSize + newNodeSize;\n    ensureCleanupIsScheduled();\n}\nfunction deleteFromLru(deleted) {\n    const next = deleted.next;\n    const prev = deleted.prev;\n    if (next !== null && prev !== null) {\n        lruSize -= deleted.size;\n        deleted.next = null;\n        deleted.prev = null;\n        // Remove from the list\n        if (head === deleted) {\n            // Update the head\n            if (next === head) {\n                // This was the last entry\n                head = null;\n            } else {\n                head = next;\n                prev.next = next;\n                next.prev = prev;\n            }\n        } else {\n            prev.next = next;\n            next.prev = prev;\n        }\n    } else {\n    // Already deleted\n    }\n}\nfunction ensureCleanupIsScheduled() {\n    if (didScheduleCleanup || lruSize <= maxLruSize) {\n        return;\n    }\n    didScheduleCleanup = true;\n    requestCleanupCallback(cleanup);\n}\nfunction cleanup() {\n    didScheduleCleanup = false;\n    // Evict entries until we're at 90% capacity. We can assume this won't\n    // infinite loop because even if `maxLruSize` were 0, eventually\n    // `deleteFromLru` sets `head` to `null` when we run out entries.\n    const ninetyPercentMax = maxLruSize * 0.9;\n    while(lruSize > ninetyPercentMax && head !== null){\n        const tail = head.prev;\n        // In practice, this is never null, but that isn't encoded in the type\n        if (tail !== null) {\n            // Delete the entry from the map. In turn, this will remove it from\n            // the LRU.\n            (0, _cachemap.deleteMapEntry)(tail);\n        }\n    }\n}\nconst requestCleanupCallback = typeof requestIdleCallback === 'function' ? requestIdleCallback : (cb)=>setTimeout(cb, 0);\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=lru.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvc2VnbWVudC1jYWNoZS9scnUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBb0VnQkEsYUFBYTtlQUFiQTs7SUFyREFDLE1BQU07ZUFBTkE7O0lBdUNBQyxhQUFhO2VBQWJBOzs7c0NBdERlO0FBRy9CLDhFQUE4RTtBQUM5RSwyREFBMkQ7QUFFM0QsSUFBSUMsT0FBK0I7QUFDbkMsSUFBSUMscUJBQThCO0FBQ2xDLElBQUlDLFVBQWtCO0FBRXRCLCtFQUErRTtBQUMvRSwwRUFBMEU7QUFDMUUsNENBQTRDO0FBQzVDLE1BQU1DLGFBQWEsS0FBSyxPQUFPLEtBQUssUUFBUTs7QUFFckMsU0FBU0wsT0FBT00sSUFBcUI7SUFDMUMsSUFBSUosU0FBU0ksTUFBTTtRQUNqQixzQkFBc0I7UUFDdEI7SUFDRjtJQUNBLE1BQU1DLE9BQU9ELEtBQUtDLElBQUk7SUFDdEIsTUFBTUMsT0FBT0YsS0FBS0UsSUFBSTtJQUN0QixJQUFJQSxTQUFTLFFBQVFELFNBQVMsTUFBTTtRQUNsQyx1QkFBdUI7UUFDdkJILFdBQVdFLEtBQUtHLElBQUk7UUFDcEIsbUVBQW1FO1FBQ25FLHlFQUF5RTtRQUN6RSx3QkFBd0I7UUFDeEJDO0lBQ0YsT0FBTztRQUNMLG9EQUFvRDtRQUNwREgsS0FBS0MsSUFBSSxHQUFHQTtRQUNaQSxLQUFLRCxJQUFJLEdBQUdBO0lBQ2Q7SUFFQSxnQ0FBZ0M7SUFDaEMsSUFBSUwsU0FBUyxNQUFNO1FBQ2pCLDBCQUEwQjtRQUMxQkksS0FBS0MsSUFBSSxHQUFHRDtRQUNaQSxLQUFLRSxJQUFJLEdBQUdGO0lBQ2QsT0FBTztRQUNMLCtCQUErQjtRQUMvQixNQUFNSyxPQUFPVCxLQUFLSyxJQUFJO1FBQ3RCRCxLQUFLQyxJQUFJLEdBQUdJO1FBQ1osc0VBQXNFO1FBQ3RFLElBQUlBLFNBQVMsTUFBTTtZQUNqQkEsS0FBS0gsSUFBSSxHQUFHRjtRQUNkO1FBQ0FBLEtBQUtFLElBQUksR0FBR047UUFDWkEsS0FBS0ssSUFBSSxHQUFHRDtJQUNkO0lBQ0FKLE9BQU9JO0FBQ1Q7QUFFTyxTQUFTTCxjQUFjSyxJQUFxQixFQUFFTSxXQUFtQjtJQUN0RSx5RUFBeUU7SUFDekUsaUVBQWlFO0lBQ2pFLE1BQU1DLGVBQWVQLEtBQUtHLElBQUk7SUFDOUJILEtBQUtHLElBQUksR0FBR0c7SUFDWixJQUFJTixLQUFLRSxJQUFJLEtBQUssTUFBTTtRQUN0Qix3REFBd0Q7UUFDeEQ7SUFDRjtJQUNBLDRCQUE0QjtJQUM1QkosVUFBVUEsVUFBVVMsZUFBZUQ7SUFDbkNGO0FBQ0Y7QUFFTyxTQUFTWCxjQUFjZSxPQUF3QjtJQUNwRCxNQUFNTixPQUFPTSxRQUFRTixJQUFJO0lBQ3pCLE1BQU1ELE9BQU9PLFFBQVFQLElBQUk7SUFDekIsSUFBSUMsU0FBUyxRQUFRRCxTQUFTLE1BQU07UUFDbENILFdBQVdVLFFBQVFMLElBQUk7UUFFdkJLLFFBQVFOLElBQUksR0FBRztRQUNmTSxRQUFRUCxJQUFJLEdBQUc7UUFFZix1QkFBdUI7UUFDdkIsSUFBSUwsU0FBU1ksU0FBUztZQUNwQixrQkFBa0I7WUFDbEIsSUFBSU4sU0FBU04sTUFBTTtnQkFDakIsMEJBQTBCO2dCQUMxQkEsT0FBTztZQUNULE9BQU87Z0JBQ0xBLE9BQU9NO2dCQUNQRCxLQUFLQyxJQUFJLEdBQUdBO2dCQUNaQSxLQUFLRCxJQUFJLEdBQUdBO1lBQ2Q7UUFDRixPQUFPO1lBQ0xBLEtBQUtDLElBQUksR0FBR0E7WUFDWkEsS0FBS0QsSUFBSSxHQUFHQTtRQUNkO0lBQ0YsT0FBTztJQUNMLGtCQUFrQjtJQUNwQjtBQUNGO0FBRUEsU0FBU0c7SUFDUCxJQUFJUCxzQkFBc0JDLFdBQVdDLFlBQVk7UUFDL0M7SUFDRjtJQUNBRixxQkFBcUI7SUFDckJZLHVCQUF1QkM7QUFDekI7QUFFQSxTQUFTQTtJQUNQYixxQkFBcUI7SUFFckIsc0VBQXNFO0lBQ3RFLGdFQUFnRTtJQUNoRSxpRUFBaUU7SUFDakUsTUFBTWMsbUJBQW1CWixhQUFhO0lBQ3RDLE1BQU9ELFVBQVVhLG9CQUFvQmYsU0FBUyxLQUFNO1FBQ2xELE1BQU1TLE9BQU9ULEtBQUtLLElBQUk7UUFDdEIsc0VBQXNFO1FBQ3RFLElBQUlJLFNBQVMsTUFBTTtZQUNqQixtRUFBbUU7WUFDbkUsV0FBVztZQUNYTyxDQUFBQSxHQUFBQSxVQUFBQSxjQUFBQSxFQUFlUDtRQUNqQjtJQUNGO0FBQ0Y7QUFFQSxNQUFNSSx5QkFDSixPQUFPSSx3QkFBd0IsYUFDM0JBLHNCQUNBLENBQUNDLEtBQW1CQyxXQUFXRCxJQUFJIiwic291cmNlcyI6WyIvVXNlcnMvcnlhbnJvc3p0b2N6eS9zcmMvY2xpZW50L2NvbXBvbmVudHMvc2VnbWVudC1jYWNoZS9scnUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVsZXRlTWFwRW50cnkgfSBmcm9tICcuL2NhY2hlLW1hcCdcbmltcG9ydCB0eXBlIHsgVW5rbm93bk1hcEVudHJ5IH0gZnJvbSAnLi9jYWNoZS1tYXAnXG5cbi8vIFdlIHVzZSBhbiBMUlUgZm9yIG1lbW9yeSBtYW5hZ2VtZW50LiBXZSBtdXN0IHVwZGF0ZSB0aGlzIHdoZW5ldmVyIHdlIGFkZCBvclxuLy8gcmVtb3ZlIGEgbmV3IGNhY2hlIGVudHJ5LCBvciB3aGVuIGFuIGVudHJ5IGNoYW5nZXMgc2l6ZS5cblxubGV0IGhlYWQ6IFVua25vd25NYXBFbnRyeSB8IG51bGwgPSBudWxsXG5sZXQgZGlkU2NoZWR1bGVDbGVhbnVwOiBib29sZWFuID0gZmFsc2VcbmxldCBscnVTaXplOiBudW1iZXIgPSAwXG5cbi8vIFRPRE86IEkgY2hvc2UgdGhlIG1heCBzaXplIHNvbWV3aGF0IGFyYml0cmFyaWx5LiBDb25zaWRlciBzZXR0aW5nIHRoaXMgYmFzZWRcbi8vIG9uIG5hdmlnYXRvci5kZXZpY2VNZW1vcnksIG9yIHNvbWUgb3RoZXIgaGV1cmlzdGljLiBXZSBzaG91bGQgbWFrZSB0aGlzXG4vLyBjdXN0b21pemFibGUgdmlhIHRoZSBOZXh0LmpzIGNvbmZpZywgdG9vLlxuY29uc3QgbWF4THJ1U2l6ZSA9IDUwICogMTAyNCAqIDEwMjQgLy8gNTAgTUJcblxuZXhwb3J0IGZ1bmN0aW9uIGxydVB1dChub2RlOiBVbmtub3duTWFwRW50cnkpIHtcbiAgaWYgKGhlYWQgPT09IG5vZGUpIHtcbiAgICAvLyBBbHJlYWR5IGF0IHRoZSBoZWFkXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgcHJldiA9IG5vZGUucHJldlxuICBjb25zdCBuZXh0ID0gbm9kZS5uZXh0XG4gIGlmIChuZXh0ID09PSBudWxsIHx8IHByZXYgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvblxuICAgIGxydVNpemUgKz0gbm9kZS5zaXplXG4gICAgLy8gV2hlbmV2ZXIgd2UgYWRkIGFuIGVudHJ5LCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlJ3ZlIGV4Y2VlZGVkIHRoZVxuICAgIC8vIG1heCBzaXplLiBXZSBkb24ndCBldmljdCBlbnRyaWVzIGltbWVkaWF0ZWx5OyB0aGV5J3JlIGV2aWN0ZWQgbGF0ZXIgaW5cbiAgICAvLyBhbiBhc3luY2hyb25vdXMgdGFzay5cbiAgICBlbnN1cmVDbGVhbnVwSXNTY2hlZHVsZWQoKVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSBtb3ZlLiBSZW1vdmUgZnJvbSBpdHMgY3VycmVudCBwb3NpdGlvbi5cbiAgICBwcmV2Lm5leHQgPSBuZXh0XG4gICAgbmV4dC5wcmV2ID0gcHJldlxuICB9XG5cbiAgLy8gTW92ZSB0byB0aGUgZnJvbnQgb2YgdGhlIGxpc3RcbiAgaWYgKGhlYWQgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBlbnRyeVxuICAgIG5vZGUucHJldiA9IG5vZGVcbiAgICBub2RlLm5leHQgPSBub2RlXG4gIH0gZWxzZSB7XG4gICAgLy8gQWRkIHRvIHRoZSBmcm9udCBvZiB0aGUgbGlzdFxuICAgIGNvbnN0IHRhaWwgPSBoZWFkLnByZXZcbiAgICBub2RlLnByZXYgPSB0YWlsXG4gICAgLy8gSW4gcHJhY3RpY2UsIHRoaXMgaXMgbmV2ZXIgbnVsbCwgYnV0IHRoYXQgaXNuJ3QgZW5jb2RlZCBpbiB0aGUgdHlwZVxuICAgIGlmICh0YWlsICE9PSBudWxsKSB7XG4gICAgICB0YWlsLm5leHQgPSBub2RlXG4gICAgfVxuICAgIG5vZGUubmV4dCA9IGhlYWRcbiAgICBoZWFkLnByZXYgPSBub2RlXG4gIH1cbiAgaGVhZCA9IG5vZGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUxydVNpemUobm9kZTogVW5rbm93bk1hcEVudHJ5LCBuZXdOb2RlU2l6ZTogbnVtYmVyKSB7XG4gIC8vIFRoaXMgaXMgYSBzZXBhcmF0ZSBmdW5jdGlvbiBmcm9tIGBwdXRgIHNvIHRoYXQgd2UgY2FuIHJlc2l6ZSB0aGUgZW50cnlcbiAgLy8gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0J3MgY3VycmVudGx5IGJlaW5nIHRyYWNrZWQgYnkgdGhlIExSVS5cbiAgY29uc3QgcHJldk5vZGVTaXplID0gbm9kZS5zaXplXG4gIG5vZGUuc2l6ZSA9IG5ld05vZGVTaXplXG4gIGlmIChub2RlLm5leHQgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGVudHJ5IGlzIG5vdCBjdXJyZW50bHkgYmVpbmcgdHJhY2tlZCBieSB0aGUgTFJVLlxuICAgIHJldHVyblxuICB9XG4gIC8vIFVwZGF0ZSB0aGUgdG90YWwgTFJVIHNpemVcbiAgbHJ1U2l6ZSA9IGxydVNpemUgLSBwcmV2Tm9kZVNpemUgKyBuZXdOb2RlU2l6ZVxuICBlbnN1cmVDbGVhbnVwSXNTY2hlZHVsZWQoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlRnJvbUxydShkZWxldGVkOiBVbmtub3duTWFwRW50cnkpIHtcbiAgY29uc3QgbmV4dCA9IGRlbGV0ZWQubmV4dFxuICBjb25zdCBwcmV2ID0gZGVsZXRlZC5wcmV2XG4gIGlmIChuZXh0ICE9PSBudWxsICYmIHByZXYgIT09IG51bGwpIHtcbiAgICBscnVTaXplIC09IGRlbGV0ZWQuc2l6ZVxuXG4gICAgZGVsZXRlZC5uZXh0ID0gbnVsbFxuICAgIGRlbGV0ZWQucHJldiA9IG51bGxcblxuICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBsaXN0XG4gICAgaWYgKGhlYWQgPT09IGRlbGV0ZWQpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgaGVhZFxuICAgICAgaWYgKG5leHQgPT09IGhlYWQpIHtcbiAgICAgICAgLy8gVGhpcyB3YXMgdGhlIGxhc3QgZW50cnlcbiAgICAgICAgaGVhZCA9IG51bGxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYWQgPSBuZXh0XG4gICAgICAgIHByZXYubmV4dCA9IG5leHRcbiAgICAgICAgbmV4dC5wcmV2ID0gcHJldlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2Lm5leHQgPSBuZXh0XG4gICAgICBuZXh0LnByZXYgPSBwcmV2XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEFscmVhZHkgZGVsZXRlZFxuICB9XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUNsZWFudXBJc1NjaGVkdWxlZCgpIHtcbiAgaWYgKGRpZFNjaGVkdWxlQ2xlYW51cCB8fCBscnVTaXplIDw9IG1heExydVNpemUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkaWRTY2hlZHVsZUNsZWFudXAgPSB0cnVlXG4gIHJlcXVlc3RDbGVhbnVwQ2FsbGJhY2soY2xlYW51cClcbn1cblxuZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgZGlkU2NoZWR1bGVDbGVhbnVwID0gZmFsc2VcblxuICAvLyBFdmljdCBlbnRyaWVzIHVudGlsIHdlJ3JlIGF0IDkwJSBjYXBhY2l0eS4gV2UgY2FuIGFzc3VtZSB0aGlzIHdvbid0XG4gIC8vIGluZmluaXRlIGxvb3AgYmVjYXVzZSBldmVuIGlmIGBtYXhMcnVTaXplYCB3ZXJlIDAsIGV2ZW50dWFsbHlcbiAgLy8gYGRlbGV0ZUZyb21McnVgIHNldHMgYGhlYWRgIHRvIGBudWxsYCB3aGVuIHdlIHJ1biBvdXQgZW50cmllcy5cbiAgY29uc3QgbmluZXR5UGVyY2VudE1heCA9IG1heExydVNpemUgKiAwLjlcbiAgd2hpbGUgKGxydVNpemUgPiBuaW5ldHlQZXJjZW50TWF4ICYmIGhlYWQgIT09IG51bGwpIHtcbiAgICBjb25zdCB0YWlsID0gaGVhZC5wcmV2XG4gICAgLy8gSW4gcHJhY3RpY2UsIHRoaXMgaXMgbmV2ZXIgbnVsbCwgYnV0IHRoYXQgaXNuJ3QgZW5jb2RlZCBpbiB0aGUgdHlwZVxuICAgIGlmICh0YWlsICE9PSBudWxsKSB7XG4gICAgICAvLyBEZWxldGUgdGhlIGVudHJ5IGZyb20gdGhlIG1hcC4gSW4gdHVybiwgdGhpcyB3aWxsIHJlbW92ZSBpdCBmcm9tXG4gICAgICAvLyB0aGUgTFJVLlxuICAgICAgZGVsZXRlTWFwRW50cnkodGFpbClcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgcmVxdWVzdENsZWFudXBDYWxsYmFjayA9XG4gIHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrID09PSAnZnVuY3Rpb24nXG4gICAgPyByZXF1ZXN0SWRsZUNhbGxiYWNrXG4gICAgOiAoY2I6ICgpID0+IHZvaWQpID0+IHNldFRpbWVvdXQoY2IsIDApXG4iXSwibmFtZXMiOlsiZGVsZXRlRnJvbUxydSIsImxydVB1dCIsInVwZGF0ZUxydVNpemUiLCJoZWFkIiwiZGlkU2NoZWR1bGVDbGVhbnVwIiwibHJ1U2l6ZSIsIm1heExydVNpemUiLCJub2RlIiwicHJldiIsIm5leHQiLCJzaXplIiwiZW5zdXJlQ2xlYW51cElzU2NoZWR1bGVkIiwidGFpbCIsIm5ld05vZGVTaXplIiwicHJldk5vZGVTaXplIiwiZGVsZXRlZCIsInJlcXVlc3RDbGVhbnVwQ2FsbGJhY2siLCJjbGVhbnVwIiwibmluZXR5UGVyY2VudE1heCIsImRlbGV0ZU1hcEVudHJ5IiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNiIiwic2V0VGltZW91dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache/lru.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/use-action-queue.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/use-action-queue.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    dispatchAppRouterAction: function() {\n        return dispatchAppRouterAction;\n    },\n    useActionQueue: function() {\n        return useActionQueue;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _isthenable = __webpack_require__(/*! ../../shared/lib/is-thenable */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/is-thenable.js\");\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch = null;\nfunction dispatchAppRouterAction(action) {\n    if (dispatch === null) {\n        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E668\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    dispatch(action);\n}\nconst __DEV__ = \"development\" !== 'production';\nconst promisesWithDebugInfo = __DEV__ ? new WeakMap() : null;\nfunction useActionQueue(actionQueue) {\n    _s();\n    const [state, setState] = _react.default.useState(actionQueue.state);\n    // Because of a known issue that requires to decode Flight streams inside the\n    // render phase, we have to be a bit clever and assign the dispatch method to\n    // a module-level variable upon initialization. The useState hook in this\n    // module only exists to synchronize state that lives outside of React.\n    // Ideally, what we'd do instead is pass the state as a prop to root.render;\n    // this is conceptually how we're modeling the app router state, despite the\n    // weird implementation details.\n    if (true) {\n        const { useAppDevRenderingIndicator } = __webpack_require__(/*! ../../next-devtools/userspace/use-app-dev-rendering-indicator */ \"(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/use-app-dev-rendering-indicator.js\");\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const appDevRenderingIndicator = useAppDevRenderingIndicator();\n        dispatch = (action)=>{\n            appDevRenderingIndicator(()=>{\n                actionQueue.dispatch(action, setState);\n            });\n        };\n    } else {}\n    // When navigating to a non-prefetched route, then App Router state will be\n    // blocked until the server responds. We need to transfer the `_debugInfo`\n    // from the underlying Flight response onto the top-level promise that is\n    // passed to React (via `use`) so that the latency is accurately represented\n    // in the React DevTools.\n    const stateWithDebugInfo = (0, _react.useMemo)(()=>{\n        if (!__DEV__) {\n            return state;\n        }\n        if ((0, _isthenable.isThenable)(state)) {\n            // useMemo can't be used to cache a Promise since the memoized value is thrown\n            // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n            let promiseWithDebugInfo = promisesWithDebugInfo.get(state);\n            if (promiseWithDebugInfo === undefined) {\n                const debugInfo = [];\n                promiseWithDebugInfo = Promise.resolve(state).then((asyncState)=>{\n                    if (asyncState.debugInfo !== null) {\n                        debugInfo.push(...asyncState.debugInfo);\n                    }\n                    return asyncState;\n                });\n                promiseWithDebugInfo._debugInfo = debugInfo;\n                promisesWithDebugInfo.set(state, promiseWithDebugInfo);\n            }\n            return promiseWithDebugInfo;\n        }\n        return state;\n    }, [\n        state\n    ]);\n    return (0, _isthenable.isThenable)(stateWithDebugInfo) ? (0, _react.use)(stateWithDebugInfo) : stateWithDebugInfo;\n}\n_s(useActionQueue, \"Rp0Tj1zyE8LTecjN/cjTzn46xPo=\");\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-action-queue.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvdXNlLWFjdGlvbi1xdWV1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQWVnQkEsdUJBQXVCO2VBQXZCQTs7SUFlQUMsY0FBYztlQUFkQTs7Ozs2RUE3Qm9CO3dDQUNUO0FBUTNCLDZFQUE2RTtBQUM3RSwrRUFBK0U7QUFDL0UsY0FBYztBQUNkLElBQUlDLFdBQTRDO0FBRXpDLFNBQVNGLHdCQUF3QkcsTUFBc0I7SUFDNUQsSUFBSUQsYUFBYSxNQUFNO1FBQ3JCLE1BQU0scUJBRUwsQ0FGSyxJQUFJRSxNQUNSLDRFQURJO21CQUFBO3dCQUFBOzBCQUFBO1FBRU47SUFDRjtJQUNBRixTQUFTQztBQUNYO0FBRUEsTUFBTUUsVUFBVUMsUUFBUUMsR0FBRyxDQUFDQyxNQUFhLEVBQUw7QUFDcEMsTUFBTUMsd0JBR0ZKLFVBQVUsSUFBSUssWUFBYTtBQUV4Qix3QkFDTEMsV0FBaUM7O0lBRWpDLE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHQyxPQUFBQSxPQUFLLENBQUNDLFFBQVEsQ0FBZUosWUFBWUMsS0FBSztJQUV4RSw2RUFBNkU7SUFDN0UsNkVBQTZFO0lBQzdFLHlFQUF5RTtJQUN6RSx1RUFBdUU7SUFDdkUsNEVBQTRFO0lBQzVFLDRFQUE0RTtJQUM1RSxnQ0FBZ0M7SUFDaEMsSUFBSU4sSUFBb0IsRUFBbUI7UUFDekMsTUFBTSxFQUFFVSwyQkFBMkIsRUFBRSxHQUNuQ0MsbUJBQU9BLENBQUMsOEtBQStEO1FBQ3pFLHNEQUFzRDtRQUN0RCxNQUFNQywyQkFBMkJGO1FBRWpDZCxXQUFXLENBQUNDO1lBQ1ZlLHlCQUF5QjtnQkFDdkJQLFlBQVlULFFBQVEsQ0FBQ0MsUUFBUVU7WUFDL0I7UUFDRjtJQUNGLE9BQU8sRUFHTjtJQUVELDJFQUEyRTtJQUMzRSwwRUFBMEU7SUFDMUUseUVBQXlFO0lBQ3pFLDRFQUE0RTtJQUM1RSx5QkFBeUI7SUFDekIsTUFBTU0scUJBQXFCQyxDQUFBQSxHQUFBQSxPQUFBQSxPQUFBQSxFQUFRO1FBQ2pDLElBQUksQ0FBQ2YsU0FBUztZQUNaLE9BQU9PO1FBQ1Q7UUFFQSxJQUFJUyxDQUFBQSxHQUFBQSxZQUFBQSxVQUFBQSxFQUFXVCxRQUFRO1lBQ3JCLDhFQUE4RTtZQUM5RSxrRkFBa0Y7WUFDbEYsSUFBSVUsdUJBQXVCYixzQkFBc0JjLEdBQUcsQ0FBQ1g7WUFDckQsSUFBSVUseUJBQXlCRSxXQUFXO2dCQUN0QyxNQUFNQyxZQUE0QixFQUFFO2dCQUNwQ0gsdUJBQXVCSSxRQUFRQyxPQUFPLENBQUNmLE9BQU9nQixJQUFJLENBQUMsQ0FBQ0M7b0JBQ2xELElBQUlBLFdBQVdKLFNBQVMsS0FBSyxNQUFNO3dCQUNqQ0EsVUFBVUssSUFBSSxJQUFJRCxXQUFXSixTQUFTO29CQUN4QztvQkFDQSxPQUFPSTtnQkFDVDtnQkFDQVAscUJBQXFCUyxVQUFVLEdBQUdOO2dCQUVsQ2hCLHNCQUFzQnVCLEdBQUcsQ0FBQ3BCLE9BQU9VO1lBQ25DO1lBRUEsT0FBT0E7UUFDVDtRQUNBLE9BQU9WO0lBQ1QsR0FBRztRQUFDQTtLQUFNO0lBRVYsT0FBT1MsQ0FBQUEsR0FBQUEsWUFBQUEsVUFBVSxFQUFDRixzQkFDZGMsQ0FBQUEsR0FBQUEsT0FBQUEsR0FBQUEsRUFBSWQsc0JBQ0pBO0FBQ047R0EvRGdCbEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yeWFucm9zenRvY3p5L0RldmVsb3BtZW50L3NyYy9jbGllbnQvY29tcG9uZW50cy91c2UtYWN0aW9uLXF1ZXVlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRGlzcGF0Y2ggfSBmcm9tICdyZWFjdCdcbmltcG9ydCBSZWFjdCwgeyB1c2UsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGlzVGhlbmFibGUgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2lzLXRoZW5hYmxlJ1xuaW1wb3J0IHR5cGUgeyBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSB9IGZyb20gJy4vYXBwLXJvdXRlci1pbnN0YW5jZSdcbmltcG9ydCB0eXBlIHtcbiAgQXBwUm91dGVyU3RhdGUsXG4gIFJlZHVjZXJBY3Rpb25zLFxuICBSZWR1Y2VyU3RhdGUsXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5cbi8vIFRoZSBhcHAgcm91dGVyIHN0YXRlIGxpdmVzIG91dHNpZGUgb2YgUmVhY3QsIHNvIHdlIGNhbiBpbXBvcnQgdGhlIGRpc3BhdGNoXG4vLyBtZXRob2QgZGlyZWN0bHkgd2hlcmV2ZXIgd2UgbmVlZCBpdCwgcmF0aGVyIHRoYW4gcGFzc2luZyBpdCBhcm91bmQgdmlhIHByb3BzXG4vLyBvciBjb250ZXh0LlxubGV0IGRpc3BhdGNoOiBEaXNwYXRjaDxSZWR1Y2VyQWN0aW9ucz4gfCBudWxsID0gbnVsbFxuXG5leHBvcnQgZnVuY3Rpb24gZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oYWN0aW9uOiBSZWR1Y2VyQWN0aW9ucykge1xuICBpZiAoZGlzcGF0Y2ggPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW50ZXJuYWwgTmV4dC5qcyBlcnJvcjogUm91dGVyIGFjdGlvbiBkaXNwYXRjaGVkIGJlZm9yZSBpbml0aWFsaXphdGlvbi4nXG4gICAgKVxuICB9XG4gIGRpc3BhdGNoKGFjdGlvbilcbn1cblxuY29uc3QgX19ERVZfXyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbmNvbnN0IHByb21pc2VzV2l0aERlYnVnSW5mbzogV2Vha01hcDxcbiAgUHJvbWlzZTxBcHBSb3V0ZXJTdGF0ZT4sXG4gIFByb21pc2U8QXBwUm91dGVyU3RhdGU+ICYgeyBfZGVidWdJbmZvPzogQXJyYXk8dW5rbm93bj4gfVxuPiA9IF9fREVWX18gPyBuZXcgV2Vha01hcCgpIDogKG51bGwgYXMgYW55KVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQWN0aW9uUXVldWUoXG4gIGFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZVxuKTogQXBwUm91dGVyU3RhdGUge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlPFJlZHVjZXJTdGF0ZT4oYWN0aW9uUXVldWUuc3RhdGUpXG5cbiAgLy8gQmVjYXVzZSBvZiBhIGtub3duIGlzc3VlIHRoYXQgcmVxdWlyZXMgdG8gZGVjb2RlIEZsaWdodCBzdHJlYW1zIGluc2lkZSB0aGVcbiAgLy8gcmVuZGVyIHBoYXNlLCB3ZSBoYXZlIHRvIGJlIGEgYml0IGNsZXZlciBhbmQgYXNzaWduIHRoZSBkaXNwYXRjaCBtZXRob2QgdG9cbiAgLy8gYSBtb2R1bGUtbGV2ZWwgdmFyaWFibGUgdXBvbiBpbml0aWFsaXphdGlvbi4gVGhlIHVzZVN0YXRlIGhvb2sgaW4gdGhpc1xuICAvLyBtb2R1bGUgb25seSBleGlzdHMgdG8gc3luY2hyb25pemUgc3RhdGUgdGhhdCBsaXZlcyBvdXRzaWRlIG9mIFJlYWN0LlxuICAvLyBJZGVhbGx5LCB3aGF0IHdlJ2QgZG8gaW5zdGVhZCBpcyBwYXNzIHRoZSBzdGF0ZSBhcyBhIHByb3AgdG8gcm9vdC5yZW5kZXI7XG4gIC8vIHRoaXMgaXMgY29uY2VwdHVhbGx5IGhvdyB3ZSdyZSBtb2RlbGluZyB0aGUgYXBwIHJvdXRlciBzdGF0ZSwgZGVzcGl0ZSB0aGVcbiAgLy8gd2VpcmQgaW1wbGVtZW50YXRpb24gZGV0YWlscy5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCB7IHVzZUFwcERldlJlbmRlcmluZ0luZGljYXRvciB9ID1cbiAgICAgIHJlcXVpcmUoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL3VzZS1hcHAtZGV2LXJlbmRlcmluZy1pbmRpY2F0b3InKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS91c2UtYXBwLWRldi1yZW5kZXJpbmctaW5kaWNhdG9yJylcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBjb25zdCBhcHBEZXZSZW5kZXJpbmdJbmRpY2F0b3IgPSB1c2VBcHBEZXZSZW5kZXJpbmdJbmRpY2F0b3IoKVxuXG4gICAgZGlzcGF0Y2ggPSAoYWN0aW9uOiBSZWR1Y2VyQWN0aW9ucykgPT4ge1xuICAgICAgYXBwRGV2UmVuZGVyaW5nSW5kaWNhdG9yKCgpID0+IHtcbiAgICAgICAgYWN0aW9uUXVldWUuZGlzcGF0Y2goYWN0aW9uLCBzZXRTdGF0ZSlcbiAgICAgIH0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpc3BhdGNoID0gKGFjdGlvbjogUmVkdWNlckFjdGlvbnMpID0+XG4gICAgICBhY3Rpb25RdWV1ZS5kaXNwYXRjaChhY3Rpb24sIHNldFN0YXRlKVxuICB9XG5cbiAgLy8gV2hlbiBuYXZpZ2F0aW5nIHRvIGEgbm9uLXByZWZldGNoZWQgcm91dGUsIHRoZW4gQXBwIFJvdXRlciBzdGF0ZSB3aWxsIGJlXG4gIC8vIGJsb2NrZWQgdW50aWwgdGhlIHNlcnZlciByZXNwb25kcy4gV2UgbmVlZCB0byB0cmFuc2ZlciB0aGUgYF9kZWJ1Z0luZm9gXG4gIC8vIGZyb20gdGhlIHVuZGVybHlpbmcgRmxpZ2h0IHJlc3BvbnNlIG9udG8gdGhlIHRvcC1sZXZlbCBwcm9taXNlIHRoYXQgaXNcbiAgLy8gcGFzc2VkIHRvIFJlYWN0ICh2aWEgYHVzZWApIHNvIHRoYXQgdGhlIGxhdGVuY3kgaXMgYWNjdXJhdGVseSByZXByZXNlbnRlZFxuICAvLyBpbiB0aGUgUmVhY3QgRGV2VG9vbHMuXG4gIGNvbnN0IHN0YXRlV2l0aERlYnVnSW5mbyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghX19ERVZfXykge1xuICAgICAgcmV0dXJuIHN0YXRlXG4gICAgfVxuXG4gICAgaWYgKGlzVGhlbmFibGUoc3RhdGUpKSB7XG4gICAgICAvLyB1c2VNZW1vIGNhbid0IGJlIHVzZWQgdG8gY2FjaGUgYSBQcm9taXNlIHNpbmNlIHRoZSBtZW1vaXplZCB2YWx1ZSBpcyB0aHJvd25cbiAgICAgIC8vIGF3YXkgd2hlbiB3ZSBzdXNwZW5kLiBTbyB3ZSB1c2UgYSBXZWFrTWFwIHRvIGNhY2hlIHRoZSBQcm9taXNlIHdpdGggZGVidWcgaW5mby5cbiAgICAgIGxldCBwcm9taXNlV2l0aERlYnVnSW5mbyA9IHByb21pc2VzV2l0aERlYnVnSW5mby5nZXQoc3RhdGUpXG4gICAgICBpZiAocHJvbWlzZVdpdGhEZWJ1Z0luZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBkZWJ1Z0luZm86IEFycmF5PHVua25vd24+ID0gW11cbiAgICAgICAgcHJvbWlzZVdpdGhEZWJ1Z0luZm8gPSBQcm9taXNlLnJlc29sdmUoc3RhdGUpLnRoZW4oKGFzeW5jU3RhdGUpID0+IHtcbiAgICAgICAgICBpZiAoYXN5bmNTdGF0ZS5kZWJ1Z0luZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKC4uLmFzeW5jU3RhdGUuZGVidWdJbmZvKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXN5bmNTdGF0ZVxuICAgICAgICB9KSBhcyBQcm9taXNlPEFwcFJvdXRlclN0YXRlPiAmIHsgX2RlYnVnSW5mbz86IEFycmF5PHVua25vd24+IH1cbiAgICAgICAgcHJvbWlzZVdpdGhEZWJ1Z0luZm8uX2RlYnVnSW5mbyA9IGRlYnVnSW5mb1xuXG4gICAgICAgIHByb21pc2VzV2l0aERlYnVnSW5mby5zZXQoc3RhdGUsIHByb21pc2VXaXRoRGVidWdJbmZvKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZVdpdGhEZWJ1Z0luZm9cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlXG4gIH0sIFtzdGF0ZV0pXG5cbiAgcmV0dXJuIGlzVGhlbmFibGUoc3RhdGVXaXRoRGVidWdJbmZvKVxuICAgID8gdXNlKHN0YXRlV2l0aERlYnVnSW5mbylcbiAgICA6IHN0YXRlV2l0aERlYnVnSW5mb1xufVxuIl0sIm5hbWVzIjpbImRpc3BhdGNoQXBwUm91dGVyQWN0aW9uIiwidXNlQWN0aW9uUXVldWUiLCJkaXNwYXRjaCIsImFjdGlvbiIsIkVycm9yIiwiX19ERVZfXyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInByb21pc2VzV2l0aERlYnVnSW5mbyIsIldlYWtNYXAiLCJhY3Rpb25RdWV1ZSIsInN0YXRlIiwic2V0U3RhdGUiLCJSZWFjdCIsInVzZVN0YXRlIiwidXNlQXBwRGV2UmVuZGVyaW5nSW5kaWNhdG9yIiwicmVxdWlyZSIsImFwcERldlJlbmRlcmluZ0luZGljYXRvciIsInN0YXRlV2l0aERlYnVnSW5mbyIsInVzZU1lbW8iLCJpc1RoZW5hYmxlIiwicHJvbWlzZVdpdGhEZWJ1Z0luZm8iLCJnZXQiLCJ1bmRlZmluZWQiLCJkZWJ1Z0luZm8iLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJhc3luY1N0YXRlIiwicHVzaCIsIl9kZWJ1Z0luZm8iLCJzZXQiLCJ1c2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/use-action-queue.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js ***!
  \******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// This file is only used in app router due to the specific error state handling.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    onCaughtError: function() {\n        return onCaughtError;\n    },\n    onUncaughtError: function() {\n        return onUncaughtError;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _isnextroutererror = __webpack_require__(/*! ../components/is-next-router-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/is-next-router-error.js\");\nconst _bailouttocsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nconst _reportglobalerror = __webpack_require__(/*! ./report-global-error */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/report-global-error.js\");\nconst _errorboundary = __webpack_require__(/*! ../components/error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\");\nconst _globalerror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../components/builtin/global-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/builtin/global-error.js\"));\nconst devToolErrorMod =  true ? __webpack_require__(/*! ../../next-devtools/userspace/app/errors */ \"(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/index.js\") : 0;\nfunction onCaughtError(thrownValue, errorInfo) {\n    const errorBoundaryComponent = errorInfo.errorBoundary?.constructor;\n    let isImplicitErrorBoundary;\n    if (true) {\n        const { AppDevOverlayErrorBoundary } = __webpack_require__(/*! ../../next-devtools/userspace/app/app-dev-overlay-error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-error-boundary.js\");\n        isImplicitErrorBoundary = errorBoundaryComponent === AppDevOverlayErrorBoundary;\n    }\n    isImplicitErrorBoundary = isImplicitErrorBoundary || errorBoundaryComponent === _errorboundary.ErrorBoundaryHandler && errorInfo.errorBoundary.props.errorComponent === _globalerror.default;\n    // Skip the segment explorer triggered error\n    if (true) {\n        const { SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE } = __webpack_require__(/*! ../../next-devtools/userspace/app/segment-explorer-node */ \"(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js\");\n        if (thrownValue instanceof Error && thrownValue.message === SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE) {\n            return;\n        }\n    }\n    if (isImplicitErrorBoundary) {\n        // We don't consider errors caught unless they're caught by an explicit error\n        // boundary. The built-in ones are considered implicit.\n        // This mimics how the same app would behave without Next.js.\n        return onUncaughtError(thrownValue);\n    }\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(thrownValue) || (0, _isnextroutererror.isNextRouterError)(thrownValue)) return;\n    if (true) {\n        const errorBoundaryName = errorBoundaryComponent?.displayName || errorBoundaryComponent?.name || 'Unknown';\n        const componentThatErroredFrame = errorInfo?.componentStack?.split('\\n')[1];\n        // Match chrome or safari stack trace\n        const matches = // example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)\n        // example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1\n        componentThatErroredFrame?.match(/\\s+at (\\w+)\\s+|(\\w+)@/) ?? [];\n        const componentThatErroredName = matches[1] || matches[2] || 'Unknown';\n        // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n        const errorBoundaryMessage = `It was handled by the <${errorBoundaryName}> error boundary.`;\n        const componentErrorMessage = componentThatErroredName ? `The above error occurred in the <${componentThatErroredName}> component.` : `The above error occurred in one of your components.`;\n        const errorLocation = `${componentErrorMessage} ${errorBoundaryMessage}`;\n        const error = devToolErrorMod.decorateDevError(thrownValue);\n        // Log and report the error with location but without modifying the error stack\n        devToolErrorMod.originConsoleError('%o\\n\\n%s', thrownValue, errorLocation);\n        devToolErrorMod.handleClientError(error);\n    } else {}\n}\nfunction onUncaughtError(thrownValue) {\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(thrownValue) || (0, _isnextroutererror.isNextRouterError)(thrownValue)) return;\n    if (true) {\n        const error = devToolErrorMod.decorateDevError(thrownValue);\n        // TODO: Add an adendum to the overlay telling people about custom error boundaries.\n        (0, _reportglobalerror.reportGlobalError)(error);\n    } else {}\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary-callbacks.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlYWN0LWNsaWVudC1jYWxsYmFja3MvZXJyb3ItYm91bmRhcnktY2FsbGJhY2tzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlGQUFpRjs7Ozs7Ozs7Ozs7OztJQWtCakVBLGFBQWE7ZUFBYkE7O0lBK0VBQyxlQUFlO2VBQWZBOzs7OytDQTlGa0I7MENBQ0U7K0NBQ0Y7MkNBQ0c7a0ZBQ0o7QUFFakMsTUFBTUMsa0JBQ0pDLEtBQW9CLEdBQ2ZHLG1CQUFPQSxDQUFDLDBJQUEwQyxJQUNuRCxDQUlDO0FBRUEsU0FBU04sY0FDZGEsV0FBb0IsRUFDcEJDLFNBQTBEO0lBRTFELE1BQU1DLHlCQUF5QkQsVUFBVUUsYUFBYSxFQUFFQztJQUV4RCxJQUFJQztJQUVKLElBQUlmLElBQW9CLEVBQW1CO1FBQ3pDLE1BQU0sRUFBRWdCLDBCQUEwQixFQUFFLEdBQ2xDYixtQkFBT0EsQ0FBQyxvTEFBa0U7UUFFNUVZLDBCQUNFSCwyQkFBMkJJO0lBQy9CO0lBRUFELDBCQUNFQSwyQkFDQ0gsMkJBQTJCSyxlQUFBQSxvQkFBb0IsSUFDN0NOLFVBQVVFLGFBQWEsQ0FDckJLLEtBQUssQ0FBQ0MsY0FBYyxLQUFLQyxhQUFBQSxPQUFvQjtJQUVwRCw0Q0FBNEM7SUFDNUMsSUFBSXBCLElBQW9CLEVBQW1CO1FBQ3pDLE1BQU0sRUFBRXFCLHdDQUF3QyxFQUFFLEdBQ2hEbEIsbUJBQU9BLENBQUMsa0tBQXlEO1FBQ25FLElBQ0VPLHVCQUF1QlksU0FDdkJaLFlBQVlhLE9BQU8sS0FBS0YsMENBQ3hCO1lBQ0E7UUFDRjtJQUNGO0lBRUEsSUFBSU4seUJBQXlCO1FBQzNCLDZFQUE2RTtRQUM3RSx1REFBdUQ7UUFDdkQsNkRBQTZEO1FBQzdELE9BQU9qQixnQkFBZ0JZO0lBQ3pCO0lBRUEsNkVBQTZFO0lBQzdFLElBQUljLENBQUFBLEdBQUFBLGNBQUFBLG1CQUFBQSxFQUFvQmQsZ0JBQWdCZSxDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCZixjQUFjO0lBRXhFLElBQUlWLElBQW9CLEVBQW1CO1FBQ3pDLE1BQU0wQixvQkFDSix3QkFDaUNDLFdBREUsSUFFbkNmLHdCQUF3QmdCLFFBQ3hCO1FBRUYsTUFBTUMsNEJBQTRCbEIsV0FBV21CLGdCQUFnQkMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUUzRSxxQ0FBcUM7UUFDckMsTUFBTUMsVUFFSixzREFEc0QsK0NBQytDO1FBQ3JHLGdHQUFnRztRQUNoR0gsMkJBQTJCSSxNQUFNLDRCQUE0QixFQUFFO1FBQ2pFLE1BQU1DLDJCQUEyQkYsT0FBTyxDQUFDLEVBQUUsSUFBSUEsT0FBTyxDQUFDLEVBQUUsSUFBSTtRQUU3RCxpSUFBaUk7UUFDakksTUFBTUcsdUJBQXVCLENBQUMsdUJBQXVCLEVBQUVULGtCQUFrQixpQkFBaUIsQ0FBQztRQUMzRixNQUFNVSx3QkFBd0JGLDJCQUMxQixDQUFDLGlDQUFpQyxFQUFFQSx5QkFBeUIsWUFBWSxDQUFDLEdBQzFFLENBQUMsbURBQW1ELENBQUM7UUFFekQsTUFBTUcsZ0JBQWdCLEdBQUdELHNCQUFzQixDQUFDLEVBQUVELHNCQUFzQjtRQUN4RSxNQUFNOUIsUUFBUU4sZ0JBQWdCSyxnQkFBZ0IsQ0FBQ007UUFFL0MsK0VBQStFO1FBQy9FWCxnQkFBZ0JRLGtCQUFrQixDQUFDLFlBQVlHLGFBQWEyQjtRQUU1RHRDLGdCQUFnQk8saUJBQWlCLENBQUNEO0lBQ3BDLE9BQU8sRUFFTjtBQUNIO0FBRU8sU0FBU1AsZ0JBQWdCWSxXQUFvQjtJQUNsRCw2RUFBNkU7SUFDN0UsSUFBSWMsQ0FBQUEsR0FBQUEsY0FBQUEsbUJBQUFBLEVBQW9CZCxnQkFBZ0JlLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JmLGNBQWM7SUFFeEUsSUFBSVYsSUFBb0IsRUFBbUI7UUFDekMsTUFBTUssUUFBUU4sZ0JBQWdCSyxnQkFBZ0IsQ0FBQ007UUFFL0Msb0ZBQW9GO1FBQ3BGNEIsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFBQSxFQUFrQmpDO0lBQ3BCLE9BQU8sRUFFTjtBQUNIIiwic291cmNlcyI6WyIvVXNlcnMvcnlhbnJvc3p0b2N6eS9EZXZlbG9wbWVudC9zcmMvY2xpZW50L3JlYWN0LWNsaWVudC1jYWxsYmFja3MvZXJyb3ItYm91bmRhcnktY2FsbGJhY2tzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBpcyBvbmx5IHVzZWQgaW4gYXBwIHJvdXRlciBkdWUgdG8gdGhlIHNwZWNpZmljIGVycm9yIHN0YXRlIGhhbmRsaW5nLlxuXG5pbXBvcnQgdHlwZSB7IEVycm9ySW5mbyB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgaXNOZXh0Um91dGVyRXJyb3IgfSBmcm9tICcuLi9jb21wb25lbnRzL2lzLW5leHQtcm91dGVyLWVycm9yJ1xuaW1wb3J0IHsgaXNCYWlsb3V0VG9DU1JFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvbGF6eS1keW5hbWljL2JhaWxvdXQtdG8tY3NyJ1xuaW1wb3J0IHsgcmVwb3J0R2xvYmFsRXJyb3IgfSBmcm9tICcuL3JlcG9ydC1nbG9iYWwtZXJyb3InXG5pbXBvcnQgeyBFcnJvckJvdW5kYXJ5SGFuZGxlciB9IGZyb20gJy4uL2NvbXBvbmVudHMvZXJyb3ItYm91bmRhcnknXG5pbXBvcnQgRGVmYXVsdEVycm9yQm91bmRhcnkgZnJvbSAnLi4vY29tcG9uZW50cy9idWlsdGluL2dsb2JhbC1lcnJvcidcblxuY29uc3QgZGV2VG9vbEVycm9yTW9kOiB0eXBlb2YgaW1wb3J0KCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvZXJyb3JzJykgPVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyAocmVxdWlyZSgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2Vycm9ycycpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9lcnJvcnMnKSlcbiAgICA6IHtcbiAgICAgICAgZGVjb3JhdGVEZXZFcnJvcjogKGVycm9yOiB1bmtub3duKSA9PiBlcnJvciBhcyBFcnJvcixcbiAgICAgICAgaGFuZGxlQ2xpZW50RXJyb3I6ICgpID0+IHt9LFxuICAgICAgICBvcmlnaW5Db25zb2xlRXJyb3I6IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSxcbiAgICAgIH1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uQ2F1Z2h0RXJyb3IoXG4gIHRocm93blZhbHVlOiB1bmtub3duLFxuICBlcnJvckluZm86IEVycm9ySW5mbyAmIHsgZXJyb3JCb3VuZGFyeT86IFJlYWN0LkNvbXBvbmVudCB9XG4pIHtcbiAgY29uc3QgZXJyb3JCb3VuZGFyeUNvbXBvbmVudCA9IGVycm9ySW5mby5lcnJvckJvdW5kYXJ5Py5jb25zdHJ1Y3RvclxuXG4gIGxldCBpc0ltcGxpY2l0RXJyb3JCb3VuZGFyeVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgeyBBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeSB9ID1cbiAgICAgIHJlcXVpcmUoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9hcHAtZGV2LW92ZXJsYXktZXJyb3ItYm91bmRhcnknKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvYXBwLWRldi1vdmVybGF5LWVycm9yLWJvdW5kYXJ5JylcblxuICAgIGlzSW1wbGljaXRFcnJvckJvdW5kYXJ5ID1cbiAgICAgIGVycm9yQm91bmRhcnlDb21wb25lbnQgPT09IEFwcERldk92ZXJsYXlFcnJvckJvdW5kYXJ5XG4gIH1cblxuICBpc0ltcGxpY2l0RXJyb3JCb3VuZGFyeSA9XG4gICAgaXNJbXBsaWNpdEVycm9yQm91bmRhcnkgfHxcbiAgICAoZXJyb3JCb3VuZGFyeUNvbXBvbmVudCA9PT0gRXJyb3JCb3VuZGFyeUhhbmRsZXIgJiZcbiAgICAgIChlcnJvckluZm8uZXJyb3JCb3VuZGFyeSEgYXMgSW5zdGFuY2VUeXBlPHR5cGVvZiBFcnJvckJvdW5kYXJ5SGFuZGxlcj4pXG4gICAgICAgIC5wcm9wcy5lcnJvckNvbXBvbmVudCA9PT0gRGVmYXVsdEVycm9yQm91bmRhcnkpXG5cbiAgLy8gU2tpcCB0aGUgc2VnbWVudCBleHBsb3JlciB0cmlnZ2VyZWQgZXJyb3JcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCB7IFNFR01FTlRfRVhQTE9SRVJfU0lNVUxBVEVEX0VSUk9SX01FU1NBR0UgfSA9XG4gICAgICByZXF1aXJlKCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvc2VnbWVudC1leHBsb3Jlci1ub2RlJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL3NlZ21lbnQtZXhwbG9yZXItbm9kZScpXG4gICAgaWYgKFxuICAgICAgdGhyb3duVmFsdWUgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgdGhyb3duVmFsdWUubWVzc2FnZSA9PT0gU0VHTUVOVF9FWFBMT1JFUl9TSU1VTEFURURfRVJST1JfTUVTU0FHRVxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgaWYgKGlzSW1wbGljaXRFcnJvckJvdW5kYXJ5KSB7XG4gICAgLy8gV2UgZG9uJ3QgY29uc2lkZXIgZXJyb3JzIGNhdWdodCB1bmxlc3MgdGhleSdyZSBjYXVnaHQgYnkgYW4gZXhwbGljaXQgZXJyb3JcbiAgICAvLyBib3VuZGFyeS4gVGhlIGJ1aWx0LWluIG9uZXMgYXJlIGNvbnNpZGVyZWQgaW1wbGljaXQuXG4gICAgLy8gVGhpcyBtaW1pY3MgaG93IHRoZSBzYW1lIGFwcCB3b3VsZCBiZWhhdmUgd2l0aG91dCBOZXh0LmpzLlxuICAgIHJldHVybiBvblVuY2F1Z2h0RXJyb3IodGhyb3duVmFsdWUpXG4gIH1cblxuICAvLyBTa2lwIGNlcnRhaW4gY3VzdG9tIGVycm9ycyB3aGljaCBhcmUgbm90IGV4cGVjdGVkIHRvIGJlIHJlcG9ydGVkIG9uIGNsaWVudFxuICBpZiAoaXNCYWlsb3V0VG9DU1JFcnJvcih0aHJvd25WYWx1ZSkgfHwgaXNOZXh0Um91dGVyRXJyb3IodGhyb3duVmFsdWUpKSByZXR1cm5cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IGVycm9yQm91bmRhcnlOYW1lID1cbiAgICAgIC8vIHJlYWQgcmVhY3QgY29tcG9uZW50IGRpc3BsYXlOYW1lXG4gICAgICAoZXJyb3JCb3VuZGFyeUNvbXBvbmVudCBhcyBhbnkpPy5kaXNwbGF5TmFtZSB8fFxuICAgICAgZXJyb3JCb3VuZGFyeUNvbXBvbmVudD8ubmFtZSB8fFxuICAgICAgJ1Vua25vd24nXG5cbiAgICBjb25zdCBjb21wb25lbnRUaGF0RXJyb3JlZEZyYW1lID0gZXJyb3JJbmZvPy5jb21wb25lbnRTdGFjaz8uc3BsaXQoJ1xcbicpWzFdXG5cbiAgICAvLyBNYXRjaCBjaHJvbWUgb3Igc2FmYXJpIHN0YWNrIHRyYWNlXG4gICAgY29uc3QgbWF0Y2hlcyA9XG4gICAgICAvLyByZWdleCB0byBtYXRjaCB0aGUgZnVuY3Rpb24gbmFtZSBpbiB0aGUgc3RhY2sgdHJhY2VcbiAgICAgIC8vIGV4YW1wbGUgMTogYXQgUGFnZSAoaHR0cDovL2xvY2FsaG9zdDozMDAwL19uZXh0L3N0YXRpYy9jaHVua3MvcGFnZXMvaW5kZXguanM/dHM9MTYzMTYwMDAwMDAwMDoyOjEpXG4gICAgICAvLyBleGFtcGxlIDI6IFBhZ2VAaHR0cDovL2xvY2FsaG9zdDozMDAwL19uZXh0L3N0YXRpYy9jaHVua3MvcGFnZXMvaW5kZXguanM/dHM9MTYzMTYwMDAwMDAwMDoyOjFcbiAgICAgIGNvbXBvbmVudFRoYXRFcnJvcmVkRnJhbWU/Lm1hdGNoKC9cXHMrYXQgKFxcdyspXFxzK3woXFx3KylALykgPz8gW11cbiAgICBjb25zdCBjb21wb25lbnRUaGF0RXJyb3JlZE5hbWUgPSBtYXRjaGVzWzFdIHx8IG1hdGNoZXNbMl0gfHwgJ1Vua25vd24nXG5cbiAgICAvLyBDcmVhdGUgZXJyb3IgbG9jYXRpb24gd2l0aCBlcnJvcmVkIGNvbXBvbmVudCBhbmQgZXJyb3IgYm91bmRhcnksIHRvIG1hdGNoIHRoZSBiZWhhdmlvciBvZiBkZWZhdWx0IFJlYWN0IG9uQ2F1Z2h0RXJyb3IgaGFuZGxlci5cbiAgICBjb25zdCBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9IGBJdCB3YXMgaGFuZGxlZCBieSB0aGUgPCR7ZXJyb3JCb3VuZGFyeU5hbWV9PiBlcnJvciBib3VuZGFyeS5gXG4gICAgY29uc3QgY29tcG9uZW50RXJyb3JNZXNzYWdlID0gY29tcG9uZW50VGhhdEVycm9yZWROYW1lXG4gICAgICA/IGBUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDwke2NvbXBvbmVudFRoYXRFcnJvcmVkTmFtZX0+IGNvbXBvbmVudC5gXG4gICAgICA6IGBUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgY29tcG9uZW50cy5gXG5cbiAgICBjb25zdCBlcnJvckxvY2F0aW9uID0gYCR7Y29tcG9uZW50RXJyb3JNZXNzYWdlfSAke2Vycm9yQm91bmRhcnlNZXNzYWdlfWBcbiAgICBjb25zdCBlcnJvciA9IGRldlRvb2xFcnJvck1vZC5kZWNvcmF0ZURldkVycm9yKHRocm93blZhbHVlKVxuXG4gICAgLy8gTG9nIGFuZCByZXBvcnQgdGhlIGVycm9yIHdpdGggbG9jYXRpb24gYnV0IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBlcnJvciBzdGFja1xuICAgIGRldlRvb2xFcnJvck1vZC5vcmlnaW5Db25zb2xlRXJyb3IoJyVvXFxuXFxuJXMnLCB0aHJvd25WYWx1ZSwgZXJyb3JMb2NhdGlvbilcblxuICAgIGRldlRvb2xFcnJvck1vZC5oYW5kbGVDbGllbnRFcnJvcihlcnJvcilcbiAgfSBlbHNlIHtcbiAgICBkZXZUb29sRXJyb3JNb2Qub3JpZ2luQ29uc29sZUVycm9yKHRocm93blZhbHVlKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvblVuY2F1Z2h0RXJyb3IodGhyb3duVmFsdWU6IHVua25vd24pIHtcbiAgLy8gU2tpcCBjZXJ0YWluIGN1c3RvbSBlcnJvcnMgd2hpY2ggYXJlIG5vdCBleHBlY3RlZCB0byBiZSByZXBvcnRlZCBvbiBjbGllbnRcbiAgaWYgKGlzQmFpbG91dFRvQ1NSRXJyb3IodGhyb3duVmFsdWUpIHx8IGlzTmV4dFJvdXRlckVycm9yKHRocm93blZhbHVlKSkgcmV0dXJuXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBlcnJvciA9IGRldlRvb2xFcnJvck1vZC5kZWNvcmF0ZURldkVycm9yKHRocm93blZhbHVlKVxuXG4gICAgLy8gVE9ETzogQWRkIGFuIGFkZW5kdW0gdG8gdGhlIG92ZXJsYXkgdGVsbGluZyBwZW9wbGUgYWJvdXQgY3VzdG9tIGVycm9yIGJvdW5kYXJpZXMuXG4gICAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpXG4gIH0gZWxzZSB7XG4gICAgcmVwb3J0R2xvYmFsRXJyb3IodGhyb3duVmFsdWUpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJvbkNhdWdodEVycm9yIiwib25VbmNhdWdodEVycm9yIiwiZGV2VG9vbEVycm9yTW9kIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwicmVxdWlyZSIsImRlY29yYXRlRGV2RXJyb3IiLCJlcnJvciIsImhhbmRsZUNsaWVudEVycm9yIiwib3JpZ2luQ29uc29sZUVycm9yIiwiY29uc29sZSIsImJpbmQiLCJ0aHJvd25WYWx1ZSIsImVycm9ySW5mbyIsImVycm9yQm91bmRhcnlDb21wb25lbnQiLCJlcnJvckJvdW5kYXJ5IiwiY29uc3RydWN0b3IiLCJpc0ltcGxpY2l0RXJyb3JCb3VuZGFyeSIsIkFwcERldk92ZXJsYXlFcnJvckJvdW5kYXJ5IiwiRXJyb3JCb3VuZGFyeUhhbmRsZXIiLCJwcm9wcyIsImVycm9yQ29tcG9uZW50IiwiRGVmYXVsdEVycm9yQm91bmRhcnkiLCJTRUdNRU5UX0VYUExPUkVSX1NJTVVMQVRFRF9FUlJPUl9NRVNTQUdFIiwiRXJyb3IiLCJtZXNzYWdlIiwiaXNCYWlsb3V0VG9DU1JFcnJvciIsImlzTmV4dFJvdXRlckVycm9yIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJjb21wb25lbnRUaGF0RXJyb3JlZEZyYW1lIiwiY29tcG9uZW50U3RhY2siLCJzcGxpdCIsIm1hdGNoZXMiLCJtYXRjaCIsImNvbXBvbmVudFRoYXRFcnJvcmVkTmFtZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiY29tcG9uZW50RXJyb3JNZXNzYWdlIiwiZXJyb3JMb2NhdGlvbiIsInJlcG9ydEdsb2JhbEVycm9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js ***!
  \**************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// This module can be shared between both pages router and app router\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isRecoverableError: function() {\n        return isRecoverableError;\n    },\n    onRecoverableError: function() {\n        return onRecoverableError;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _bailouttocsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nconst _iserror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../lib/is-error */ \"(app-pages-browser)/./node_modules/next/dist/lib/is-error.js\"));\nconst _reportglobalerror = __webpack_require__(/*! ./report-global-error */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/report-global-error.js\");\nconst recoverableErrors = new WeakSet();\nfunction isRecoverableError(error) {\n    return recoverableErrors.has(error);\n}\nconst onRecoverableError = (error)=>{\n    // x-ref: https://github.com/facebook/react/pull/28736\n    let cause = (0, _iserror.default)(error) && 'cause' in error ? error.cause : error;\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(cause)) return;\n    if (true) {\n        const { decorateDevError } = __webpack_require__(/*! ../../next-devtools/userspace/app/errors/stitched-error */ \"(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js\");\n        const causeError = decorateDevError(cause);\n        recoverableErrors.add(causeError);\n        cause = causeError;\n    }\n    (0, _reportglobalerror.reportGlobalError)(cause);\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=on-recoverable-error.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlYWN0LWNsaWVudC1jYWxsYmFja3Mvb24tcmVjb3ZlcmFibGUtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUEscUVBQXFFOzs7Ozs7Ozs7Ozs7O0lBU3JEQSxrQkFBa0I7ZUFBbEJBOztJQUlIQyxrQkFBa0I7ZUFBbEJBOzs7OzBDQVZ1Qjs4RUFDaEI7K0NBQ2M7QUFFbEMsTUFBTUMsb0JBQW9CLElBQUlDO0FBRXZCLFNBQVNILG1CQUFtQkksS0FBWTtJQUM3QyxPQUFPRixrQkFBa0JHLEdBQUcsQ0FBQ0Q7QUFDL0I7QUFFTyxNQUFNSCxxQkFBNkQsQ0FDeEVHO0lBRUEsc0RBQXNEO0lBQ3RELElBQUlFLFFBQVFDLENBQUFBLEdBQUFBLFNBQUFBLE9BQUFBLEVBQVFILFVBQVUsV0FBV0EsUUFBUUEsTUFBTUUsS0FBSyxHQUFHRjtJQUMvRCw2RUFBNkU7SUFDN0UsSUFBSUksQ0FBQUEsR0FBQUEsY0FBQUEsbUJBQUFBLEVBQW9CRixRQUFRO0lBRWhDLElBQUlHLElBQW9CLEVBQW1CO1FBQ3pDLE1BQU0sRUFBRUcsZ0JBQWdCLEVBQUUsR0FDeEJDLG1CQUFPQSxDQUFDLGtLQUF5RDtRQUNuRSxNQUFNQyxhQUFhRixpQkFBaUJOO1FBQ3BDSixrQkFBa0JhLEdBQUcsQ0FBQ0Q7UUFDdEJSLFFBQVFRO0lBQ1Y7SUFFQUUsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFBQSxFQUFrQlY7QUFDcEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yeWFucm9zenRvY3p5L0RldmVsb3BtZW50L3NyYy9jbGllbnQvcmVhY3QtY2xpZW50LWNhbGxiYWNrcy9vbi1yZWNvdmVyYWJsZS1lcnJvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIG1vZHVsZSBjYW4gYmUgc2hhcmVkIGJldHdlZW4gYm90aCBwYWdlcyByb3V0ZXIgYW5kIGFwcCByb3V0ZXJcblxuaW1wb3J0IHR5cGUgeyBIeWRyYXRpb25PcHRpb25zIH0gZnJvbSAncmVhY3QtZG9tL2NsaWVudCdcbmltcG9ydCB7IGlzQmFpbG91dFRvQ1NSRXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2xhenktZHluYW1pYy9iYWlsb3V0LXRvLWNzcidcbmltcG9ydCBpc0Vycm9yIGZyb20gJy4uLy4uL2xpYi9pcy1lcnJvcidcbmltcG9ydCB7IHJlcG9ydEdsb2JhbEVycm9yIH0gZnJvbSAnLi9yZXBvcnQtZ2xvYmFsLWVycm9yJ1xuXG5jb25zdCByZWNvdmVyYWJsZUVycm9ycyA9IG5ldyBXZWFrU2V0PEVycm9yPigpXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlY292ZXJhYmxlRXJyb3IoZXJyb3I6IEVycm9yKTogYm9vbGVhbiB7XG4gIHJldHVybiByZWNvdmVyYWJsZUVycm9ycy5oYXMoZXJyb3IpXG59XG5cbmV4cG9ydCBjb25zdCBvblJlY292ZXJhYmxlRXJyb3I6IEh5ZHJhdGlvbk9wdGlvbnNbJ29uUmVjb3ZlcmFibGVFcnJvciddID0gKFxuICBlcnJvclxuKSA9PiB7XG4gIC8vIHgtcmVmOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yODczNlxuICBsZXQgY2F1c2UgPSBpc0Vycm9yKGVycm9yKSAmJiAnY2F1c2UnIGluIGVycm9yID8gZXJyb3IuY2F1c2UgOiBlcnJvclxuICAvLyBTa2lwIGNlcnRhaW4gY3VzdG9tIGVycm9ycyB3aGljaCBhcmUgbm90IGV4cGVjdGVkIHRvIGJlIHJlcG9ydGVkIG9uIGNsaWVudFxuICBpZiAoaXNCYWlsb3V0VG9DU1JFcnJvcihjYXVzZSkpIHJldHVyblxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgeyBkZWNvcmF0ZURldkVycm9yIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2Vycm9ycy9zdGl0Y2hlZC1lcnJvcicpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9lcnJvcnMvc3RpdGNoZWQtZXJyb3InKVxuICAgIGNvbnN0IGNhdXNlRXJyb3IgPSBkZWNvcmF0ZURldkVycm9yKGNhdXNlKVxuICAgIHJlY292ZXJhYmxlRXJyb3JzLmFkZChjYXVzZUVycm9yKVxuICAgIGNhdXNlID0gY2F1c2VFcnJvclxuICB9XG5cbiAgcmVwb3J0R2xvYmFsRXJyb3IoY2F1c2UpXG59XG4iXSwibmFtZXMiOlsiaXNSZWNvdmVyYWJsZUVycm9yIiwib25SZWNvdmVyYWJsZUVycm9yIiwicmVjb3ZlcmFibGVFcnJvcnMiLCJXZWFrU2V0IiwiZXJyb3IiLCJoYXMiLCJjYXVzZSIsImlzRXJyb3IiLCJpc0JhaWxvdXRUb0NTUkVycm9yIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZGVjb3JhdGVEZXZFcnJvciIsInJlcXVpcmUiLCJjYXVzZUVycm9yIiwiYWRkIiwicmVwb3J0R2xvYmFsRXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/route-params.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-params.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    doesStaticSegmentAppearInURL: function() {\n        return doesStaticSegmentAppearInURL;\n    },\n    getCacheKeyForDynamicParam: function() {\n        return getCacheKeyForDynamicParam;\n    },\n    getParamValueFromCacheKey: function() {\n        return getParamValueFromCacheKey;\n    },\n    getRenderedPathname: function() {\n        return getRenderedPathname;\n    },\n    getRenderedSearch: function() {\n        return getRenderedSearch;\n    },\n    parseDynamicParamFromURLPart: function() {\n        return parseDynamicParamFromURLPart;\n    },\n    urlSearchParamsToParsedUrlQuery: function() {\n        return urlSearchParamsToParsedUrlQuery;\n    },\n    urlToUrlWithoutFlightMarker: function() {\n        return urlToUrlWithoutFlightMarker;\n    }\n});\nconst _segment = __webpack_require__(/*! ../shared/lib/segment */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment.js\");\nconst _segmentvalueencoding = __webpack_require__(/*! ../shared/lib/segment-cache/segment-value-encoding */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment-cache/segment-value-encoding.js\");\nconst _approuterheaders = __webpack_require__(/*! ./components/app-router-headers */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-headers.js\");\nfunction getRenderedSearch(response) {\n    // If the server performed a rewrite, the search params used to render the\n    // page will be different from the params in the request URL. In this case,\n    // the response will include a header that gives the rewritten search query.\n    const rewrittenQuery = response.headers.get(_approuterheaders.NEXT_REWRITTEN_QUERY_HEADER);\n    if (rewrittenQuery !== null) {\n        return rewrittenQuery === '' ? '' : '?' + rewrittenQuery;\n    }\n    // If the header is not present, there was no rewrite, so we use the search\n    // query of the response URL.\n    return urlToUrlWithoutFlightMarker(new URL(response.url)).search;\n}\nfunction getRenderedPathname(response) {\n    // If the server performed a rewrite, the pathname used to render the\n    // page will be different from the pathname in the request URL. In this case,\n    // the response will include a header that gives the rewritten pathname.\n    const rewrittenPath = response.headers.get(_approuterheaders.NEXT_REWRITTEN_PATH_HEADER);\n    return rewrittenPath ?? urlToUrlWithoutFlightMarker(new URL(response.url)).pathname;\n}\nfunction parseDynamicParamFromURLPart(paramType, pathnameParts, partIndex) {\n    // This needs to match the behavior in get-dynamic-param.ts.\n    switch(paramType){\n        // Catchalls\n        case 'c':\n            {\n                // Catchalls receive all the remaining URL parts. If there are no\n                // remaining pathname parts, return an empty array.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : [];\n            }\n        // Catchall intercepted\n        case 'ci(..)(..)':\n        case 'ci(.)':\n        case 'ci(..)':\n        case 'ci(...)':\n            {\n                const prefix = paramType.length - 2;\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s, i)=>{\n                    if (i === 0) {\n                        return encodeURIComponent(s.slice(prefix));\n                    }\n                    return encodeURIComponent(s);\n                }) : [];\n            }\n        // Optional catchalls\n        case 'oc':\n            {\n                // Optional catchalls receive all the remaining URL parts, unless this is\n                // the end of the pathname, in which case they return null.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : null;\n            }\n        // Dynamic\n        case 'd':\n            {\n                if (partIndex >= pathnameParts.length) {\n                    // The route tree expected there to be more parts in the URL than there\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\n                    // Should this be a hard error? During a prefetch, we can just abort.\n                    // During a client navigation, we could trigger a hard refresh. But if\n                    // it happens during initial render, we don't really have any\n                    // recovery options.\n                    return '';\n                }\n                return encodeURIComponent(pathnameParts[partIndex]);\n            }\n        // Dynamic intercepted\n        case 'di(..)(..)':\n        case 'di(.)':\n        case 'di(..)':\n        case 'di(...)':\n            {\n                const prefix = paramType.length - 2;\n                if (partIndex >= pathnameParts.length) {\n                    // The route tree expected there to be more parts in the URL than there\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\n                    // Should this be a hard error? During a prefetch, we can just abort.\n                    // During a client navigation, we could trigger a hard refresh. But if\n                    // it happens during initial render, we don't really have any\n                    // recovery options.\n                    return '';\n                }\n                return encodeURIComponent(pathnameParts[partIndex].slice(prefix));\n            }\n        default:\n            paramType;\n            return '';\n    }\n}\nfunction doesStaticSegmentAppearInURL(segment) {\n    // This is not a parameterized segment; however, we need to determine\n    // whether or not this segment appears in the URL. For example, this route\n    // groups do not appear in the URL, so they should be skipped. Any other\n    // special cases must be handled here.\n    // TODO: Consider encoding this directly into the router tree instead of\n    // inferring it on the client based on the segment type. Something like\n    // a `doesAppearInURL` flag in FlightRouterState.\n    if (segment === _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY || // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(_segment.PAGE_SEGMENT_KEY) || // Route groups.\n    segment[0] === '(' && segment.endsWith(')') || segment === _segment.DEFAULT_SEGMENT_KEY || segment === '/_not-found') {\n        return false;\n    } else {\n        // All other segment types appear in the URL\n        return true;\n    }\n}\nfunction getCacheKeyForDynamicParam(paramValue, renderedSearch) {\n    // This needs to match the logic in get-dynamic-param.ts, until we're able to\n    // unify the various implementations so that these are always computed on\n    // the client.\n    if (typeof paramValue === 'string') {\n        // TODO: Refactor or remove this helper function to accept a string rather\n        // than the whole segment type. Also we can probably just append the\n        // search string instead of turning it into JSON.\n        const pageSegmentWithSearchParams = (0, _segment.addSearchParamsIfPageSegment)(paramValue, Object.fromEntries(new URLSearchParams(renderedSearch)));\n        return pageSegmentWithSearchParams;\n    } else if (paramValue === null) {\n        return '';\n    } else {\n        return paramValue.join('/');\n    }\n}\nfunction urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url);\n    urlWithoutFlightParameters.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    if (false) {}\n    return urlWithoutFlightParameters;\n}\nfunction getParamValueFromCacheKey(paramCacheKey, paramType) {\n    // Turn the cache key string sent by the server (as part of FlightRouterState)\n    // into a value that can be passed to `useParams` and client components.\n    const isCatchAll = paramType === 'c' || paramType === 'oc';\n    if (isCatchAll) {\n        // Catch-all param keys are a concatenation of the path segments.\n        // See equivalent logic in `getSelectedParams`.\n        // TODO: We should just pass the array directly, rather than concatenate\n        // it to a string and then split it back to an array. It needs to be an\n        // array in some places, like when passing a key React, but we can convert\n        // it at runtime in those places.\n        return paramCacheKey.split('/');\n    }\n    return paramCacheKey;\n}\nfunction urlSearchParamsToParsedUrlQuery(searchParams) {\n    // Converts a URLSearchParams object to the same type used by the server when\n    // creating search params props, i.e. the type returned by Node's\n    // \"querystring\" module.\n    const result = {};\n    for (const [key, value] of searchParams.entries()){\n        if (result[key] === undefined) {\n            result[key] = value;\n        } else if (Array.isArray(result[key])) {\n            result[key].push(value);\n        } else {\n            result[key] = [\n                result[key],\n                value\n            ];\n        }\n    }\n    return result;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=route-params.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JvdXRlLXBhcmFtcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFpSWdCQSw0QkFBNEI7ZUFBNUJBOztJQTRCQUMsMEJBQTBCO2VBQTFCQTs7SUF3Q0FDLHlCQUF5QjtlQUF6QkE7O0lBOUpBQyxtQkFBbUI7ZUFBbkJBOztJQWxCQUMsaUJBQWlCO2VBQWpCQTs7SUE4QkFDLDRCQUE0QjtlQUE1QkE7O0lBcUtBQywrQkFBK0I7ZUFBL0JBOztJQXBDQUMsMkJBQTJCO2VBQTNCQTs7O3FDQS9LVDtrREFDa0M7OENBS2xDO0FBVUEsU0FBU0gsa0JBQ2RJLFFBQXlDO0lBRXpDLDBFQUEwRTtJQUMxRSwyRUFBMkU7SUFDM0UsNEVBQTRFO0lBQzVFLE1BQU1DLGlCQUFpQkQsU0FBU0UsT0FBTyxDQUFDQyxHQUFHLENBQUNDLGtCQUFBQSwyQkFBMkI7SUFDdkUsSUFBSUgsbUJBQW1CLE1BQU07UUFDM0IsT0FDRUEsbUJBQW1CLEtBQUssS0FBSyxNQUFNQTtJQUV2QztJQUNBLDJFQUEyRTtJQUMzRSw2QkFBNkI7SUFDN0IsT0FBT0YsNEJBQTRCLElBQUlNLElBQUlMLFNBQVNNLEdBQUcsR0FDcERDLE1BQU07QUFDWDtBQUVPLFNBQVNaLG9CQUNkSyxRQUF5QztJQUV6QyxxRUFBcUU7SUFDckUsNkVBQTZFO0lBQzdFLHdFQUF3RTtJQUN4RSxNQUFNUSxnQkFBZ0JSLFNBQVNFLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDTSxrQkFBQUEsMEJBQTBCO0lBQ3JFLE9BQVFELGlCQUNOVCw0QkFBNEIsSUFBSU0sSUFBSUwsU0FBU00sR0FBRyxHQUM3Q0ksUUFBUTtBQUNmO0FBRU8sU0FBU2IsNkJBQ2RjLFNBQWlDLEVBQ2pDQyxhQUE0QixFQUM1QkMsU0FBaUI7SUFFakIsNERBQTREO0lBQzVELE9BQVFGO1FBQ04sWUFBWTtRQUNaLEtBQUs7WUFBSztnQkFDUixpRUFBaUU7Z0JBQ2pFLG1E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aS13ZWJzaXRlL3NyYy9jbGllbnQvcm91dGUtcGFyYW1zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRHluYW1pY1BhcmFtVHlwZXNTaG9ydCB9IGZyb20gJy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci10eXBlcydcbmltcG9ydCB7XG4gIGFkZFNlYXJjaFBhcmFtc0lmUGFnZVNlZ21lbnQsXG4gIERFRkFVTFRfU0VHTUVOVF9LRVksXG4gIFBBR0VfU0VHTUVOVF9LRVksXG59IGZyb20gJy4uL3NoYXJlZC9saWIvc2VnbWVudCdcbmltcG9ydCB7IFJPT1RfU0VHTUVOVF9SRVFVRVNUX0tFWSB9IGZyb20gJy4uL3NoYXJlZC9saWIvc2VnbWVudC1jYWNoZS9zZWdtZW50LXZhbHVlLWVuY29kaW5nJ1xuaW1wb3J0IHtcbiAgTkVYVF9SRVdSSVRURU5fUEFUSF9IRUFERVIsXG4gIE5FWFRfUkVXUklUVEVOX1FVRVJZX0hFQURFUixcbiAgTkVYVF9SU0NfVU5JT05fUVVFUlksXG59IGZyb20gJy4vY29tcG9uZW50cy9hcHAtcm91dGVyLWhlYWRlcnMnXG5pbXBvcnQgdHlwZSB7XG4gIE5vcm1hbGl6ZWRQYXRobmFtZSxcbiAgTm9ybWFsaXplZFNlYXJjaCxcbn0gZnJvbSAnLi9jb21wb25lbnRzL3NlZ21lbnQtY2FjaGUvY2FjaGUta2V5J1xuaW1wb3J0IHR5cGUgeyBSU0NSZXNwb25zZSB9IGZyb20gJy4vY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQgdHlwZSB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5cbmV4cG9ydCB0eXBlIFJvdXRlUGFyYW1WYWx1ZSA9IHN0cmluZyB8IEFycmF5PHN0cmluZz4gfCBudWxsXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZW5kZXJlZFNlYXJjaChcbiAgcmVzcG9uc2U6IFJTQ1Jlc3BvbnNlPHVua25vd24+IHwgUmVzcG9uc2Vcbik6IE5vcm1hbGl6ZWRTZWFyY2gge1xuICAvLyBJZiB0aGUgc2VydmVyIHBlcmZvcm1lZCBhIHJld3JpdGUsIHRoZSBzZWFyY2ggcGFyYW1zIHVzZWQgdG8gcmVuZGVyIHRoZVxuICAvLyBwYWdlIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gdGhlIHBhcmFtcyBpbiB0aGUgcmVxdWVzdCBVUkwuIEluIHRoaXMgY2FzZSxcbiAgLy8gdGhlIHJlc3BvbnNlIHdpbGwgaW5jbHVkZSBhIGhlYWRlciB0aGF0IGdpdmVzIHRoZSByZXdyaXR0ZW4gc2VhcmNoIHF1ZXJ5LlxuICBjb25zdCByZXdyaXR0ZW5RdWVyeSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KE5FWFRfUkVXUklUVEVOX1FVRVJZX0hFQURFUilcbiAgaWYgKHJld3JpdHRlblF1ZXJ5ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHJld3JpdHRlblF1ZXJ5ID09PSAnJyA/ICcnIDogJz8nICsgcmV3cml0dGVuUXVlcnlcbiAgICApIGFzIE5vcm1hbGl6ZWRTZWFyY2hcbiAgfVxuICAvLyBJZiB0aGUgaGVhZGVyIGlzIG5vdCBwcmVzZW50LCB0aGVyZSB3YXMgbm8gcmV3cml0ZSwgc28gd2UgdXNlIHRoZSBzZWFyY2hcbiAgLy8gcXVlcnkgb2YgdGhlIHJlc3BvbnNlIFVSTC5cbiAgcmV0dXJuIHVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcihuZXcgVVJMKHJlc3BvbnNlLnVybCkpXG4gICAgLnNlYXJjaCBhcyBOb3JtYWxpemVkU2VhcmNoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZW5kZXJlZFBhdGhuYW1lKFxuICByZXNwb25zZTogUlNDUmVzcG9uc2U8dW5rbm93bj4gfCBSZXNwb25zZVxuKTogTm9ybWFsaXplZFBhdGhuYW1lIHtcbiAgLy8gSWYgdGhlIHNlcnZlciBwZXJmb3JtZWQgYSByZXdyaXRlLCB0aGUgcGF0aG5hbWUgdXNlZCB0byByZW5kZXIgdGhlXG4gIC8vIHBhZ2Ugd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgcGF0aG5hbWUgaW4gdGhlIHJlcXVlc3QgVVJMLiBJbiB0aGlzIGNhc2UsXG4gIC8vIHRoZSByZXNwb25zZSB3aWxsIGluY2x1ZGUgYSBoZWFkZXIgdGhhdCBnaXZlcyB0aGUgcmV3cml0dGVuIHBhdGhuYW1lLlxuICBjb25zdCByZXdyaXR0ZW5QYXRoID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoTkVYVF9SRVdSSVRURU5fUEFUSF9IRUFERVIpXG4gIHJldHVybiAocmV3cml0dGVuUGF0aCA/P1xuICAgIHVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcihuZXcgVVJMKHJlc3BvbnNlLnVybCkpXG4gICAgICAucGF0aG5hbWUpIGFzIE5vcm1hbGl6ZWRQYXRobmFtZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEeW5hbWljUGFyYW1Gcm9tVVJMUGFydChcbiAgcGFyYW1UeXBlOiBEeW5hbWljUGFyYW1UeXBlc1Nob3J0LFxuICBwYXRobmFtZVBhcnRzOiBBcnJheTxzdHJpbmc+LFxuICBwYXJ0SW5kZXg6IG51bWJlclxuKTogUm91dGVQYXJhbVZhbHVlIHtcbiAgLy8gVGhpcyBuZWVkcyB0byBtYXRjaCB0aGUgYmVoYXZpb3IgaW4gZ2V0LWR5bmFtaWMtcGFyYW0udHMuXG4gIHN3aXRjaCAocGFyYW1UeXBlKSB7XG4gICAgLy8gQ2F0Y2hhbGxzXG4gICAgY2FzZSAnYyc6IHtcbiAgICAgIC8vIENhdGNoYWxscyByZWNlaXZlIGFsbCB0aGUgcmVtYWluaW5nIFVSTCBwYXJ0cy4gSWYgdGhlcmUgYXJlIG5vXG4gICAgICAvLyByZW1haW5pbmcgcGF0aG5hbWUgcGFydHMsIHJldHVybiBhbiBlbXB0eSBhcnJheS5cbiAgICAgIHJldHVybiBwYXJ0SW5kZXggPCBwYXRobmFtZVBhcnRzLmxlbmd0aFxuICAgICAgICA/IHBhdGhuYW1lUGFydHMuc2xpY2UocGFydEluZGV4KS5tYXAoKHMpID0+IGVuY29kZVVSSUNvbXBvbmVudChzKSlcbiAgICAgICAgOiBbXVxuICAgIH1cbiAgICAvLyBDYXRjaGFsbCBpbnRlcmNlcHRlZFxuICAgIGNhc2UgJ2NpKC4uKSguLiknOlxuICAgIGNhc2UgJ2NpKC4pJzpcbiAgICBjYXNlICdjaSguLiknOlxuICAgIGNhc2UgJ2NpKC4uLiknOiB7XG4gICAgICBjb25zdCBwcmVmaXggPSBwYXJhbVR5cGUubGVuZ3RoIC0gMlxuICAgICAgcmV0dXJuIHBhcnRJbmRleCA8IHBhdGhuYW1lUGFydHMubGVuZ3RoXG4gICAgICAgID8gcGF0aG5hbWVQYXJ0cy5zbGljZShwYXJ0SW5kZXgpLm1hcCgocywgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzLnNsaWNlKHByZWZpeCkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQocylcbiAgICAgICAgICB9KVxuICAgICAgICA6IFtdXG4gICAgfVxuICAgIC8vIE9wdGlvbmFsIGNhdGNoYWxsc1xuICAgIGNhc2UgJ29jJzoge1xuICAgICAgLy8gT3B0aW9uYWwgY2F0Y2hhbGxzIHJlY2VpdmUgYWxsIHRoZSByZW1haW5pbmcgVVJMIHBhcnRzLCB1bmxlc3MgdGhpcyBpc1xuICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgcGF0aG5hbWUsIGluIHdoaWNoIGNhc2UgdGhleSByZXR1cm4gbnVsbC5cbiAgICAgIHJldHVybiBwYXJ0SW5kZXggPCBwYXRobmFtZVBhcnRzLmxlbmd0aFxuICAgICAgICA/IHBhdGhuYW1lUGFydHMuc2xpY2UocGFydEluZGV4KS5tYXAoKHMpID0+IGVuY29kZVVSSUNvbXBvbmVudChzKSlcbiAgICAgICAgOiBudWxsXG4gICAgfVxuICAgIC8vIER5bmFtaWNcbiAgICBjYXNlICdkJzoge1xuICAgICAgaWYgKHBhcnRJbmRleCA+PSBwYXRobmFtZVBhcnRzLmxlbmd0aCkge1xuICAgICAgICAvLyBUaGUgcm91dGUgdHJlZSBleHBlY3RlZCB0aGVyZSB0byBiZSBtb3JlIHBhcnRzIGluIHRoZSBVUkwgdGhhbiB0aGVyZVxuICAgICAgICAvLyBhY3R1YWxseSBhcmUuIFRoaXMgY291bGQgaGFwcGVuIGlmIHRoZSB4LW5leHRqcy1yZXdyaXR0ZW4tcGF0aCBoZWFkZXJcbiAgICAgICAgLy8gaXMgaW5jb3JyZWN0bHkgc2V0LCBvciBwb3RlbnRpYWxseSBkdWUgdG8gYnVnIGluIE5leHQuanMuIFRPRE86XG4gICAgICAgIC8vIFNob3VsZCB0aGlzIGJlIGEgaGFyZCBlcnJvcj8gRHVyaW5nIGEgcHJlZmV0Y2gsIHdlIGNhbiBqdXN0IGFib3J0LlxuICAgICAgICAvLyBEdXJpbmcgYSBjbGllbnQgbmF2aWdhdGlvbiwgd2UgY291bGQgdHJpZ2dlciBhIGhhcmQgcmVmcmVzaC4gQnV0IGlmXG4gICAgICAgIC8vIGl0IGhhcHBlbnMgZHVyaW5nIGluaXRpYWwgcmVuZGVyLCB3ZSBkb24ndCByZWFsbHkgaGF2ZSBhbnlcbiAgICAgICAgLy8gcmVjb3Zlcnkgb3B0aW9ucy5cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9XG4gICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHBhdGhuYW1lUGFydHNbcGFydEluZGV4XSlcbiAgICB9XG4gICAgLy8gRHluYW1pYyBpbnRlcmNlcHRlZFxuICAgIGNhc2UgJ2RpKC4uKSguLiknOlxuICAgIGNhc2UgJ2RpKC4pJzpcbiAgICBjYXNlICdkaSguLiknOlxuICAgIGNhc2UgJ2RpKC4uLiknOiB7XG4gICAgICBjb25zdCBwcmVmaXggPSBwYXJhbVR5cGUubGVuZ3RoIC0gMlxuICAgICAgaWYgKHBhcnRJbmRleCA+PSBwYXRobmFtZVBhcnRzLmxlbmd0aCkge1xuICAgICAgICAvLyBUaGUgcm91dGUgdHJlZSBleHBlY3RlZCB0aGVyZSB0byBiZSBtb3JlIHBhcnRzIGluIHRoZSBVUkwgdGhhbiB0aGVyZVxuICAgICAgICAvLyBhY3R1YWxseSBhcmUuIFRoaXMgY291bGQgaGFwcGVuIGlmIHRoZSB4LW5leHRqcy1yZXdyaXR0ZW4tcGF0aCBoZWFkZXJcbiAgICAgICAgLy8gaXMgaW5jb3JyZWN0bHkgc2V0LCBvciBwb3RlbnRpYWxseSBkdWUgdG8gYnVnIGluIE5leHQuanMuIFRPRE86XG4gICAgICAgIC8vIFNob3VsZCB0aGlzIGJlIGEgaGFyZCBlcnJvcj8gRHVyaW5nIGEgcHJlZmV0Y2gsIHdlIGNhbiBqdXN0IGFib3J0LlxuICAgICAgICAvLyBEdXJpbmcgYSBjbGllbnQgbmF2aWdhdGlvbiwgd2UgY291bGQgdHJpZ2dlciBhIGhhcmQgcmVmcmVzaC4gQnV0IGlmXG4gICAgICAgIC8vIGl0IGhhcHBlbnMgZHVyaW5nIGluaXRpYWwgcmVuZGVyLCB3ZSBkb24ndCByZWFsbHkgaGF2ZSBhbnlcbiAgICAgICAgLy8gcmVjb3Zlcnkgb3B0aW9ucy5cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQocGF0aG5hbWVQYXJ0c1twYXJ0SW5kZXhdLnNsaWNlKHByZWZpeCkpXG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBwYXJhbVR5cGUgc2F0aXNmaWVzIG5ldmVyXG4gICAgICByZXR1cm4gJydcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZG9lc1N0YXRpY1NlZ21lbnRBcHBlYXJJblVSTChzZWdtZW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgLy8gVGhpcyBpcyBub3QgYSBwYXJhbWV0ZXJpemVkIHNlZ21lbnQ7IGhvd2V2ZXIsIHdlIG5lZWQgdG8gZGV0ZXJtaW5lXG4gIC8vIHdoZXRoZXIgb3Igbm90IHRoaXMgc2VnbWVudCBhcHBlYXJzIGluIHRoZSBVUkwuIEZvciBleGFtcGxlLCB0aGlzIHJvdXRlXG4gIC8vIGdyb3VwcyBkbyBub3QgYXBwZWFyIGluIHRoZSBVUkwsIHNvIHRoZXkgc2hvdWxkIGJlIHNraXBwZWQuIEFueSBvdGhlclxuICAvLyBzcGVjaWFsIGNhc2VzIG11c3QgYmUgaGFuZGxlZCBoZXJlLlxuICAvLyBUT0RPOiBDb25zaWRlciBlbmNvZGluZyB0aGlzIGRpcmVjdGx5IGludG8gdGhlIHJvdXRlciB0cmVlIGluc3RlYWQgb2ZcbiAgLy8gaW5mZXJyaW5nIGl0IG9uIHRoZSBjbGllbnQgYmFzZWQgb24gdGhlIHNlZ21lbnQgdHlwZS4gU29tZXRoaW5nIGxpa2VcbiAgLy8gYSBgZG9lc0FwcGVhckluVVJMYCBmbGFnIGluIEZsaWdodFJvdXRlclN0YXRlLlxuICBpZiAoXG4gICAgc2VnbWVudCA9PT0gUk9PVF9TRUdNRU5UX1JFUVVFU1RfS0VZIHx8XG4gICAgLy8gRm9yIHNvbWUgcmVhc29uLCB0aGUgbG9hZGVyIHRyZWUgc29tZXRpbWVzIGluY2x1ZGVzIGV4dHJhIF9fUEFHRV9fXG4gICAgLy8gXCJsYXlvdXRzXCIgd2hlbiBwYXJ0IG9mIGEgcGFyYWxsZWwgcm91dGUuIEJ1dCBpdCdzIG5vdCBhIGxlYWYgbm9kZS5cbiAgICAvLyBPdGhlcndpc2UsIHdlIHdvdWxkbid0IG5lZWQgdGhpcyBzcGVjaWFsIGNhc2UgYmVjYXVzZSBwYWdlcyBhcmVcbiAgICAvLyBhbHdheXMgbGVhZiBub2Rlcy5cbiAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSB3aHkgdGhlIGxvYWRlciBwcm9kdWNlcyB0aGVzZSBmYWtlIHBhZ2Ugc2VnbWVudHMuXG4gICAgc2VnbWVudC5zdGFydHNXaXRoKFBBR0VfU0VHTUVOVF9LRVkpIHx8XG4gICAgLy8gUm91dGUgZ3JvdXBzLlxuICAgIChzZWdtZW50WzBdID09PSAnKCcgJiYgc2VnbWVudC5lbmRzV2l0aCgnKScpKSB8fFxuICAgIHNlZ21lbnQgPT09IERFRkFVTFRfU0VHTUVOVF9LRVkgfHxcbiAgICBzZWdtZW50ID09PSAnL19ub3QtZm91bmQnXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2Uge1xuICAgIC8vIEFsbCBvdGhlciBzZWdtZW50IHR5cGVzIGFwcGVhciBpbiB0aGUgVVJMXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FjaGVLZXlGb3JEeW5hbWljUGFyYW0oXG4gIHBhcmFtVmFsdWU6IFJvdXRlUGFyYW1WYWx1ZSxcbiAgcmVuZGVyZWRTZWFyY2g6IE5vcm1hbGl6ZWRTZWFyY2hcbik6IHN0cmluZyB7XG4gIC8vIFRoaXMgbmVlZHMgdG8gbWF0Y2ggdGhlIGxvZ2ljIGluIGdldC1keW5hbWljLXBhcmFtLnRzLCB1bnRpbCB3ZSdyZSBhYmxlIHRvXG4gIC8vIHVuaWZ5IHRoZSB2YXJpb3VzIGltcGxlbWVudGF0aW9ucyBzbyB0aGF0IHRoZXNlIGFyZSBhbHdheXMgY29tcHV0ZWQgb25cbiAgLy8gdGhlIGNsaWVudC5cbiAgaWYgKHR5cGVvZiBwYXJhbVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIC8vIFRPRE86IFJlZmFjdG9yIG9yIHJlbW92ZSB0aGlzIGhlbHBlciBmdW5jdGlvbiB0byBhY2NlcHQgYSBzdHJpbmcgcmF0aGVyXG4gICAgLy8gdGhhbiB0aGUgd2hvbGUgc2VnbWVudCB0eXBlLiBBbHNvIHdlIGNhbiBwcm9iYWJseSBqdXN0IGFwcGVuZCB0aGVcbiAgICAvLyBzZWFyY2ggc3RyaW5nIGluc3RlYWQgb2YgdHVybmluZyBpdCBpbnRvIEpTT04uXG4gICAgY29uc3QgcGFnZVNlZ21lbnRXaXRoU2VhcmNoUGFyYW1zID0gYWRkU2VhcmNoUGFyYW1zSWZQYWdlU2VnbWVudChcbiAgICAgIHBhcmFtVmFsdWUsXG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMobmV3IFVSTFNlYXJjaFBhcmFtcyhyZW5kZXJlZFNlYXJjaCkpXG4gICAgKSBhcyBzdHJpbmdcbiAgICByZXR1cm4gcGFnZVNlZ21lbnRXaXRoU2VhcmNoUGFyYW1zXG4gIH0gZWxzZSBpZiAocGFyYW1WYWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnJ1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJhbVZhbHVlLmpvaW4oJy8nKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIodXJsOiBVUkwpOiBVUkwge1xuICBjb25zdCB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycyA9IG5ldyBVUkwodXJsKVxuICB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycy5zZWFyY2hQYXJhbXMuZGVsZXRlKE5FWFRfUlNDX1VOSU9OX1FVRVJZKVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9DT05GSUdfT1VUUFVUID09PSAnZXhwb3J0JyAmJlxuICAgICAgdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnMucGF0aG5hbWUuZW5kc1dpdGgoJy50eHQnKVxuICAgICkge1xuICAgICAgY29uc3QgeyBwYXRobmFtZSB9ID0gdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnNcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHBhdGhuYW1lLmVuZHNXaXRoKCcvaW5kZXgudHh0JykgPyAxMCA6IDRcbiAgICAgIC8vIFNsaWNlIG9mZiBgL2luZGV4LnR4dGAgb3IgYC50eHRgIGZyb20gdGhlIGVuZCBvZiB0aGUgcGF0aG5hbWVcbiAgICAgIHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzLnBhdGhuYW1lID0gcGF0aG5hbWUuc2xpY2UoMCwgLWxlbmd0aClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJhbVZhbHVlRnJvbUNhY2hlS2V5KFxuICBwYXJhbUNhY2hlS2V5OiBzdHJpbmcsXG4gIHBhcmFtVHlwZTogRHluYW1pY1BhcmFtVHlwZXNTaG9ydFxuKSB7XG4gIC8vIFR1cm4gdGhlIGNhY2hlIGtleSBzdHJpbmcgc2VudCBieSB0aGUgc2VydmVyIChhcyBwYXJ0IG9mIEZsaWdodFJvdXRlclN0YXRlKVxuICAvLyBpbnRvIGEgdmFsdWUgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGB1c2VQYXJhbXNgIGFuZCBjbGllbnQgY29tcG9uZW50cy5cbiAgY29uc3QgaXNDYXRjaEFsbCA9IHBhcmFtVHlwZSA9PT0gJ2MnIHx8IHBhcmFtVHlwZSA9PT0gJ29jJ1xuICBpZiAoaXNDYXRjaEFsbCkge1xuICAgIC8vIENhdGNoLWFsbCBwYXJhbSBrZXlzIGFyZSBhIGNvbmNhdGVuYXRpb24gb2YgdGhlIHBhdGggc2VnbWVudHMuXG4gICAgLy8gU2VlIGVxdWl2YWxlbnQgbG9naWMgaW4gYGdldFNlbGVjdGVkUGFyYW1zYC5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQganVzdCBwYXNzIHRoZSBhcnJheSBkaXJlY3RseSwgcmF0aGVyIHRoYW4gY29uY2F0ZW5hdGVcbiAgICAvLyBpdCB0byBhIHN0cmluZyBhbmQgdGhlbiBzcGxpdCBpdCBiYWNrIHRvIGFuIGFycmF5LiBJdCBuZWVkcyB0byBiZSBhblxuICAgIC8vIGFycmF5IGluIHNvbWUgcGxhY2VzLCBsaWtlIHdoZW4gcGFzc2luZyBhIGtleSBSZWFjdCwgYnV0IHdlIGNhbiBjb252ZXJ0XG4gICAgLy8gaXQgYXQgcnVudGltZSBpbiB0aG9zZSBwbGFjZXMuXG4gICAgcmV0dXJuIHBhcmFtQ2FjaGVLZXkuc3BsaXQoJy8nKVxuICB9XG4gIHJldHVybiBwYXJhbUNhY2hlS2V5XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cmxTZWFyY2hQYXJhbXNUb1BhcnNlZFVybFF1ZXJ5KFxuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc1xuKTogUGFyc2VkVXJsUXVlcnkge1xuICAvLyBDb252ZXJ0cyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QgdG8gdGhlIHNhbWUgdHlwZSB1c2VkIGJ5IHRoZSBzZXJ2ZXIgd2hlblxuICAvLyBjcmVhdGluZyBzZWFyY2ggcGFyYW1zIHByb3BzLCBpLmUuIHRoZSB0eXBlIHJldHVybmVkIGJ5IE5vZGUnc1xuICAvLyBcInF1ZXJ5c3RyaW5nXCIgbW9kdWxlLlxuICBjb25zdCByZXN1bHQ6IFBhcnNlZFVybFF1ZXJ5ID0ge31cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc2VhcmNoUGFyYW1zLmVudHJpZXMoKSkge1xuICAgIGlmIChyZXN1bHRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSBbcmVzdWx0W2tleV0sIHZhbHVlXVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG4iXSwibmFtZXMiOlsiZG9lc1N0YXRpY1NlZ21lbnRBcHBlYXJJblVSTCIsImdldENhY2hlS2V5Rm9yRHluYW1pY1BhcmFtIiwiZ2V0UGFyYW1WYWx1ZUZyb21DYWNoZUtleSIsImdldFJlbmRlcmVkUGF0aG5hbWUiLCJnZXRSZW5kZXJlZFNlYXJjaCIsInBhcnNlRHluYW1pY1BhcmFtRnJvbVVSTFBhcnQiLCJ1cmxTZWFyY2hQYXJhbXNUb1BhcnNlZFVybFF1ZXJ5IiwidXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyIiwicmVzcG9uc2UiLCJyZXdyaXR0ZW5RdWVyeSIsImhlYWRlcnMiLCJnZXQiLCJORVhUX1JFV1JJVFRFTl9RVUVSWV9IRUFERVIiLCJVUkwiLCJ1cmwiLCJzZWFyY2giLCJyZXdyaXR0ZW5QYXRoIiwiTkVYVF9SRVdSSVRURU5fUEFUSF9IRUFERVIiLCJwYXRobmFtZSIsInBhcmFtVHlwZSIsInBhdGhuYW1lUGFydHMiLCJwYXJ0SW5kZXgiLCJsZW5ndGgiLCJzbGljZSIsIm1hcCIsInMiLCJlbmNvZGVVUklDb21wb25lbnQiLCJwcmVmaXgiLCJpIiwic2VnbWVudCIsIlJPT1RfU0VHTUVOVF9SRVFVRVNUX0tFWSIsInN0YXJ0c1dpdGgiLCJQQUdFX1NFR01FTlRfS0VZIiwiZW5kc1dpdGgiLCJERUZBVUxUX1NFR01FTlRfS0VZIiwicGFyYW1WYWx1ZSIsInJlbmRlcmVkU2VhcmNoIiwicGFnZVNlZ21lbnRXaXRoU2VhcmNoUGFyYW1zIiwiYWRkU2VhcmNoUGFyYW1zSWZQYWdlU2VnbWVudCIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiVVJMU2VhcmNoUGFyYW1zIiwiam9pbiIsInVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzIiwic2VhcmNoUGFyYW1zIiwiZGVsZXRlIiwiTkVYVF9SU0NfVU5JT05fUVVFUlkiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJfX05FWFRfQ09ORklHX09VVFBVVCIsInBhcmFtQ2FjaGVLZXkiLCJpc0NhdGNoQWxsIiwic3BsaXQiLCJyZXN1bHQiLCJrZXkiLCJ2YWx1ZSIsImVudHJpZXMiLCJ1bmRlZmluZWQiLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/route-params.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * @license React\n * react-server-dom-webpack-client.browser.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function resolveClientReference(bundlerConfig, metadata) {\n      if (bundlerConfig) {\n        var moduleExports = bundlerConfig[metadata[0]];\n        if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))\n          moduleExports = bundlerConfig.name;\n        else {\n          bundlerConfig = moduleExports && moduleExports[\"*\"];\n          if (!bundlerConfig)\n            throw Error(\n              'Could not find the module \"' +\n                metadata[0] +\n                '\" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.'\n            );\n          moduleExports = metadata[2];\n        }\n        return 4 === metadata.length\n          ? [bundlerConfig.id, bundlerConfig.chunks, moduleExports, 1]\n          : [bundlerConfig.id, bundlerConfig.chunks, moduleExports];\n      }\n      return metadata;\n    }\n    function resolveServerReference(bundlerConfig, id) {\n      var name = \"\",\n        resolvedModuleData = bundlerConfig[id];\n      if (resolvedModuleData) name = resolvedModuleData.name;\n      else {\n        var idx = id.lastIndexOf(\"#\");\n        -1 !== idx &&\n          ((name = id.slice(idx + 1)),\n          (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));\n        if (!resolvedModuleData)\n          throw Error(\n            'Could not find the module \"' +\n              id +\n              '\" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'\n          );\n      }\n      return resolvedModuleData.async\n        ? [resolvedModuleData.id, resolvedModuleData.chunks, name, 1]\n        : [resolvedModuleData.id, resolvedModuleData.chunks, name];\n    }\n    function requireAsyncModule(id) {\n      var promise = __webpack_require__(id);\n      if (\"function\" !== typeof promise.then || \"fulfilled\" === promise.status)\n        return null;\n      promise.then(\n        function (value) {\n          promise.status = \"fulfilled\";\n          promise.value = value;\n        },\n        function (reason) {\n          promise.status = \"rejected\";\n          promise.reason = reason;\n        }\n      );\n      return promise;\n    }\n    function ignoreReject() {}\n    function preloadModule(metadata) {\n      for (\n        var chunks = metadata[1], promises = [], i = 0;\n        i < chunks.length;\n\n      ) {\n        var chunkId = chunks[i++],\n          chunkFilename = chunks[i++],\n          entry = chunkCache.get(chunkId);\n        void 0 === entry\n          ? ((chunkFilename = loadChunk(chunkId, chunkFilename)),\n            promises.push(chunkFilename),\n            (entry = chunkCache.set.bind(chunkCache, chunkId, null)),\n            chunkFilename.then(entry, ignoreReject),\n            chunkCache.set(chunkId, chunkFilename))\n          : null !== entry && promises.push(entry);\n      }\n      return 4 === metadata.length\n        ? 0 === promises.length\n          ? requireAsyncModule(metadata[0])\n          : Promise.all(promises).then(function () {\n              return requireAsyncModule(metadata[0]);\n            })\n        : 0 < promises.length\n          ? Promise.all(promises)\n          : null;\n    }\n    function requireModule(metadata) {\n      var moduleExports = __webpack_require__(metadata[0]);\n      if (4 === metadata.length && \"function\" === typeof moduleExports.then)\n        if (\"fulfilled\" === moduleExports.status)\n          moduleExports = moduleExports.value;\n        else throw moduleExports.reason;\n      if (\"*\" === metadata[2]) return moduleExports;\n      if (\"\" === metadata[2])\n        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n      if (hasOwnProperty.call(moduleExports, metadata[2]))\n        return moduleExports[metadata[2]];\n    }\n    function loadChunk(chunkId, filename) {\n      chunkMap.set(chunkId, filename);\n      return __webpack_require__.e(chunkId);\n    }\n    function getIteratorFn(maybeIterable) {\n      if (null === maybeIterable || \"object\" !== typeof maybeIterable)\n        return null;\n      maybeIterable =\n        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n        maybeIterable[\"@@iterator\"];\n      return \"function\" === typeof maybeIterable ? maybeIterable : null;\n    }\n    function isObjectPrototype(object) {\n      if (!object) return !1;\n      var ObjectPrototype = Object.prototype;\n      if (object === ObjectPrototype) return !0;\n      if (getPrototypeOf(object)) return !1;\n      object = Object.getOwnPropertyNames(object);\n      for (var i = 0; i < object.length; i++)\n        if (!(object[i] in ObjectPrototype)) return !1;\n      return !0;\n    }\n    function isSimpleObject(object) {\n      if (!isObjectPrototype(getPrototypeOf(object))) return !1;\n      for (\n        var names = Object.getOwnPropertyNames(object), i = 0;\n        i < names.length;\n        i++\n      ) {\n        var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);\n        if (\n          !descriptor ||\n          (!descriptor.enumerable &&\n            ((\"key\" !== names[i] && \"ref\" !== names[i]) ||\n              \"function\" !== typeof descriptor.get))\n        )\n          return !1;\n      }\n      return !0;\n    }\n    function objectName(object) {\n      object = Object.prototype.toString.call(object);\n      return object.slice(8, object.length - 1);\n    }\n    function describeKeyForErrorMessage(key) {\n      var encodedKey = JSON.stringify(key);\n      return '\"' + key + '\"' === encodedKey ? key : encodedKey;\n    }\n    function describeValueForErrorMessage(value) {\n      switch (typeof value) {\n        case \"string\":\n          return JSON.stringify(\n            10 >= value.length ? value : value.slice(0, 10) + \"...\"\n          );\n        case \"object\":\n          if (isArrayImpl(value)) return \"[...]\";\n          if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)\n            return \"client\";\n          value = objectName(value);\n          return \"Object\" === value ? \"{...}\" : value;\n        case \"function\":\n          return value.$$typeof === CLIENT_REFERENCE_TAG\n            ? \"client\"\n            : (value = value.displayName || value.name)\n              ? \"function \" + value\n              : \"function\";\n        default:\n          return String(value);\n      }\n    }\n    function describeElementType(type) {\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_VIEW_TRANSITION_TYPE:\n          return \"ViewTransition\";\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeElementType(type.render);\n          case REACT_MEMO_TYPE:\n            return describeElementType(type.type);\n          case REACT_LAZY_TYPE:\n            var payload = type._payload;\n            type = type._init;\n            try {\n              return describeElementType(type(payload));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function describeObjectForErrorMessage(objectOrArray, expandedName) {\n      var objKind = objectName(objectOrArray);\n      if (\"Object\" !== objKind && \"Array\" !== objKind) return objKind;\n      var start = -1,\n        length = 0;\n      if (isArrayImpl(objectOrArray))\n        if (jsxChildrenParents.has(objectOrArray)) {\n          var type = jsxChildrenParents.get(objectOrArray);\n          objKind = \"<\" + describeElementType(type) + \">\";\n          for (var i = 0; i < objectOrArray.length; i++) {\n            var value = objectOrArray[i];\n            value =\n              \"string\" === typeof value\n                ? value\n                : \"object\" === typeof value && null !== value\n                  ? \"{\" + describeObjectForErrorMessage(value) + \"}\"\n                  : \"{\" + describeValueForErrorMessage(value) + \"}\";\n            \"\" + i === expandedName\n              ? ((start = objKind.length),\n                (length = value.length),\n                (objKind += value))\n              : (objKind =\n                  15 > value.length && 40 > objKind.length + value.length\n                    ? objKind + value\n                    : objKind + \"{...}\");\n          }\n          objKind += \"</\" + describeElementType(type) + \">\";\n        } else {\n          objKind = \"[\";\n          for (type = 0; type < objectOrArray.length; type++)\n            0 < type && (objKind += \", \"),\n              (i = objectOrArray[type]),\n              (i =\n                \"object\" === typeof i && null !== i\n                  ? describeObjectForErrorMessage(i)\n                  : describeValueForErrorMessage(i)),\n              \"\" + type === expandedName\n                ? ((start = objKind.length),\n                  (length = i.length),\n                  (objKind += i))\n                : (objKind =\n                    10 > i.length && 40 > objKind.length + i.length\n                      ? objKind + i\n                      : objKind + \"...\");\n          objKind += \"]\";\n        }\n      else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)\n        objKind = \"<\" + describeElementType(objectOrArray.type) + \"/>\";\n      else {\n        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return \"client\";\n        if (jsxPropsParents.has(objectOrArray)) {\n          objKind = jsxPropsParents.get(objectOrArray);\n          objKind = \"<\" + (describeElementType(objKind) || \"...\");\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++) {\n            objKind += \" \";\n            value = type[i];\n            objKind += describeKeyForErrorMessage(value) + \"=\";\n            var _value2 = objectOrArray[value];\n            var _substr2 =\n              value === expandedName &&\n              \"object\" === typeof _value2 &&\n              null !== _value2\n                ? describeObjectForErrorMessage(_value2)\n                : describeValueForErrorMessage(_value2);\n            \"string\" !== typeof _value2 && (_substr2 = \"{\" + _substr2 + \"}\");\n            value === expandedName\n              ? ((start = objKind.length),\n                (length = _substr2.length),\n                (objKind += _substr2))\n              : (objKind =\n                  10 > _substr2.length && 40 > objKind.length + _substr2.length\n                    ? objKind + _substr2\n                    : objKind + \"...\");\n          }\n          objKind += \">\";\n        } else {\n          objKind = \"{\";\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++)\n            0 < i && (objKind += \", \"),\n              (value = type[i]),\n              (objKind += describeKeyForErrorMessage(value) + \": \"),\n              (_value2 = objectOrArray[value]),\n              (_value2 =\n                \"object\" === typeof _value2 && null !== _value2\n                  ? describeObjectForErrorMessage(_value2)\n                  : describeValueForErrorMessage(_value2)),\n              value === expandedName\n                ? ((start = objKind.length),\n                  (length = _value2.length),\n                  (objKind += _value2))\n                : (objKind =\n                    10 > _value2.length && 40 > objKind.length + _value2.length\n                      ? objKind + _value2\n                      : objKind + \"...\");\n          objKind += \"}\";\n        }\n      }\n      return void 0 === expandedName\n        ? objKind\n        : -1 < start && 0 < length\n          ? ((objectOrArray = \" \".repeat(start) + \"^\".repeat(length)),\n            \"\\n  \" + objKind + \"\\n  \" + objectOrArray)\n          : \"\\n  \" + objKind;\n    }\n    function serializeNumber(number) {\n      return Number.isFinite(number)\n        ? 0 === number && -Infinity === 1 / number\n          ? \"$-0\"\n          : number\n        : Infinity === number\n          ? \"$Infinity\"\n          : -Infinity === number\n            ? \"$-Infinity\"\n            : \"$NaN\";\n    }\n    function processReply(\n      root,\n      formFieldPrefix,\n      temporaryReferences,\n      resolve,\n      reject\n    ) {\n      function serializeTypedArray(tag, typedArray) {\n        typedArray = new Blob([\n          new Uint8Array(\n            typedArray.buffer,\n            typedArray.byteOffset,\n            typedArray.byteLength\n          )\n        ]);\n        var blobId = nextPartId++;\n        null === formData && (formData = new FormData());\n        formData.append(formFieldPrefix + blobId, typedArray);\n        return \"$\" + tag + blobId.toString(16);\n      }\n      function serializeBinaryReader(reader) {\n        function progress(entry) {\n          entry.done\n            ? ((entry = nextPartId++),\n              data.append(formFieldPrefix + entry, new Blob(buffer)),\n              data.append(\n                formFieldPrefix + streamId,\n                '\"$o' + entry.toString(16) + '\"'\n              ),\n              data.append(formFieldPrefix + streamId, \"C\"),\n              pendingParts--,\n              0 === pendingParts && resolve(data))\n            : (buffer.push(entry.value),\n              reader.read(new Uint8Array(1024)).then(progress, reject));\n        }\n        null === formData && (formData = new FormData());\n        var data = formData;\n        pendingParts++;\n        var streamId = nextPartId++,\n          buffer = [];\n        reader.read(new Uint8Array(1024)).then(progress, reject);\n        return \"$r\" + streamId.toString(16);\n      }\n      function serializeReader(reader) {\n        function progress(entry) {\n          if (entry.done)\n            data.append(formFieldPrefix + streamId, \"C\"),\n              pendingParts--,\n              0 === pendingParts && resolve(data);\n          else\n            try {\n              var partJSON = JSON.stringify(entry.value, resolveToJSON);\n              data.append(formFieldPrefix + streamId, partJSON);\n              reader.read().then(progress, reject);\n            } catch (x) {\n              reject(x);\n            }\n        }\n        null === formData && (formData = new FormData());\n        var data = formData;\n        pendingParts++;\n        var streamId = nextPartId++;\n        reader.read().then(progress, reject);\n        return \"$R\" + streamId.toString(16);\n      }\n      function serializeReadableStream(stream) {\n        try {\n          var binaryReader = stream.getReader({ mode: \"byob\" });\n        } catch (x) {\n          return serializeReader(stream.getReader());\n        }\n        return serializeBinaryReader(binaryReader);\n      }\n      function serializeAsyncIterable(iterable, iterator) {\n        function progress(entry) {\n          if (entry.done) {\n            if (void 0 === entry.value)\n              data.append(formFieldPrefix + streamId, \"C\");\n            else\n              try {\n                var partJSON = JSON.stringify(entry.value, resolveToJSON);\n                data.append(formFieldPrefix + streamId, \"C\" + partJSON);\n              } catch (x) {\n                reject(x);\n                return;\n              }\n            pendingParts--;\n            0 === pendingParts && resolve(data);\n          } else\n            try {\n              var _partJSON = JSON.stringify(entry.value, resolveToJSON);\n              data.append(formFieldPrefix + streamId, _partJSON);\n              iterator.next().then(progress, reject);\n            } catch (x$0) {\n              reject(x$0);\n            }\n        }\n        null === formData && (formData = new FormData());\n        var data = formData;\n        pendingParts++;\n        var streamId = nextPartId++;\n        iterable = iterable === iterator;\n        iterator.next().then(progress, reject);\n        return \"$\" + (iterable ? \"x\" : \"X\") + streamId.toString(16);\n      }\n      function resolveToJSON(key, value) {\n        \"__proto__\" === key &&\n          console.error(\n            \"Expected not to serialize an object with own property `__proto__`. When parsed this property will be omitted.%s\",\n            describeObjectForErrorMessage(this, key)\n          );\n        var originalValue = this[key];\n        \"object\" !== typeof originalValue ||\n          originalValue === value ||\n          originalValue instanceof Date ||\n          (\"Object\" !== objectName(originalValue)\n            ? console.error(\n                \"Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s\",\n                objectName(originalValue),\n                describeObjectForErrorMessage(this, key)\n              )\n            : console.error(\n                \"Only plain objects can be passed to Server Functions from the Client. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s\",\n                describeObjectForErrorMessage(this, key)\n              ));\n        if (null === value) return null;\n        if (\"object\" === typeof value) {\n          switch (value.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              if (void 0 !== temporaryReferences && -1 === key.indexOf(\":\")) {\n                var parentReference = writtenObjects.get(this);\n                if (void 0 !== parentReference)\n                  return (\n                    temporaryReferences.set(parentReference + \":\" + key, value),\n                    \"$T\"\n                  );\n              }\n              throw Error(\n                \"React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options.\" +\n                  describeObjectForErrorMessage(this, key)\n              );\n            case REACT_LAZY_TYPE:\n              originalValue = value._payload;\n              var init = value._init;\n              null === formData && (formData = new FormData());\n              pendingParts++;\n              try {\n                parentReference = init(originalValue);\n                var lazyId = nextPartId++,\n                  partJSON = serializeModel(parentReference, lazyId);\n                formData.append(formFieldPrefix + lazyId, partJSON);\n                return \"$\" + lazyId.toString(16);\n              } catch (x) {\n                if (\n                  \"object\" === typeof x &&\n                  null !== x &&\n                  \"function\" === typeof x.then\n                ) {\n                  pendingParts++;\n                  var _lazyId = nextPartId++;\n                  parentReference = function () {\n                    try {\n                      var _partJSON2 = serializeModel(value, _lazyId),\n                        _data = formData;\n                      _data.append(formFieldPrefix + _lazyId, _partJSON2);\n                      pendingParts--;\n                      0 === pendingParts && resolve(_data);\n                    } catch (reason) {\n                      reject(reason);\n                    }\n                  };\n                  x.then(parentReference, parentReference);\n                  return \"$\" + _lazyId.toString(16);\n                }\n                reject(x);\n                return null;\n              } finally {\n                pendingParts--;\n              }\n          }\n          parentReference = writtenObjects.get(value);\n          if (\"function\" === typeof value.then) {\n            if (void 0 !== parentReference)\n              if (modelRoot === value) modelRoot = null;\n              else return parentReference;\n            null === formData && (formData = new FormData());\n            pendingParts++;\n            var promiseId = nextPartId++;\n            key = \"$@\" + promiseId.toString(16);\n            writtenObjects.set(value, key);\n            value.then(function (partValue) {\n              try {\n                var previousReference = writtenObjects.get(partValue);\n                var _partJSON3 =\n                  void 0 !== previousReference\n                    ? JSON.stringify(previousReference)\n                    : serializeModel(partValue, promiseId);\n                partValue = formData;\n                partValue.append(formFieldPrefix + promiseId, _partJSON3);\n                pendingParts--;\n                0 === pendingParts && resolve(partValue);\n              } catch (reason) {\n                reject(reason);\n              }\n            }, reject);\n            return key;\n          }\n          if (void 0 !== parentReference)\n            if (modelRoot === value) modelRoot = null;\n            else return parentReference;\n          else\n            -1 === key.indexOf(\":\") &&\n              ((parentReference = writtenObjects.get(this)),\n              void 0 !== parentReference &&\n                ((parentReference = parentReference + \":\" + key),\n                writtenObjects.set(value, parentReference),\n                void 0 !== temporaryReferences &&\n                  temporaryReferences.set(parentReference, value)));\n          if (isArrayImpl(value)) return value;\n          if (value instanceof FormData) {\n            null === formData && (formData = new FormData());\n            var _data3 = formData;\n            key = nextPartId++;\n            var prefix = formFieldPrefix + key + \"_\";\n            value.forEach(function (originalValue, originalKey) {\n              _data3.append(prefix + originalKey, originalValue);\n            });\n            return \"$K\" + key.toString(16);\n          }\n          if (value instanceof Map)\n            return (\n              (key = nextPartId++),\n              (parentReference = serializeModel(Array.from(value), key)),\n              null === formData && (formData = new FormData()),\n              formData.append(formFieldPrefix + key, parentReference),\n              \"$Q\" + key.toString(16)\n            );\n          if (value instanceof Set)\n            return (\n              (key = nextPartId++),\n              (parentReference = serializeModel(Array.from(value), key)),\n              null === formData && (formData = new FormData()),\n              formData.append(formFieldPrefix + key, parentReference),\n              \"$W\" + key.toString(16)\n            );\n          if (value instanceof ArrayBuffer)\n            return (\n              (key = new Blob([value])),\n              (parentReference = nextPartId++),\n              null === formData && (formData = new FormData()),\n              formData.append(formFieldPrefix + parentReference, key),\n              \"$A\" + parentReference.toString(16)\n            );\n          if (value instanceof Int8Array)\n            return serializeTypedArray(\"O\", value);\n          if (value instanceof Uint8Array)\n            return serializeTypedArray(\"o\", value);\n          if (value instanceof Uint8ClampedArray)\n            return serializeTypedArray(\"U\", value);\n          if (value instanceof Int16Array)\n            return serializeTypedArray(\"S\", value);\n          if (value instanceof Uint16Array)\n            return serializeTypedArray(\"s\", value);\n          if (value instanceof Int32Array)\n            return serializeTypedArray(\"L\", value);\n          if (value instanceof Uint32Array)\n            return serializeTypedArray(\"l\", value);\n          if (value instanceof Float32Array)\n            return serializeTypedArray(\"G\", value);\n          if (value instanceof Float64Array)\n            return serializeTypedArray(\"g\", value);\n          if (value instanceof BigInt64Array)\n            return serializeTypedArray(\"M\", value);\n          if (value instanceof BigUint64Array)\n            return serializeTypedArray(\"m\", value);\n          if (value instanceof DataView) return serializeTypedArray(\"V\", value);\n          if (\"function\" === typeof Blob && value instanceof Blob)\n            return (\n              null === formData && (formData = new FormData()),\n              (key = nextPartId++),\n              formData.append(formFieldPrefix + key, value),\n              \"$B\" + key.toString(16)\n            );\n          if ((parentReference = getIteratorFn(value)))\n            return (\n              (parentReference = parentReference.call(value)),\n              parentReference === value\n                ? ((key = nextPartId++),\n                  (parentReference = serializeModel(\n                    Array.from(parentReference),\n                    key\n                  )),\n                  null === formData && (formData = new FormData()),\n                  formData.append(formFieldPrefix + key, parentReference),\n                  \"$i\" + key.toString(16))\n                : Array.from(parentReference)\n            );\n          if (\n            \"function\" === typeof ReadableStream &&\n            value instanceof ReadableStream\n          )\n            return serializeReadableStream(value);\n          parentReference = value[ASYNC_ITERATOR];\n          if (\"function\" === typeof parentReference)\n            return serializeAsyncIterable(value, parentReference.call(value));\n          parentReference = getPrototypeOf(value);\n          if (\n            parentReference !== ObjectPrototype &&\n            (null === parentReference ||\n              null !== getPrototypeOf(parentReference))\n          ) {\n            if (void 0 === temporaryReferences)\n              throw Error(\n                \"Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported.\" +\n                  describeObjectForErrorMessage(this, key)\n              );\n            return \"$T\";\n          }\n          value.$$typeof === REACT_CONTEXT_TYPE\n            ? console.error(\n                \"React Context Providers cannot be passed to Server Functions from the Client.%s\",\n                describeObjectForErrorMessage(this, key)\n              )\n            : \"Object\" !== objectName(value)\n              ? console.error(\n                  \"Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s\",\n                  objectName(value),\n                  describeObjectForErrorMessage(this, key)\n                )\n              : isSimpleObject(value)\n                ? Object.getOwnPropertySymbols &&\n                  ((parentReference = Object.getOwnPropertySymbols(value)),\n                  0 < parentReference.length &&\n                    console.error(\n                      \"Only plain objects can be passed to Server Functions from the Client. Objects with symbol properties like %s are not supported.%s\",\n                      parentReference[0].description,\n                      describeObjectForErrorMessage(this, key)\n                    ))\n                : console.error(\n                    \"Only plain objects can be passed to Server Functions from the Client. Classes or other objects with methods are not supported.%s\",\n                    describeObjectForErrorMessage(this, key)\n                  );\n          return value;\n        }\n        if (\"string\" === typeof value) {\n          if (\"Z\" === value[value.length - 1] && this[key] instanceof Date)\n            return \"$D\" + value;\n          key = \"$\" === value[0] ? \"$\" + value : value;\n          return key;\n        }\n        if (\"boolean\" === typeof value) return value;\n        if (\"number\" === typeof value) return serializeNumber(value);\n        if (\"undefined\" === typeof value) return \"$undefined\";\n        if (\"function\" === typeof value) {\n          parentReference = knownServerReferences.get(value);\n          if (void 0 !== parentReference) {\n            key = writtenObjects.get(value);\n            if (void 0 !== key) return key;\n            key = JSON.stringify(\n              { id: parentReference.id, bound: parentReference.bound },\n              resolveToJSON\n            );\n            null === formData && (formData = new FormData());\n            parentReference = nextPartId++;\n            formData.set(formFieldPrefix + parentReference, key);\n            key = \"$h\" + parentReference.toString(16);\n            writtenObjects.set(value, key);\n            return key;\n          }\n          if (\n            void 0 !== temporaryReferences &&\n            -1 === key.indexOf(\":\") &&\n            ((parentReference = writtenObjects.get(this)),\n            void 0 !== parentReference)\n          )\n            return (\n              temporaryReferences.set(parentReference + \":\" + key, value), \"$T\"\n            );\n          throw Error(\n            \"Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.\"\n          );\n        }\n        if (\"symbol\" === typeof value) {\n          if (\n            void 0 !== temporaryReferences &&\n            -1 === key.indexOf(\":\") &&\n            ((parentReference = writtenObjects.get(this)),\n            void 0 !== parentReference)\n          )\n            return (\n              temporaryReferences.set(parentReference + \":\" + key, value), \"$T\"\n            );\n          throw Error(\n            \"Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options.\" +\n              describeObjectForErrorMessage(this, key)\n          );\n        }\n        if (\"bigint\" === typeof value) return \"$n\" + value.toString(10);\n        throw Error(\n          \"Type \" +\n            typeof value +\n            \" is not supported as an argument to a Server Function.\"\n        );\n      }\n      function serializeModel(model, id) {\n        \"object\" === typeof model &&\n          null !== model &&\n          ((id = \"$\" + id.toString(16)),\n          writtenObjects.set(model, id),\n          void 0 !== temporaryReferences && temporaryReferences.set(id, model));\n        modelRoot = model;\n        return JSON.stringify(model, resolveToJSON);\n      }\n      var nextPartId = 1,\n        pendingParts = 0,\n        formData = null,\n        writtenObjects = new WeakMap(),\n        modelRoot = root,\n        json = serializeModel(root, 0);\n      null === formData\n        ? resolve(json)\n        : (formData.set(formFieldPrefix + \"0\", json),\n          0 === pendingParts && resolve(formData));\n      return function () {\n        0 < pendingParts &&\n          ((pendingParts = 0),\n          null === formData ? resolve(json) : resolve(formData));\n      };\n    }\n    function createFakeServerFunction(\n      name,\n      filename,\n      sourceMap,\n      line,\n      col,\n      environmentName,\n      innerFunction\n    ) {\n      name || (name = \"<anonymous>\");\n      var encodedName = JSON.stringify(name);\n      1 >= line\n        ? ((line = encodedName.length + 7),\n          (col =\n            \"s=>({\" +\n            encodedName +\n            \" \".repeat(col < line ? 0 : col - line) +\n            \":(...args) => s(...args)})\\n/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */\"))\n        : (col =\n            \"/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */\" +\n            \"\\n\".repeat(line - 2) +\n            \"server=>({\" +\n            encodedName +\n            \":\\n\" +\n            \" \".repeat(1 > col ? 0 : col - 1) +\n            \"(...args) => server(...args)})\");\n      filename.startsWith(\"/\") && (filename = \"file://\" + filename);\n      sourceMap\n        ? ((col +=\n            \"\\n//# sourceURL=about://React/\" +\n            encodeURIComponent(environmentName) +\n            \"/\" +\n            encodeURI(filename) +\n            \"?s\" +\n            fakeServerFunctionIdx++),\n          (col += \"\\n//# sourceMappingURL=\" + sourceMap))\n        : filename && (col += \"\\n//# sourceURL=\" + filename);\n      try {\n        return (0, eval)(col)(innerFunction)[name];\n      } catch (x) {\n        return innerFunction;\n      }\n    }\n    function registerBoundServerReference(reference, id, bound) {\n      knownServerReferences.has(reference) ||\n        knownServerReferences.set(reference, {\n          id: id,\n          originalBind: reference.bind,\n          bound: bound\n        });\n    }\n    function createBoundServerReference(\n      metaData,\n      callServer,\n      encodeFormAction,\n      findSourceMapURL\n    ) {\n      function action() {\n        var args = Array.prototype.slice.call(arguments);\n        return bound\n          ? \"fulfilled\" === bound.status\n            ? callServer(id, bound.value.concat(args))\n            : Promise.resolve(bound).then(function (boundArgs) {\n                return callServer(id, boundArgs.concat(args));\n              })\n          : callServer(id, args);\n      }\n      var id = metaData.id,\n        bound = metaData.bound,\n        location = metaData.location;\n      if (location) {\n        encodeFormAction = metaData.name || \"\";\n        var filename = location[1],\n          line = location[2];\n        location = location[3];\n        metaData = metaData.env || \"Server\";\n        findSourceMapURL =\n          null == findSourceMapURL\n            ? null\n            : findSourceMapURL(filename, metaData);\n        action = createFakeServerFunction(\n          encodeFormAction,\n          filename,\n          findSourceMapURL,\n          line,\n          location,\n          metaData,\n          action\n        );\n      }\n      registerBoundServerReference(action, id, bound);\n      return action;\n    }\n    function parseStackLocation(error) {\n      error = error.stack;\n      error.startsWith(\"Error: react-stack-top-frame\\n\") &&\n        (error = error.slice(29));\n      var endOfFirst = error.indexOf(\"\\n\");\n      if (-1 !== endOfFirst) {\n        var endOfSecond = error.indexOf(\"\\n\", endOfFirst + 1);\n        endOfFirst =\n          -1 === endOfSecond\n            ? error.slice(endOfFirst + 1)\n            : error.slice(endOfFirst + 1, endOfSecond);\n      } else endOfFirst = error;\n      error = v8FrameRegExp.exec(endOfFirst);\n      if (\n        !error &&\n        ((error = jscSpiderMonkeyFrameRegExp.exec(endOfFirst)), !error)\n      )\n        return null;\n      endOfFirst = error[1] || \"\";\n      \"<anonymous>\" === endOfFirst && (endOfFirst = \"\");\n      endOfSecond = error[2] || error[5] || \"\";\n      \"<anonymous>\" === endOfSecond && (endOfSecond = \"\");\n      return [\n        endOfFirst,\n        endOfSecond,\n        +(error[3] || error[6]),\n        +(error[4] || error[7])\n      ];\n    }\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n        case REACT_VIEW_TRANSITION_TYPE:\n          return \"ViewTransition\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function getArrayKind(array) {\n      for (var kind = 0, i = 0; i < array.length && 100 > i; i++) {\n        var value = array[i];\n        if (\"object\" === typeof value && null !== value)\n          if (\n            isArrayImpl(value) &&\n            2 === value.length &&\n            \"string\" === typeof value[0]\n          ) {\n            if (0 !== kind && 3 !== kind) return 1;\n            kind = 3;\n          } else return 1;\n        else {\n          if (\n            \"function\" === typeof value ||\n            (\"string\" === typeof value && 50 < value.length) ||\n            (0 !== kind && 2 !== kind)\n          )\n            return 1;\n          kind = 2;\n        }\n      }\n      return kind;\n    }\n    function addObjectToProperties(object, properties, indent, prefix) {\n      var addedProperties = 0,\n        key;\n      for (key in object)\n        if (\n          hasOwnProperty.call(object, key) &&\n          \"_\" !== key[0] &&\n          (addedProperties++,\n          addValueToProperties(key, object[key], properties, indent, prefix),\n          100 <= addedProperties)\n        ) {\n          properties.push([\n            prefix +\n              \"\\u00a0\\u00a0\".repeat(indent) +\n              \"Only 100 properties are shown. React will not log more properties of this object.\",\n            \"\"\n          ]);\n          break;\n        }\n    }\n    function addValueToProperties(\n      propertyName,\n      value,\n      properties,\n      indent,\n      prefix\n    ) {\n      switch (typeof value) {\n        case \"object\":\n          if (null === value) {\n            value = \"null\";\n            break;\n          } else {\n            if (value.$$typeof === REACT_ELEMENT_TYPE) {\n              var typeName = getComponentNameFromType(value.type) || \"\\u2026\",\n                key = value.key;\n              value = value.props;\n              var propsKeys = Object.keys(value),\n                propsLength = propsKeys.length;\n              if (null == key && 0 === propsLength) {\n                value = \"<\" + typeName + \" />\";\n                break;\n              }\n              if (\n                3 > indent ||\n                (1 === propsLength &&\n                  \"children\" === propsKeys[0] &&\n                  null == key)\n              ) {\n                value = \"<\" + typeName + \" \\u2026 />\";\n                break;\n              }\n              properties.push([\n                prefix + \"\\u00a0\\u00a0\".repeat(indent) + propertyName,\n                \"<\" + typeName\n              ]);\n              null !== key &&\n                addValueToProperties(\n                  \"key\",\n                  key,\n                  properties,\n                  indent + 1,\n                  prefix\n                );\n              propertyName = !1;\n              key = 0;\n              for (var propKey in value)\n                if (\n                  (key++,\n                  \"children\" === propKey\n                    ? null != value.children &&\n                      (!isArrayImpl(value.children) ||\n                        0 < value.children.length) &&\n                      (propertyName = !0)\n                    : hasOwnProperty.call(value, propKey) &&\n                      \"_\" !== propKey[0] &&\n                      addValueToProperties(\n                        propKey,\n                        value[propKey],\n                        properties,\n                        indent + 1,\n                        prefix\n                      ),\n                  100 <= key)\n                )\n                  break;\n              properties.push([\n                \"\",\n                propertyName ? \">\\u2026</\" + typeName + \">\" : \"/>\"\n              ]);\n              return;\n            }\n            typeName = Object.prototype.toString.call(value);\n            propKey = typeName.slice(8, typeName.length - 1);\n            if (\"Array\" === propKey)\n              if (\n                ((typeName = 100 < value.length),\n                (key = getArrayKind(value)),\n                2 === key || 0 === key)\n              ) {\n                value = JSON.stringify(\n                  typeName ? value.slice(0, 100).concat(\"\\u2026\") : value\n                );\n                break;\n              } else if (3 === key) {\n                properties.push([\n                  prefix + \"\\u00a0\\u00a0\".repeat(indent) + propertyName,\n                  \"\"\n                ]);\n                for (\n                  propertyName = 0;\n                  propertyName < value.length && 100 > propertyName;\n                  propertyName++\n                )\n                  (propKey = value[propertyName]),\n                    addValueToProperties(\n                      propKey[0],\n                      propKey[1],\n                      properties,\n                      indent + 1,\n                      prefix\n                    );\n                typeName &&\n                  addValueToProperties(\n                    (100).toString(),\n                    \"\\u2026\",\n                    properties,\n                    indent + 1,\n                    prefix\n                  );\n                return;\n              }\n            if (\"Promise\" === propKey) {\n              if (\"fulfilled\" === value.status) {\n                if (\n                  ((typeName = properties.length),\n                  addValueToProperties(\n                    propertyName,\n                    value.value,\n                    properties,\n                    indent,\n                    prefix\n                  ),\n                  properties.length > typeName)\n                ) {\n                  properties = properties[typeName];\n                  properties[1] =\n                    \"Promise<\" + (properties[1] || \"Object\") + \">\";\n                  return;\n                }\n              } else if (\n                \"rejected\" === value.status &&\n                ((typeName = properties.length),\n                addValueToProperties(\n                  propertyName,\n                  value.reason,\n                  properties,\n                  indent,\n                  prefix\n                ),\n                properties.length > typeName)\n              ) {\n                properties = properties[typeName];\n                properties[1] = \"Rejected Promise<\" + properties[1] + \">\";\n                return;\n              }\n              properties.push([\n                \"\\u00a0\\u00a0\".repeat(indent) + propertyName,\n                \"Promise\"\n              ]);\n              return;\n            }\n            \"Object\" === propKey &&\n              (typeName = Object.getPrototypeOf(value)) &&\n              \"function\" === typeof typeName.constructor &&\n              (propKey = typeName.constructor.name);\n            properties.push([\n              prefix + \"\\u00a0\\u00a0\".repeat(indent) + propertyName,\n              \"Object\" === propKey ? (3 > indent ? \"\" : \"\\u2026\") : propKey\n            ]);\n            3 > indent &&\n              addObjectToProperties(value, properties, indent + 1, prefix);\n            return;\n          }\n        case \"function\":\n          value = \"\" === value.name ? \"() => {}\" : value.name + \"() {}\";\n          break;\n        case \"string\":\n          value =\n            \"This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.\" ===\n            value\n              ? \"\\u2026\"\n              : JSON.stringify(value);\n          break;\n        case \"undefined\":\n          value = \"undefined\";\n          break;\n        case \"boolean\":\n          value = value ? \"true\" : \"false\";\n          break;\n        default:\n          value = String(value);\n      }\n      properties.push([\n        prefix + \"\\u00a0\\u00a0\".repeat(indent) + propertyName,\n        value\n      ]);\n    }\n    function getIODescription(value) {\n      try {\n        switch (typeof value) {\n          case \"function\":\n            return value.name || \"\";\n          case \"object\":\n            if (null === value) return \"\";\n            if (value instanceof Error) return String(value.message);\n            if (\"string\" === typeof value.url) return value.url;\n            if (\"string\" === typeof value.href) return value.href;\n            if (\"string\" === typeof value.src) return value.src;\n            if (\"string\" === typeof value.currentSrc) return value.currentSrc;\n            if (\"string\" === typeof value.command) return value.command;\n            if (\n              \"object\" === typeof value.request &&\n              null !== value.request &&\n              \"string\" === typeof value.request.url\n            )\n              return value.request.url;\n            if (\n              \"object\" === typeof value.response &&\n              null !== value.response &&\n              \"string\" === typeof value.response.url\n            )\n              return value.response.url;\n            if (\n              \"string\" === typeof value.id ||\n              \"number\" === typeof value.id ||\n              \"bigint\" === typeof value.id\n            )\n              return String(value.id);\n            if (\"string\" === typeof value.name) return value.name;\n            var str = value.toString();\n            return str.startsWith(\"[object \") ||\n              5 > str.length ||\n              500 < str.length\n              ? \"\"\n              : str;\n          case \"string\":\n            return 5 > value.length || 500 < value.length ? \"\" : value;\n          case \"number\":\n          case \"bigint\":\n            return String(value);\n          default:\n            return \"\";\n        }\n      } catch (x) {\n        return \"\";\n      }\n    }\n    function markAllTracksInOrder() {\n      supportsUserTiming &&\n        (console.timeStamp(\n          \"Server Requests Track\",\n          0.001,\n          0.001,\n          \"Server Requests \\u269b\",\n          void 0,\n          \"primary-light\"\n        ),\n        console.timeStamp(\n          \"Server Components Track\",\n          0.001,\n          0.001,\n          \"Primary\",\n          \"Server Components \\u269b\",\n          \"primary-light\"\n        ));\n    }\n    function getIOColor(functionName) {\n      switch (functionName.charCodeAt(0) % 3) {\n        case 0:\n          return \"tertiary-light\";\n        case 1:\n          return \"tertiary\";\n        default:\n          return \"tertiary-dark\";\n      }\n    }\n    function getIOLongName(ioInfo, description, env, rootEnv) {\n      ioInfo = ioInfo.name;\n      description =\n        \"\" === description ? ioInfo : ioInfo + \" (\" + description + \")\";\n      return env === rootEnv || void 0 === env\n        ? description\n        : description + \" [\" + env + \"]\";\n    }\n    function getIOShortName(ioInfo, description, env, rootEnv) {\n      ioInfo = ioInfo.name;\n      env = env === rootEnv || void 0 === env ? \"\" : \" [\" + env + \"]\";\n      var desc = \"\";\n      rootEnv = 30 - ioInfo.length - env.length;\n      if (1 < rootEnv) {\n        var l = description.length;\n        if (0 < l && l <= rootEnv) desc = \" (\" + description + \")\";\n        else if (\n          description.startsWith(\"http://\") ||\n          description.startsWith(\"https://\") ||\n          description.startsWith(\"/\")\n        ) {\n          var queryIdx = description.indexOf(\"?\");\n          -1 === queryIdx && (queryIdx = description.length);\n          47 === description.charCodeAt(queryIdx - 1) && queryIdx--;\n          desc = description.lastIndexOf(\"/\", queryIdx - 1);\n          queryIdx - desc < rootEnv\n            ? (desc = \" (\\u2026\" + description.slice(desc, queryIdx) + \")\")\n            : ((l = description.slice(desc, desc + rootEnv / 2)),\n              (description = description.slice(\n                queryIdx - rootEnv / 2,\n                queryIdx\n              )),\n              (desc =\n                \" (\" +\n                (0 < desc ? \"\\u2026\" : \"\") +\n                l +\n                \"\\u2026\" +\n                description +\n                \")\"));\n        }\n      }\n      return ioInfo + desc + env;\n    }\n    function logComponentAwait(\n      asyncInfo,\n      trackIdx,\n      startTime,\n      endTime,\n      rootEnv,\n      value\n    ) {\n      if (supportsUserTiming && 0 < endTime) {\n        var description = getIODescription(value),\n          name = getIOShortName(\n            asyncInfo.awaited,\n            description,\n            asyncInfo.env,\n            rootEnv\n          ),\n          entryName = \"await \" + name;\n        name = getIOColor(name);\n        var debugTask = asyncInfo.debugTask || asyncInfo.awaited.debugTask;\n        if (debugTask) {\n          var properties = [];\n          \"object\" === typeof value && null !== value\n            ? addObjectToProperties(value, properties, 0, \"\")\n            : void 0 !== value &&\n              addValueToProperties(\"awaited value\", value, properties, 0, \"\");\n          asyncInfo = getIOLongName(\n            asyncInfo.awaited,\n            description,\n            asyncInfo.env,\n            rootEnv\n          );\n          debugTask.run(\n            performance.measure.bind(performance, entryName, {\n              start: 0 > startTime ? 0 : startTime,\n              end: endTime,\n              detail: {\n                devtools: {\n                  color: name,\n                  track: trackNames[trackIdx],\n                  trackGroup: \"Server Components \\u269b\",\n                  properties: properties,\n                  tooltipText: asyncInfo\n                }\n              }\n            })\n          );\n          performance.clearMeasures(entryName);\n        } else\n          console.timeStamp(\n            entryName,\n            0 > startTime ? 0 : startTime,\n            endTime,\n            trackNames[trackIdx],\n            \"Server Components \\u269b\",\n            name\n          );\n      }\n    }\n    function logIOInfoErrored(ioInfo, rootEnv, error) {\n      var startTime = ioInfo.start,\n        endTime = ioInfo.end;\n      if (supportsUserTiming && 0 <= endTime) {\n        var description = getIODescription(error),\n          entryName = getIOShortName(ioInfo, description, ioInfo.env, rootEnv),\n          debugTask = ioInfo.debugTask;\n        entryName = \"\\u200b\" + entryName;\n        debugTask\n          ? ((error = [\n              [\n                \"rejected with\",\n                \"object\" === typeof error &&\n                null !== error &&\n                \"string\" === typeof error.message\n                  ? String(error.message)\n                  : String(error)\n              ]\n            ]),\n            (ioInfo =\n              getIOLongName(ioInfo, description, ioInfo.env, rootEnv) +\n              \" Rejected\"),\n            debugTask.run(\n              performance.measure.bind(performance, entryName, {\n                start: 0 > startTime ? 0 : startTime,\n                end: endTime,\n                detail: {\n                  devtools: {\n                    color: \"error\",\n                    track: \"Server Requests \\u269b\",\n                    properties: error,\n                    tooltipText: ioInfo\n                  }\n                }\n              })\n            ),\n            performance.clearMeasures(entryName))\n          : console.timeStamp(\n              entryName,\n              0 > startTime ? 0 : startTime,\n              endTime,\n              \"Server Requests \\u269b\",\n              void 0,\n              \"error\"\n            );\n      }\n    }\n    function logIOInfo(ioInfo, rootEnv, value) {\n      var startTime = ioInfo.start,\n        endTime = ioInfo.end;\n      if (supportsUserTiming && 0 <= endTime) {\n        var description = getIODescription(value),\n          entryName = getIOShortName(ioInfo, description, ioInfo.env, rootEnv),\n          color = getIOColor(entryName),\n          debugTask = ioInfo.debugTask;\n        entryName = \"\\u200b\" + entryName;\n        if (debugTask) {\n          var properties = [];\n          \"object\" === typeof value && null !== value\n            ? addObjectToProperties(value, properties, 0, \"\")\n            : void 0 !== value &&\n              addValueToProperties(\"Resolved\", value, properties, 0, \"\");\n          ioInfo = getIOLongName(ioInfo, description, ioInfo.env, rootEnv);\n          debugTask.run(\n            performance.measure.bind(performance, entryName, {\n              start: 0 > startTime ? 0 : startTime,\n              end: endTime,\n              detail: {\n                devtools: {\n                  color: color,\n                  track: \"Server Requests \\u269b\",\n                  properties: properties,\n                  tooltipText: ioInfo\n                }\n              }\n            })\n          );\n          performance.clearMeasures(entryName);\n        } else\n          console.timeStamp(\n            entryName,\n            0 > startTime ? 0 : startTime,\n            endTime,\n            \"Server Requests \\u269b\",\n            void 0,\n            color\n          );\n      }\n    }\n    function ReactPromise(status, value, reason) {\n      this.status = status;\n      this.value = value;\n      this.reason = reason;\n      this._children = [];\n      this._debugChunk = null;\n      this._debugInfo = [];\n    }\n    function unwrapWeakResponse(weakResponse) {\n      weakResponse = weakResponse.weak.deref();\n      if (void 0 === weakResponse)\n        throw Error(\n          \"We did not expect to receive new data after GC:ing the response.\"\n        );\n      return weakResponse;\n    }\n    function closeDebugChannel(debugChannel) {\n      debugChannel.callback && debugChannel.callback(\"\");\n    }\n    function readChunk(chunk) {\n      switch (chunk.status) {\n        case \"resolved_model\":\n          initializeModelChunk(chunk);\n          break;\n        case \"resolved_module\":\n          initializeModuleChunk(chunk);\n      }\n      switch (chunk.status) {\n        case \"fulfilled\":\n          return chunk.value;\n        case \"pending\":\n        case \"blocked\":\n        case \"halted\":\n          throw chunk;\n        default:\n          throw chunk.reason;\n      }\n    }\n    function getRoot(weakResponse) {\n      weakResponse = unwrapWeakResponse(weakResponse);\n      return getChunk(weakResponse, 0);\n    }\n    function createPendingChunk(response) {\n      0 === response._pendingChunks++ &&\n        ((response._weakResponse.response = response),\n        null !== response._pendingInitialRender &&\n          (clearTimeout(response._pendingInitialRender),\n          (response._pendingInitialRender = null)));\n      return new ReactPromise(\"pending\", null, null);\n    }\n    function releasePendingChunk(response, chunk) {\n      \"pending\" === chunk.status &&\n        0 === --response._pendingChunks &&\n        ((response._weakResponse.response = null),\n        (response._pendingInitialRender = setTimeout(\n          flushInitialRenderPerformance.bind(null, response),\n          100\n        )));\n    }\n    function filterDebugInfo(response, value) {\n      if (null !== response._debugEndTime) {\n        response = response._debugEndTime - performance.timeOrigin;\n        for (var debugInfo = [], i = 0; i < value._debugInfo.length; i++) {\n          var info = value._debugInfo[i];\n          if (\"number\" === typeof info.time && info.time > response) break;\n          debugInfo.push(info);\n        }\n        value._debugInfo = debugInfo;\n      }\n    }\n    function moveDebugInfoFromChunkToInnerValue(chunk, value) {\n      value = resolveLazy(value);\n      \"object\" !== typeof value ||\n        null === value ||\n        (!isArrayImpl(value) &&\n          \"function\" !== typeof value[ASYNC_ITERATOR] &&\n          value.$$typeof !== REACT_ELEMENT_TYPE &&\n          value.$$typeof !== REACT_LAZY_TYPE) ||\n        ((chunk = chunk._debugInfo.splice(0)),\n        isArrayImpl(value._debugInfo)\n          ? value._debugInfo.unshift.apply(value._debugInfo, chunk)\n          : Object.defineProperty(value, \"_debugInfo\", {\n              configurable: !1,\n              enumerable: !1,\n              writable: !0,\n              value: chunk\n            }));\n    }\n    function wakeChunk(response, listeners, value, chunk) {\n      for (var i = 0; i < listeners.length; i++) {\n        var listener = listeners[i];\n        \"function\" === typeof listener\n          ? listener(value)\n          : fulfillReference(response, listener, value, chunk);\n      }\n      filterDebugInfo(response, chunk);\n      moveDebugInfoFromChunkToInnerValue(chunk, value);\n    }\n    function rejectChunk(response, listeners, error) {\n      for (var i = 0; i < listeners.length; i++) {\n        var listener = listeners[i];\n        \"function\" === typeof listener\n          ? listener(error)\n          : rejectReference(response, listener.handler, error);\n      }\n    }\n    function resolveBlockedCycle(resolvedChunk, reference) {\n      var referencedChunk = reference.handler.chunk;\n      if (null === referencedChunk) return null;\n      if (referencedChunk === resolvedChunk) return reference.handler;\n      reference = referencedChunk.value;\n      if (null !== reference)\n        for (\n          referencedChunk = 0;\n          referencedChunk < reference.length;\n          referencedChunk++\n        ) {\n          var listener = reference[referencedChunk];\n          if (\n            \"function\" !== typeof listener &&\n            ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n            null !== listener)\n          )\n            return listener;\n        }\n      return null;\n    }\n    function wakeChunkIfInitialized(\n      response,\n      chunk,\n      resolveListeners,\n      rejectListeners\n    ) {\n      switch (chunk.status) {\n        case \"fulfilled\":\n          wakeChunk(response, resolveListeners, chunk.value, chunk);\n          break;\n        case \"blocked\":\n          for (var i = 0; i < resolveListeners.length; i++) {\n            var listener = resolveListeners[i];\n            if (\"function\" !== typeof listener) {\n              var cyclicHandler = resolveBlockedCycle(chunk, listener);\n              if (null !== cyclicHandler)\n                switch (\n                  (fulfillReference(\n                    response,\n                    listener,\n                    cyclicHandler.value,\n                    chunk\n                  ),\n                  resolveListeners.splice(i, 1),\n                  i--,\n                  null !== rejectListeners &&\n                    ((listener = rejectListeners.indexOf(listener)),\n                    -1 !== listener && rejectListeners.splice(listener, 1)),\n                  chunk.status)\n                ) {\n                  case \"fulfilled\":\n                    wakeChunk(response, resolveListeners, chunk.value, chunk);\n                    return;\n                  case \"rejected\":\n                    null !== rejectListeners &&\n                      rejectChunk(response, rejectListeners, chunk.reason);\n                    return;\n                }\n            }\n          }\n        case \"pending\":\n          if (chunk.value)\n            for (response = 0; response < resolveListeners.length; response++)\n              chunk.value.push(resolveListeners[response]);\n          else chunk.value = resolveListeners;\n          if (chunk.reason) {\n            if (rejectListeners)\n              for (\n                resolveListeners = 0;\n                resolveListeners < rejectListeners.length;\n                resolveListeners++\n              )\n                chunk.reason.push(rejectListeners[resolveListeners]);\n          } else chunk.reason = rejectListeners;\n          break;\n        case \"rejected\":\n          rejectListeners &&\n            rejectChunk(response, rejectListeners, chunk.reason);\n      }\n    }\n    function triggerErrorOnChunk(response, chunk, error) {\n      if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n        chunk.reason.error(error);\n      else {\n        releasePendingChunk(response, chunk);\n        var listeners = chunk.reason;\n        if (\"pending\" === chunk.status && null != chunk._debugChunk) {\n          var prevHandler = initializingHandler,\n            prevChunk = initializingChunk;\n          initializingHandler = null;\n          chunk.status = \"blocked\";\n          chunk.value = null;\n          chunk.reason = null;\n          initializingChunk = chunk;\n          try {\n            initializeDebugChunk(response, chunk);\n          } finally {\n            (initializingHandler = prevHandler),\n              (initializingChunk = prevChunk);\n          }\n        }\n        chunk.status = \"rejected\";\n        chunk.reason = error;\n        null !== listeners && rejectChunk(response, listeners, error);\n      }\n    }\n    function createResolvedModelChunk(response, value) {\n      return new ReactPromise(\"resolved_model\", value, response);\n    }\n    function createResolvedIteratorResultChunk(response, value, done) {\n      return new ReactPromise(\n        \"resolved_model\",\n        (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n          value +\n          \"}\",\n        response\n      );\n    }\n    function resolveIteratorResultChunk(response, chunk, value, done) {\n      resolveModelChunk(\n        response,\n        chunk,\n        (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n          value +\n          \"}\"\n      );\n    }\n    function resolveModelChunk(response, chunk, value) {\n      if (\"pending\" !== chunk.status) chunk.reason.enqueueModel(value);\n      else {\n        releasePendingChunk(response, chunk);\n        var resolveListeners = chunk.value,\n          rejectListeners = chunk.reason;\n        chunk.status = \"resolved_model\";\n        chunk.value = value;\n        chunk.reason = response;\n        null !== resolveListeners &&\n          (initializeModelChunk(chunk),\n          wakeChunkIfInitialized(\n            response,\n            chunk,\n            resolveListeners,\n            rejectListeners\n          ));\n      }\n    }\n    function resolveModuleChunk(response, chunk, value) {\n      if (\"pending\" === chunk.status || \"blocked\" === chunk.status) {\n        releasePendingChunk(response, chunk);\n        var resolveListeners = chunk.value,\n          rejectListeners = chunk.reason;\n        chunk.status = \"resolved_module\";\n        chunk.value = value;\n        chunk.reason = null;\n        value = value[1];\n        for (var debugInfo = [], i = 0; i < value.length; ) {\n          var chunkId = value[i++];\n          value[i++];\n          var href = void 0,\n            target = debugInfo,\n            ioInfo = chunkIOInfoCache.get(chunkId);\n          if (void 0 === ioInfo) {\n            var scriptFilename = __webpack_require__.u(chunkId);\n            try {\n              href = new URL(scriptFilename, document.baseURI).href;\n            } catch (_) {\n              href = scriptFilename;\n            }\n            var end = (ioInfo = -1);\n            scriptFilename = 0;\n            if (\"function\" === typeof performance.getEntriesByType)\n              for (\n                var resourceEntries = performance.getEntriesByType(\"resource\"),\n                  i$jscomp$0 = 0;\n                i$jscomp$0 < resourceEntries.length;\n                i$jscomp$0++\n              ) {\n                var resourceEntry = resourceEntries[i$jscomp$0];\n                resourceEntry.name === href &&\n                  ((ioInfo = resourceEntry.startTime),\n                  (end = ioInfo + resourceEntry.duration),\n                  (scriptFilename = resourceEntry.transferSize || 0));\n              }\n            resourceEntries = Promise.resolve(href);\n            resourceEntries.status = \"fulfilled\";\n            resourceEntries.value = { chunkId: chunkId, href: href };\n            i$jscomp$0 = Error(\"react-stack-top-frame\");\n            i$jscomp$0.stack.startsWith(\"Error: react-stack-top-frame\")\n              ? (i$jscomp$0.stack =\n                  \"Error: react-stack-top-frame\\n    at Client Component Bundle (\" +\n                  href +\n                  \":1:1)\\n    at Client Component Bundle (\" +\n                  href +\n                  \":1:1)\")\n              : (i$jscomp$0.stack =\n                  \"Client Component Bundle@\" +\n                  href +\n                  \":1:1\\nClient Component Bundle@\" +\n                  href +\n                  \":1:1\");\n            ioInfo = {\n              name: \"script\",\n              start: ioInfo,\n              end: end,\n              value: resourceEntries,\n              debugStack: i$jscomp$0\n            };\n            0 < scriptFilename && (ioInfo.byteSize = scriptFilename);\n            chunkIOInfoCache.set(chunkId, ioInfo);\n          }\n          target.push({ awaited: ioInfo });\n        }\n        null !== debugInfo &&\n          chunk._debugInfo.push.apply(chunk._debugInfo, debugInfo);\n        null !== resolveListeners &&\n          (initializeModuleChunk(chunk),\n          wakeChunkIfInitialized(\n            response,\n            chunk,\n            resolveListeners,\n            rejectListeners\n          ));\n      }\n    }\n    function initializeDebugChunk(response, chunk) {\n      var debugChunk = chunk._debugChunk;\n      if (null !== debugChunk) {\n        var debugInfo = chunk._debugInfo;\n        try {\n          if (\"resolved_model\" === debugChunk.status) {\n            for (\n              var idx = debugInfo.length, c = debugChunk._debugChunk;\n              null !== c;\n\n            )\n              \"fulfilled\" !== c.status && idx++, (c = c._debugChunk);\n            initializeModelChunk(debugChunk);\n            switch (debugChunk.status) {\n              case \"fulfilled\":\n                debugInfo[idx] = initializeDebugInfo(\n                  response,\n                  debugChunk.value\n                );\n                break;\n              case \"blocked\":\n              case \"pending\":\n                waitForReference(\n                  debugChunk,\n                  debugInfo,\n                  \"\" + idx,\n                  response,\n                  initializeDebugInfo,\n                  [\"\"],\n                  !0\n                );\n                break;\n              default:\n                throw debugChunk.reason;\n            }\n          } else\n            switch (debugChunk.status) {\n              case \"fulfilled\":\n                break;\n              case \"blocked\":\n              case \"pending\":\n                waitForReference(\n                  debugChunk,\n                  {},\n                  \"debug\",\n                  response,\n                  initializeDebugInfo,\n                  [\"\"],\n                  !0\n                );\n                break;\n              default:\n                throw debugChunk.reason;\n            }\n        } catch (error) {\n          triggerErrorOnChunk(response, chunk, error);\n        }\n      }\n    }\n    function initializeModelChunk(chunk) {\n      var prevHandler = initializingHandler,\n        prevChunk = initializingChunk;\n      initializingHandler = null;\n      var resolvedModel = chunk.value,\n        response = chunk.reason;\n      chunk.status = \"blocked\";\n      chunk.value = null;\n      chunk.reason = null;\n      initializingChunk = chunk;\n      initializeDebugChunk(response, chunk);\n      try {\n        var value = JSON.parse(resolvedModel, response._fromJSON),\n          resolveListeners = chunk.value;\n        if (null !== resolveListeners)\n          for (\n            chunk.value = null, chunk.reason = null, resolvedModel = 0;\n            resolvedModel < resolveListeners.length;\n            resolvedModel++\n          ) {\n            var listener = resolveListeners[resolvedModel];\n            \"function\" === typeof listener\n              ? listener(value)\n              : fulfillReference(response, listener, value, chunk);\n          }\n        if (null !== initializingHandler) {\n          if (initializingHandler.errored) throw initializingHandler.reason;\n          if (0 < initializingHandler.deps) {\n            initializingHandler.value = value;\n            initializingHandler.chunk = chunk;\n            return;\n          }\n        }\n        chunk.status = \"fulfilled\";\n        chunk.value = value;\n        filterDebugInfo(response, chunk);\n        moveDebugInfoFromChunkToInnerValue(chunk, value);\n      } catch (error) {\n        (chunk.status = \"rejected\"), (chunk.reason = error);\n      } finally {\n        (initializingHandler = prevHandler), (initializingChunk = prevChunk);\n      }\n    }\n    function initializeModuleChunk(chunk) {\n      try {\n        var value = requireModule(chunk.value);\n        chunk.status = \"fulfilled\";\n        chunk.value = value;\n      } catch (error) {\n        (chunk.status = \"rejected\"), (chunk.reason = error);\n      }\n    }\n    function reportGlobalError(weakResponse, error) {\n      if (void 0 !== weakResponse.weak.deref()) {\n        var response = unwrapWeakResponse(weakResponse);\n        response._closed = !0;\n        response._closedReason = error;\n        response._chunks.forEach(function (chunk) {\n          \"pending\" === chunk.status\n            ? triggerErrorOnChunk(response, chunk, error)\n            : \"fulfilled\" === chunk.status &&\n              null !== chunk.reason &&\n              chunk.reason.error(error);\n        });\n        weakResponse = response._debugChannel;\n        void 0 !== weakResponse &&\n          (closeDebugChannel(weakResponse),\n          (response._debugChannel = void 0),\n          null !== debugChannelRegistry &&\n            debugChannelRegistry.unregister(response));\n      }\n    }\n    function nullRefGetter() {\n      return null;\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\"function\" === typeof type) return '\"use client\"';\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return type._init === readChunk ? '\"use client\"' : \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function initializeElement(response, element, lazyNode) {\n      var stack = element._debugStack,\n        owner = element._owner;\n      null === owner && (element._owner = response._debugRootOwner);\n      var env = response._rootEnvironmentName;\n      null !== owner && null != owner.env && (env = owner.env);\n      var normalizedStackTrace = null;\n      null === owner && null != response._debugRootStack\n        ? (normalizedStackTrace = response._debugRootStack)\n        : null !== stack &&\n          (normalizedStackTrace = createFakeJSXCallStackInDEV(\n            response,\n            stack,\n            env\n          ));\n      element._debugStack = normalizedStackTrace;\n      normalizedStackTrace = null;\n      supportsCreateTask &&\n        null !== stack &&\n        ((normalizedStackTrace = console.createTask.bind(\n          console,\n          getTaskName(element.type)\n        )),\n        (stack = buildFakeCallStack(\n          response,\n          stack,\n          env,\n          !1,\n          normalizedStackTrace\n        )),\n        (env = null === owner ? null : initializeFakeTask(response, owner)),\n        null === env\n          ? ((env = response._debugRootTask),\n            (normalizedStackTrace = null != env ? env.run(stack) : stack()))\n          : (normalizedStackTrace = env.run(stack)));\n      element._debugTask = normalizedStackTrace;\n      null !== owner && initializeFakeStack(response, owner);\n      null !== lazyNode &&\n        (lazyNode._store &&\n          lazyNode._store.validated &&\n          !element._store.validated &&\n          (element._store.validated = lazyNode._store.validated),\n        \"fulfilled\" === lazyNode._payload.status &&\n          lazyNode._debugInfo &&\n          ((response = lazyNode._debugInfo.splice(0)),\n          element._debugInfo\n            ? element._debugInfo.unshift.apply(element._debugInfo, response)\n            : Object.defineProperty(element, \"_debugInfo\", {\n                configurable: !1,\n                enumerable: !1,\n                writable: !0,\n                value: response\n              })));\n      Object.freeze(element.props);\n    }\n    function createLazyChunkWrapper(chunk, validated) {\n      var lazyType = {\n        $$typeof: REACT_LAZY_TYPE,\n        _payload: chunk,\n        _init: readChunk\n      };\n      lazyType._debugInfo = chunk._debugInfo;\n      lazyType._store = { validated: validated };\n      return lazyType;\n    }\n    function getChunk(response, id) {\n      var chunks = response._chunks,\n        chunk = chunks.get(id);\n      chunk ||\n        ((chunk = response._closed\n          ? new ReactPromise(\"rejected\", null, response._closedReason)\n          : createPendingChunk(response)),\n        chunks.set(id, chunk));\n      return chunk;\n    }\n    function fulfillReference(response, reference, value, fulfilledChunk) {\n      var handler = reference.handler,\n        parentObject = reference.parentObject,\n        key = reference.key,\n        map = reference.map,\n        path = reference.path;\n      try {\n        for (var i = 1; i < path.length; i++) {\n          for (\n            ;\n            \"object\" === typeof value &&\n            null !== value &&\n            value.$$typeof === REACT_LAZY_TYPE;\n\n          ) {\n            var referencedChunk = value._payload;\n            if (referencedChunk === handler.chunk) value = handler.value;\n            else {\n              switch (referencedChunk.status) {\n                case \"resolved_model\":\n                  initializeModelChunk(referencedChunk);\n                  break;\n                case \"resolved_module\":\n                  initializeModuleChunk(referencedChunk);\n              }\n              switch (referencedChunk.status) {\n                case \"fulfilled\":\n                  value = referencedChunk.value;\n                  continue;\n                case \"blocked\":\n                  var cyclicHandler = resolveBlockedCycle(\n                    referencedChunk,\n                    reference\n                  );\n                  if (null !== cyclicHandler) {\n                    value = cyclicHandler.value;\n                    continue;\n                  }\n                case \"pending\":\n                  path.splice(0, i - 1);\n                  null === referencedChunk.value\n                    ? (referencedChunk.value = [reference])\n                    : referencedChunk.value.push(reference);\n                  null === referencedChunk.reason\n                    ? (referencedChunk.reason = [reference])\n                    : referencedChunk.reason.push(reference);\n                  return;\n                case \"halted\":\n                  return;\n                default:\n                  rejectReference(\n                    response,\n                    reference.handler,\n                    referencedChunk.reason\n                  );\n                  return;\n              }\n            }\n          }\n          var name = path[i];\n          if (\n            \"object\" === typeof value &&\n            null !== value &&\n            hasOwnProperty.call(value, name)\n          )\n            value = value[name];\n          else throw Error(\"Invalid reference.\");\n        }\n        for (\n          ;\n          \"object\" === typeof value &&\n          null !== value &&\n          value.$$typeof === REACT_LAZY_TYPE;\n\n        ) {\n          var _referencedChunk = value._payload;\n          if (_referencedChunk === handler.chunk) value = handler.value;\n          else {\n            switch (_referencedChunk.status) {\n              case \"resolved_model\":\n                initializeModelChunk(_referencedChunk);\n                break;\n              case \"resolved_module\":\n                initializeModuleChunk(_referencedChunk);\n            }\n            switch (_referencedChunk.status) {\n              case \"fulfilled\":\n                value = _referencedChunk.value;\n                continue;\n            }\n            break;\n          }\n        }\n        var mappedValue = map(response, value, parentObject, key);\n        \"__proto__\" !== key && (parentObject[key] = mappedValue);\n        \"\" === key && null === handler.value && (handler.value = mappedValue);\n        if (\n          parentObject[0] === REACT_ELEMENT_TYPE &&\n          \"object\" === typeof handler.value &&\n          null !== handler.value &&\n          handler.value.$$typeof === REACT_ELEMENT_TYPE\n        ) {\n          var element = handler.value;\n          switch (key) {\n            case \"3\":\n              transferReferencedDebugInfo(handler.chunk, fulfilledChunk);\n              element.props = mappedValue;\n              break;\n            case \"4\":\n              element._owner = mappedValue;\n              break;\n            case \"5\":\n              element._debugStack = mappedValue;\n              break;\n            default:\n              transferReferencedDebugInfo(handler.chunk, fulfilledChunk);\n          }\n        } else\n          reference.isDebug ||\n            transferReferencedDebugInfo(handler.chunk, fulfilledChunk);\n      } catch (error) {\n        rejectReference(response, reference.handler, error);\n        return;\n      }\n      handler.deps--;\n      0 === handler.deps &&\n        ((reference = handler.chunk),\n        null !== reference &&\n          \"blocked\" === reference.status &&\n          ((value = reference.value),\n          (reference.status = \"fulfilled\"),\n          (reference.value = handler.value),\n          (reference.reason = handler.reason),\n          null !== value\n            ? wakeChunk(response, value, handler.value, reference)\n            : ((handler = handler.value),\n              filterDebugInfo(response, reference),\n              moveDebugInfoFromChunkToInnerValue(reference, handler))));\n    }\n    function rejectReference(response, handler, error) {\n      if (!handler.errored) {\n        var blockedValue = handler.value;\n        handler.errored = !0;\n        handler.value = null;\n        handler.reason = error;\n        handler = handler.chunk;\n        if (null !== handler && \"blocked\" === handler.status) {\n          if (\n            \"object\" === typeof blockedValue &&\n            null !== blockedValue &&\n            blockedValue.$$typeof === REACT_ELEMENT_TYPE\n          ) {\n            var erroredComponent = {\n              name: getComponentNameFromType(blockedValue.type) || \"\",\n              owner: blockedValue._owner\n            };\n            erroredComponent.debugStack = blockedValue._debugStack;\n            supportsCreateTask &&\n              (erroredComponent.debugTask = blockedValue._debugTask);\n            handler._debugInfo.push(erroredComponent);\n          }\n          triggerErrorOnChunk(response, handler, error);\n        }\n      }\n    }\n    function waitForReference(\n      referencedChunk,\n      parentObject,\n      key,\n      response,\n      map,\n      path,\n      isAwaitingDebugInfo\n    ) {\n      if (\n        !(\n          (void 0 !== response._debugChannel &&\n            response._debugChannel.hasReadable) ||\n          \"pending\" !== referencedChunk.status ||\n          parentObject[0] !== REACT_ELEMENT_TYPE ||\n          (\"4\" !== key && \"5\" !== key)\n        )\n      )\n        return null;\n      initializingHandler\n        ? ((response = initializingHandler), response.deps++)\n        : (response = initializingHandler =\n            {\n              parent: null,\n              chunk: null,\n              value: null,\n              reason: null,\n              deps: 1,\n              errored: !1\n            });\n      parentObject = {\n        handler: response,\n        parentObject: parentObject,\n        key: key,\n        map: map,\n        path: path\n      };\n      parentObject.isDebug = isAwaitingDebugInfo;\n      null === referencedChunk.value\n        ? (referencedChunk.value = [parentObject])\n        : referencedChunk.value.push(parentObject);\n      null === referencedChunk.reason\n        ? (referencedChunk.reason = [parentObject])\n        : referencedChunk.reason.push(parentObject);\n      return null;\n    }\n    function loadServerReference(response, metaData, parentObject, key) {\n      if (!response._serverReferenceConfig)\n        return createBoundServerReference(\n          metaData,\n          response._callServer,\n          response._encodeFormAction,\n          response._debugFindSourceMapURL\n        );\n      var serverReference = resolveServerReference(\n          response._serverReferenceConfig,\n          metaData.id\n        ),\n        promise = preloadModule(serverReference);\n      if (promise)\n        metaData.bound && (promise = Promise.all([promise, metaData.bound]));\n      else if (metaData.bound) promise = Promise.resolve(metaData.bound);\n      else\n        return (\n          (promise = requireModule(serverReference)),\n          registerBoundServerReference(promise, metaData.id, metaData.bound),\n          promise\n        );\n      if (initializingHandler) {\n        var handler = initializingHandler;\n        handler.deps++;\n      } else\n        handler = initializingHandler = {\n          parent: null,\n          chunk: null,\n          value: null,\n          reason: null,\n          deps: 1,\n          errored: !1\n        };\n      promise.then(\n        function () {\n          var resolvedValue = requireModule(serverReference);\n          if (metaData.bound) {\n            var boundArgs = metaData.bound.value.slice(0);\n            boundArgs.unshift(null);\n            resolvedValue = resolvedValue.bind.apply(resolvedValue, boundArgs);\n          }\n          registerBoundServerReference(\n            resolvedValue,\n            metaData.id,\n            metaData.bound\n          );\n          \"__proto__\" !== key && (parentObject[key] = resolvedValue);\n          \"\" === key &&\n            null === handler.value &&\n            (handler.value = resolvedValue);\n          if (\n            parentObject[0] === REACT_ELEMENT_TYPE &&\n            \"object\" === typeof handler.value &&\n            null !== handler.value &&\n            handler.value.$$typeof === REACT_ELEMENT_TYPE\n          )\n            switch (((boundArgs = handler.value), key)) {\n              case \"3\":\n                boundArgs.props = resolvedValue;\n                break;\n              case \"4\":\n                boundArgs._owner = resolvedValue;\n            }\n          handler.deps--;\n          0 === handler.deps &&\n            ((resolvedValue = handler.chunk),\n            null !== resolvedValue &&\n              \"blocked\" === resolvedValue.status &&\n              ((boundArgs = resolvedValue.value),\n              (resolvedValue.status = \"fulfilled\"),\n              (resolvedValue.value = handler.value),\n              (resolvedValue.reason = null),\n              null !== boundArgs\n                ? wakeChunk(response, boundArgs, handler.value, resolvedValue)\n                : ((boundArgs = handler.value),\n                  filterDebugInfo(response, resolvedValue),\n                  moveDebugInfoFromChunkToInnerValue(\n                    resolvedValue,\n                    boundArgs\n                  ))));\n        },\n        function (error) {\n          if (!handler.errored) {\n            var blockedValue = handler.value;\n            handler.errored = !0;\n            handler.value = null;\n            handler.reason = error;\n            var chunk = handler.chunk;\n            if (null !== chunk && \"blocked\" === chunk.status) {\n              if (\n                \"object\" === typeof blockedValue &&\n                null !== blockedValue &&\n                blockedValue.$$typeof === REACT_ELEMENT_TYPE\n              ) {\n                var erroredComponent = {\n                  name: getComponentNameFromType(blockedValue.type) || \"\",\n                  owner: blockedValue._owner\n                };\n                erroredComponent.debugStack = blockedValue._debugStack;\n                supportsCreateTask &&\n                  (erroredComponent.debugTask = blockedValue._debugTask);\n                chunk._debugInfo.push(erroredComponent);\n              }\n              triggerErrorOnChunk(response, chunk, error);\n            }\n          }\n        }\n      );\n      return null;\n    }\n    function resolveLazy(value) {\n      for (\n        ;\n        \"object\" === typeof value &&\n        null !== value &&\n        value.$$typeof === REACT_LAZY_TYPE;\n\n      ) {\n        var payload = value._payload;\n        if (\"fulfilled\" === payload.status) value = payload.value;\n        else break;\n      }\n      return value;\n    }\n    function transferReferencedDebugInfo(parentChunk, referencedChunk) {\n      if (null !== parentChunk) {\n        referencedChunk = referencedChunk._debugInfo;\n        parentChunk = parentChunk._debugInfo;\n        for (var i = 0; i < referencedChunk.length; ++i) {\n          var debugInfoEntry = referencedChunk[i];\n          null == debugInfoEntry.name && parentChunk.push(debugInfoEntry);\n        }\n      }\n    }\n    function getOutlinedModel(response, reference, parentObject, key, map) {\n      var path = reference.split(\":\");\n      reference = parseInt(path[0], 16);\n      reference = getChunk(response, reference);\n      null !== initializingChunk &&\n        isArrayImpl(initializingChunk._children) &&\n        initializingChunk._children.push(reference);\n      switch (reference.status) {\n        case \"resolved_model\":\n          initializeModelChunk(reference);\n          break;\n        case \"resolved_module\":\n          initializeModuleChunk(reference);\n      }\n      switch (reference.status) {\n        case \"fulfilled\":\n          for (var value = reference.value, i = 1; i < path.length; i++) {\n            for (\n              ;\n              \"object\" === typeof value &&\n              null !== value &&\n              value.$$typeof === REACT_LAZY_TYPE;\n\n            ) {\n              value = value._payload;\n              switch (value.status) {\n                case \"resolved_model\":\n                  initializeModelChunk(value);\n                  break;\n                case \"resolved_module\":\n                  initializeModuleChunk(value);\n              }\n              switch (value.status) {\n                case \"fulfilled\":\n                  value = value.value;\n                  break;\n                case \"blocked\":\n                case \"pending\":\n                  return waitForReference(\n                    value,\n                    parentObject,\n                    key,\n                    response,\n                    map,\n                    path.slice(i - 1),\n                    !1\n                  );\n                case \"halted\":\n                  return (\n                    initializingHandler\n                      ? ((parentObject = initializingHandler),\n                        parentObject.deps++)\n                      : (initializingHandler = {\n                          parent: null,\n                          chunk: null,\n                          value: null,\n                          reason: null,\n                          deps: 1,\n                          errored: !1\n                        }),\n                    null\n                  );\n                default:\n                  return (\n                    initializingHandler\n                      ? ((initializingHandler.errored = !0),\n                        (initializingHandler.value = null),\n                        (initializingHandler.reason = value.reason))\n                      : (initializingHandler = {\n                          parent: null,\n                          chunk: null,\n                          value: null,\n                          reason: value.reason,\n                          deps: 0,\n                          errored: !0\n                        }),\n                    null\n                  );\n              }\n            }\n            value = value[path[i]];\n          }\n          for (\n            ;\n            \"object\" === typeof value &&\n            null !== value &&\n            value.$$typeof === REACT_LAZY_TYPE;\n\n          ) {\n            path = value._payload;\n            switch (path.status) {\n              case \"resolved_model\":\n                initializeModelChunk(path);\n                break;\n              case \"resolved_module\":\n                initializeModuleChunk(path);\n            }\n            switch (path.status) {\n              case \"fulfilled\":\n                value = path.value;\n                continue;\n            }\n            break;\n          }\n          response = map(response, value, parentObject, key);\n          (parentObject[0] !== REACT_ELEMENT_TYPE ||\n            (\"4\" !== key && \"5\" !== key)) &&\n            transferReferencedDebugInfo(initializingChunk, reference);\n          return response;\n        case \"pending\":\n        case \"blocked\":\n          return waitForReference(\n            reference,\n            parentObject,\n            key,\n            response,\n            map,\n            path,\n            !1\n          );\n        case \"halted\":\n          return (\n            initializingHandler\n              ? ((parentObject = initializingHandler), parentObject.deps++)\n              : (initializingHandler = {\n                  parent: null,\n                  chunk: null,\n                  value: null,\n                  reason: null,\n                  deps: 1,\n                  errored: !1\n                }),\n            null\n          );\n        default:\n          return (\n            initializingHandler\n              ? ((initializingHandler.errored = !0),\n                (initializingHandler.value = null),\n                (initializingHandler.reason = reference.reason))\n              : (initializingHandler = {\n                  parent: null,\n                  chunk: null,\n                  value: null,\n                  reason: reference.reason,\n                  deps: 0,\n                  errored: !0\n                }),\n            null\n          );\n      }\n    }\n    function createMap(response, model) {\n      return new Map(model);\n    }\n    function createSet(response, model) {\n      return new Set(model);\n    }\n    function createBlob(response, model) {\n      return new Blob(model.slice(1), { type: model[0] });\n    }\n    function createFormData(response, model) {\n      response = new FormData();\n      for (var i = 0; i < model.length; i++)\n        response.append(model[i][0], model[i][1]);\n      return response;\n    }\n    function applyConstructor(response, model, parentObject) {\n      Object.setPrototypeOf(parentObject, model.prototype);\n    }\n    function defineLazyGetter(response, chunk, parentObject, key) {\n      \"__proto__\" !== key &&\n        Object.defineProperty(parentObject, key, {\n          get: function () {\n            \"resolved_model\" === chunk.status && initializeModelChunk(chunk);\n            switch (chunk.status) {\n              case \"fulfilled\":\n                return chunk.value;\n              case \"rejected\":\n                throw chunk.reason;\n            }\n            return \"This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.\";\n          },\n          enumerable: !0,\n          configurable: !1\n        });\n      return null;\n    }\n    function extractIterator(response, model) {\n      return model[Symbol.iterator]();\n    }\n    function createModel(response, model) {\n      return model;\n    }\n    function getInferredFunctionApproximate(code) {\n      code = code.startsWith(\"Object.defineProperty(\")\n        ? code.slice(22)\n        : code.startsWith(\"(\")\n          ? code.slice(1)\n          : code;\n      if (code.startsWith(\"async function\")) {\n        var idx = code.indexOf(\"(\", 14);\n        if (-1 !== idx)\n          return (\n            (code = code.slice(14, idx).trim()),\n            (0, eval)(\"({\" + JSON.stringify(code) + \":async function(){}})\")[\n              code\n            ]\n          );\n      } else if (code.startsWith(\"function\")) {\n        if (((idx = code.indexOf(\"(\", 8)), -1 !== idx))\n          return (\n            (code = code.slice(8, idx).trim()),\n            (0, eval)(\"({\" + JSON.stringify(code) + \":function(){}})\")[code]\n          );\n      } else if (\n        code.startsWith(\"class\") &&\n        ((idx = code.indexOf(\"{\", 5)), -1 !== idx)\n      )\n        return (\n          (code = code.slice(5, idx).trim()),\n          (0, eval)(\"({\" + JSON.stringify(code) + \":class{}})\")[code]\n        );\n      return function () {};\n    }\n    function parseModelString(response, parentObject, key, value) {\n      if (\"$\" === value[0]) {\n        if (\"$\" === value)\n          return (\n            null !== initializingHandler &&\n              \"0\" === key &&\n              (initializingHandler = {\n                parent: initializingHandler,\n                chunk: null,\n                value: null,\n                reason: null,\n                deps: 0,\n                errored: !1\n              }),\n            REACT_ELEMENT_TYPE\n          );\n        switch (value[1]) {\n          case \"$\":\n            return value.slice(1);\n          case \"L\":\n            return (\n              (parentObject = parseInt(value.slice(2), 16)),\n              (response = getChunk(response, parentObject)),\n              null !== initializingChunk &&\n                isArrayImpl(initializingChunk._children) &&\n                initializingChunk._children.push(response),\n              createLazyChunkWrapper(response, 0)\n            );\n          case \"@\":\n            return (\n              (parentObject = parseInt(value.slice(2), 16)),\n              (response = getChunk(response, parentObject)),\n              null !== initializingChunk &&\n                isArrayImpl(initializingChunk._children) &&\n                initializingChunk._children.push(response),\n              response\n            );\n          case \"S\":\n            return Symbol.for(value.slice(2));\n          case \"h\":\n            var ref = value.slice(2);\n            return getOutlinedModel(\n              response,\n              ref,\n              parentObject,\n              key,\n              loadServerReference\n            );\n          case \"T\":\n            parentObject = \"$\" + value.slice(2);\n            response = response._tempRefs;\n            if (null == response)\n              throw Error(\n                \"Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.\"\n              );\n            return response.get(parentObject);\n          case \"Q\":\n            return (\n              (ref = value.slice(2)),\n              getOutlinedModel(response, ref, parentObject, key, createMap)\n            );\n          case \"W\":\n            return (\n              (ref = value.slice(2)),\n              getOutlinedModel(response, ref, parentObject, key, createSet)\n            );\n          case \"B\":\n            return (\n              (ref = value.slice(2)),\n              getOutlinedModel(response, ref, parentObject, key, createBlob)\n            );\n          case \"K\":\n            return (\n              (ref = value.slice(2)),\n              getOutlinedModel(response, ref, parentObject, key, createFormData)\n            );\n          case \"Z\":\n            return (\n              (ref = value.slice(2)),\n              getOutlinedModel(\n                response,\n                ref,\n                parentObject,\n                key,\n                resolveErrorDev\n              )\n            );\n          case \"i\":\n            return (\n              (ref = value.slice(2)),\n              getOutlinedModel(\n                response,\n                ref,\n                parentObject,\n                key,\n                extractIterator\n              )\n            );\n          case \"I\":\n            return Infinity;\n          case \"-\":\n            return \"$-0\" === value ? -0 : -Infinity;\n          case \"N\":\n            return NaN;\n          case \"u\":\n            return;\n          case \"D\":\n            return new Date(Date.parse(value.slice(2)));\n          case \"n\":\n            return BigInt(value.slice(2));\n          case \"P\":\n            return (\n              (ref = value.slice(2)),\n              getOutlinedModel(\n                response,\n                ref,\n                parentObject,\n                key,\n                applyConstructor\n              )\n            );\n          case \"E\":\n            response = value.slice(2);\n            try {\n              if (!mightHaveStaticConstructor.test(response))\n                return (0, eval)(response);\n            } catch (x) {}\n            try {\n              if (\n                ((ref = getInferredFunctionApproximate(response)),\n                response.startsWith(\"Object.defineProperty(\"))\n              ) {\n                var idx = response.lastIndexOf(',\"name\",{value:\"');\n                if (-1 !== idx) {\n                  var name = JSON.parse(\n                    response.slice(idx + 16 - 1, response.length - 2)\n                  );\n                  Object.defineProperty(ref, \"name\", { value: name });\n                }\n              }\n            } catch (_) {\n              ref = function () {};\n            }\n            return ref;\n          case \"Y\":\n            if (\n              2 < value.length &&\n              (ref = response._debugChannel && response._debugChannel.callback)\n            ) {\n              if (\"@\" === value[2])\n                return (\n                  (parentObject = value.slice(3)),\n                  (key = parseInt(parentObject, 16)),\n                  response._chunks.has(key) || ref(\"P:\" + parentObject),\n                  getChunk(response, key)\n                );\n              value = value.slice(2);\n              idx = parseInt(value, 16);\n              response._chunks.has(idx) || ref(\"Q:\" + value);\n              ref = getChunk(response, idx);\n              return \"fulfilled\" === ref.status\n                ? ref.value\n                : defineLazyGetter(response, ref, parentObject, key);\n            }\n            \"__proto__\" !== key &&\n              Object.defineProperty(parentObject, key, {\n                get: function () {\n                  return \"This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.\";\n                },\n                enumerable: !0,\n                configurable: !1\n              });\n            return null;\n          default:\n            return (\n              (ref = value.slice(1)),\n              getOutlinedModel(response, ref, parentObject, key, createModel)\n            );\n        }\n      }\n      return value;\n    }\n    function missingCall() {\n      throw Error(\n        'Trying to call a function from \"use server\" but the callServer option was not implemented in your router runtime.'\n      );\n    }\n    function markIOStarted() {\n      this._debugIOStarted = !0;\n    }\n    function ResponseInstance(\n      bundlerConfig,\n      serverReferenceConfig,\n      moduleLoading,\n      callServer,\n      encodeFormAction,\n      nonce,\n      temporaryReferences,\n      findSourceMapURL,\n      replayConsole,\n      environmentName,\n      debugStartTime,\n      debugEndTime,\n      debugChannel\n    ) {\n      var chunks = new Map();\n      this._bundlerConfig = bundlerConfig;\n      this._serverReferenceConfig = serverReferenceConfig;\n      this._moduleLoading = moduleLoading;\n      this._callServer = void 0 !== callServer ? callServer : missingCall;\n      this._encodeFormAction = encodeFormAction;\n      this._nonce = nonce;\n      this._chunks = chunks;\n      this._stringDecoder = new TextDecoder();\n      this._fromJSON = null;\n      this._closed = !1;\n      this._closedReason = null;\n      this._tempRefs = temporaryReferences;\n      this._timeOrigin = 0;\n      this._pendingInitialRender = null;\n      this._pendingChunks = 0;\n      this._weakResponse = { weak: new WeakRef(this), response: this };\n      this._debugRootOwner = bundlerConfig =\n        void 0 === ReactSharedInteralsServer ||\n        null === ReactSharedInteralsServer.A\n          ? null\n          : ReactSharedInteralsServer.A.getOwner();\n      this._debugRootStack =\n        null !== bundlerConfig ? Error(\"react-stack-top-frame\") : null;\n      environmentName = void 0 === environmentName ? \"Server\" : environmentName;\n      supportsCreateTask &&\n        (this._debugRootTask = console.createTask(\n          '\"use ' + environmentName.toLowerCase() + '\"'\n        ));\n      this._debugStartTime =\n        null == debugStartTime ? performance.now() : debugStartTime;\n      this._debugIOStarted = !1;\n      setTimeout(markIOStarted.bind(this), 0);\n      this._debugEndTime = null == debugEndTime ? null : debugEndTime;\n      this._debugFindSourceMapURL = findSourceMapURL;\n      this._debugChannel = debugChannel;\n      this._blockedConsole = null;\n      this._replayConsole = replayConsole;\n      this._rootEnvironmentName = environmentName;\n      debugChannel &&\n        (null === debugChannelRegistry\n          ? (closeDebugChannel(debugChannel), (this._debugChannel = void 0))\n          : debugChannelRegistry.register(this, debugChannel, this));\n      replayConsole && markAllTracksInOrder();\n      this._fromJSON = createFromJSONCallback(this);\n    }\n    function createStreamState(weakResponse, streamDebugValue) {\n      var streamState = {\n        _rowState: 0,\n        _rowID: 0,\n        _rowTag: 0,\n        _rowLength: 0,\n        _buffer: []\n      };\n      weakResponse = unwrapWeakResponse(weakResponse);\n      var debugValuePromise = Promise.resolve(streamDebugValue);\n      debugValuePromise.status = \"fulfilled\";\n      debugValuePromise.value = streamDebugValue;\n      streamState._debugInfo = {\n        name: \"rsc stream\",\n        start: weakResponse._debugStartTime,\n        end: weakResponse._debugStartTime,\n        byteSize: 0,\n        value: debugValuePromise,\n        owner: weakResponse._debugRootOwner,\n        debugStack: weakResponse._debugRootStack,\n        debugTask: weakResponse._debugRootTask\n      };\n      streamState._debugTargetChunkSize = MIN_CHUNK_SIZE;\n      return streamState;\n    }\n    function incrementChunkDebugInfo(streamState, chunkLength) {\n      var debugInfo = streamState._debugInfo,\n        endTime = performance.now(),\n        previousEndTime = debugInfo.end;\n      chunkLength = debugInfo.byteSize + chunkLength;\n      chunkLength > streamState._debugTargetChunkSize ||\n      endTime > previousEndTime + 10\n        ? ((streamState._debugInfo = {\n            name: debugInfo.name,\n            start: debugInfo.start,\n            end: endTime,\n            byteSize: chunkLength,\n            value: debugInfo.value,\n            owner: debugInfo.owner,\n            debugStack: debugInfo.debugStack,\n            debugTask: debugInfo.debugTask\n          }),\n          (streamState._debugTargetChunkSize = chunkLength + MIN_CHUNK_SIZE))\n        : ((debugInfo.end = endTime), (debugInfo.byteSize = chunkLength));\n    }\n    function addAsyncInfo(chunk, asyncInfo) {\n      var value = resolveLazy(chunk.value);\n      \"object\" !== typeof value ||\n      null === value ||\n      (!isArrayImpl(value) &&\n        \"function\" !== typeof value[ASYNC_ITERATOR] &&\n        value.$$typeof !== REACT_ELEMENT_TYPE &&\n        value.$$typeof !== REACT_LAZY_TYPE)\n        ? chunk._debugInfo.push(asyncInfo)\n        : isArrayImpl(value._debugInfo)\n          ? value._debugInfo.push(asyncInfo)\n          : Object.defineProperty(value, \"_debugInfo\", {\n              configurable: !1,\n              enumerable: !1,\n              writable: !0,\n              value: [asyncInfo]\n            });\n    }\n    function resolveChunkDebugInfo(response, streamState, chunk) {\n      response._debugIOStarted &&\n        ((response = { awaited: streamState._debugInfo }),\n        \"pending\" === chunk.status || \"blocked\" === chunk.status\n          ? ((response = addAsyncInfo.bind(null, chunk, response)),\n            chunk.then(response, response))\n          : addAsyncInfo(chunk, response));\n    }\n    function resolveBuffer(response, id, buffer, streamState) {\n      var chunks = response._chunks,\n        chunk = chunks.get(id);\n      chunk && \"pending\" !== chunk.status\n        ? chunk.reason.enqueueValue(buffer)\n        : (chunk && releasePendingChunk(response, chunk),\n          (buffer = new ReactPromise(\"fulfilled\", buffer, null)),\n          resolveChunkDebugInfo(response, streamState, buffer),\n          chunks.set(id, buffer));\n    }\n    function resolveModule(response, id, model, streamState) {\n      var chunks = response._chunks,\n        chunk = chunks.get(id);\n      model = JSON.parse(model, response._fromJSON);\n      var clientReference = resolveClientReference(\n        response._bundlerConfig,\n        model\n      );\n      if ((model = preloadModule(clientReference))) {\n        if (chunk) {\n          releasePendingChunk(response, chunk);\n          var blockedChunk = chunk;\n          blockedChunk.status = \"blocked\";\n        } else\n          (blockedChunk = new ReactPromise(\"blocked\", null, null)),\n            chunks.set(id, blockedChunk);\n        resolveChunkDebugInfo(response, streamState, blockedChunk);\n        model.then(\n          function () {\n            return resolveModuleChunk(response, blockedChunk, clientReference);\n          },\n          function (error) {\n            return triggerErrorOnChunk(response, blockedChunk, error);\n          }\n        );\n      } else\n        chunk\n          ? (resolveChunkDebugInfo(response, streamState, chunk),\n            resolveModuleChunk(response, chunk, clientReference))\n          : ((chunk = new ReactPromise(\n              \"resolved_module\",\n              clientReference,\n              null\n            )),\n            resolveChunkDebugInfo(response, streamState, chunk),\n            chunks.set(id, chunk));\n    }\n    function resolveStream(response, id, stream, controller, streamState) {\n      var chunks = response._chunks,\n        chunk = chunks.get(id);\n      if (chunk) {\n        if (\n          (resolveChunkDebugInfo(response, streamState, chunk),\n          \"pending\" === chunk.status)\n        ) {\n          id = chunk.value;\n          if (null != chunk._debugChunk) {\n            streamState = initializingHandler;\n            chunks = initializingChunk;\n            initializingHandler = null;\n            chunk.status = \"blocked\";\n            chunk.value = null;\n            chunk.reason = null;\n            initializingChunk = chunk;\n            try {\n              if (\n                (initializeDebugChunk(response, chunk),\n                null !== initializingHandler &&\n                  !initializingHandler.errored &&\n                  0 < initializingHandler.deps)\n              ) {\n                initializingHandler.value = stream;\n                initializingHandler.reason = controller;\n                initializingHandler.chunk = chunk;\n                return;\n              }\n            } finally {\n              (initializingHandler = streamState), (initializingChunk = chunks);\n            }\n          }\n          chunk.status = \"fulfilled\";\n          chunk.value = stream;\n          chunk.reason = controller;\n          null !== id\n            ? wakeChunk(response, id, chunk.value, chunk)\n            : (filterDebugInfo(response, chunk),\n              moveDebugInfoFromChunkToInnerValue(chunk, stream));\n        }\n      } else\n        0 === response._pendingChunks++ &&\n          (response._weakResponse.response = response),\n          (stream = new ReactPromise(\"fulfilled\", stream, controller)),\n          resolveChunkDebugInfo(response, streamState, stream),\n          chunks.set(id, stream);\n    }\n    function startReadableStream(response, id, type, streamState) {\n      var controller = null,\n        closed = !1;\n      type = new ReadableStream({\n        type: type,\n        start: function (c) {\n          controller = c;\n        }\n      });\n      var previousBlockedChunk = null;\n      resolveStream(\n        response,\n        id,\n        type,\n        {\n          enqueueValue: function (value) {\n            null === previousBlockedChunk\n              ? controller.enqueue(value)\n              : previousBlockedChunk.then(function () {\n                  controller.enqueue(value);\n                });\n          },\n          enqueueModel: function (json) {\n            if (null === previousBlockedChunk) {\n              var chunk = createResolvedModelChunk(response, json);\n              initializeModelChunk(chunk);\n              \"fulfilled\" === chunk.status\n                ? controller.enqueue(chunk.value)\n                : (chunk.then(\n                    function (v) {\n                      return controller.enqueue(v);\n                    },\n                    function (e) {\n                      return controller.error(e);\n                    }\n                  ),\n                  (previousBlockedChunk = chunk));\n            } else {\n              chunk = previousBlockedChunk;\n              var _chunk3 = createPendingChunk(response);\n              _chunk3.then(\n                function (v) {\n                  return controller.enqueue(v);\n                },\n                function (e) {\n                  return controller.error(e);\n                }\n              );\n              previousBlockedChunk = _chunk3;\n              chunk.then(function () {\n                previousBlockedChunk === _chunk3 &&\n                  (previousBlockedChunk = null);\n                resolveModelChunk(response, _chunk3, json);\n              });\n            }\n          },\n          close: function () {\n            if (!closed)\n              if (((closed = !0), null === previousBlockedChunk))\n                controller.close();\n              else {\n                var blockedChunk = previousBlockedChunk;\n                previousBlockedChunk = null;\n                blockedChunk.then(function () {\n                  return controller.close();\n                });\n              }\n          },\n          error: function (error) {\n            if (!closed)\n              if (((closed = !0), null === previousBlockedChunk))\n                controller.error(error);\n              else {\n                var blockedChunk = previousBlockedChunk;\n                previousBlockedChunk = null;\n                blockedChunk.then(function () {\n                  return controller.error(error);\n                });\n              }\n          }\n        },\n        streamState\n      );\n    }\n    function asyncIterator() {\n      return this;\n    }\n    function createIterator(next) {\n      next = { next: next };\n      next[ASYNC_ITERATOR] = asyncIterator;\n      return next;\n    }\n    function startAsyncIterable(response, id, iterator, streamState) {\n      var buffer = [],\n        closed = !1,\n        nextWriteIndex = 0,\n        iterable = {};\n      iterable[ASYNC_ITERATOR] = function () {\n        var nextReadIndex = 0;\n        return createIterator(function (arg) {\n          if (void 0 !== arg)\n            throw Error(\n              \"Values cannot be passed to next() of AsyncIterables passed to Client Components.\"\n            );\n          if (nextReadIndex === buffer.length) {\n            if (closed)\n              return new ReactPromise(\n                \"fulfilled\",\n                { done: !0, value: void 0 },\n                null\n              );\n            buffer[nextReadIndex] = createPendingChunk(response);\n          }\n          return buffer[nextReadIndex++];\n        });\n      };\n      resolveStream(\n        response,\n        id,\n        iterator ? iterable[ASYNC_ITERATOR]() : iterable,\n        {\n          enqueueValue: function (value) {\n            if (nextWriteIndex === buffer.length)\n              buffer[nextWriteIndex] = new ReactPromise(\n                \"fulfilled\",\n                { done: !1, value: value },\n                null\n              );\n            else {\n              var chunk = buffer[nextWriteIndex],\n                resolveListeners = chunk.value,\n                rejectListeners = chunk.reason;\n              chunk.status = \"fulfilled\";\n              chunk.value = { done: !1, value: value };\n              chunk.reason = null;\n              null !== resolveListeners &&\n                wakeChunkIfInitialized(\n                  response,\n                  chunk,\n                  resolveListeners,\n                  rejectListeners\n                );\n            }\n            nextWriteIndex++;\n          },\n          enqueueModel: function (value) {\n            nextWriteIndex === buffer.length\n              ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(\n                  response,\n                  value,\n                  !1\n                ))\n              : resolveIteratorResultChunk(\n                  response,\n                  buffer[nextWriteIndex],\n                  value,\n                  !1\n                );\n            nextWriteIndex++;\n          },\n          close: function (value) {\n            if (!closed)\n              for (\n                closed = !0,\n                  nextWriteIndex === buffer.length\n                    ? (buffer[nextWriteIndex] =\n                        createResolvedIteratorResultChunk(response, value, !0))\n                    : resolveIteratorResultChunk(\n                        response,\n                        buffer[nextWriteIndex],\n                        value,\n                        !0\n                      ),\n                  nextWriteIndex++;\n                nextWriteIndex < buffer.length;\n\n              )\n                resolveIteratorResultChunk(\n                  response,\n                  buffer[nextWriteIndex++],\n                  '\"$undefined\"',\n                  !0\n                );\n          },\n          error: function (error) {\n            if (!closed)\n              for (\n                closed = !0,\n                  nextWriteIndex === buffer.length &&\n                    (buffer[nextWriteIndex] = createPendingChunk(response));\n                nextWriteIndex < buffer.length;\n\n              )\n                triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n          }\n        },\n        streamState\n      );\n    }\n    function resolveErrorDev(response, errorInfo) {\n      var name = errorInfo.name,\n        env = errorInfo.env;\n      var error = buildFakeCallStack(\n        response,\n        errorInfo.stack,\n        env,\n        !1,\n        Error.bind(\n          null,\n          errorInfo.message ||\n            \"An error occurred in the Server Components render but no message was provided\"\n        )\n      );\n      var ownerTask = null;\n      null != errorInfo.owner &&\n        ((errorInfo = errorInfo.owner.slice(1)),\n        (errorInfo = getOutlinedModel(\n          response,\n          errorInfo,\n          {},\n          \"\",\n          createModel\n        )),\n        null !== errorInfo &&\n          (ownerTask = initializeFakeTask(response, errorInfo)));\n      null === ownerTask\n        ? ((response = getRootTask(response, env)),\n          (error = null != response ? response.run(error) : error()))\n        : (error = ownerTask.run(error));\n      error.name = name;\n      error.environmentName = env;\n      return error;\n    }\n    function createFakeFunction(\n      name,\n      filename,\n      sourceMap,\n      line,\n      col,\n      enclosingLine,\n      enclosingCol,\n      environmentName\n    ) {\n      name || (name = \"<anonymous>\");\n      var encodedName = JSON.stringify(name);\n      1 > enclosingLine ? (enclosingLine = 0) : enclosingLine--;\n      1 > enclosingCol ? (enclosingCol = 0) : enclosingCol--;\n      1 > line ? (line = 0) : line--;\n      1 > col ? (col = 0) : col--;\n      if (\n        line < enclosingLine ||\n        (line === enclosingLine && col < enclosingCol)\n      )\n        enclosingCol = enclosingLine = 0;\n      1 > line\n        ? ((line = encodedName.length + 3),\n          (enclosingCol -= line),\n          0 > enclosingCol && (enclosingCol = 0),\n          (col = col - enclosingCol - line - 3),\n          0 > col && (col = 0),\n          (encodedName =\n            \"({\" +\n            encodedName +\n            \":\" +\n            \" \".repeat(enclosingCol) +\n            \"_=>\" +\n            \" \".repeat(col) +\n            \"_()})\"))\n        : 1 > enclosingLine\n          ? ((enclosingCol -= encodedName.length + 3),\n            0 > enclosingCol && (enclosingCol = 0),\n            (encodedName =\n              \"({\" +\n              encodedName +\n              \":\" +\n              \" \".repeat(enclosingCol) +\n              \"_=>\" +\n              \"\\n\".repeat(line - enclosingLine) +\n              \" \".repeat(col) +\n              \"_()})\"))\n          : enclosingLine === line\n            ? ((col = col - enclosingCol - 3),\n              0 > col && (col = 0),\n              (encodedName =\n                \"\\n\".repeat(enclosingLine - 1) +\n                \"({\" +\n                encodedName +\n                \":\\n\" +\n                \" \".repeat(enclosingCol) +\n                \"_=>\" +\n                \" \".repeat(col) +\n                \"_()})\"))\n            : (encodedName =\n                \"\\n\".repeat(enclosingLine - 1) +\n                \"({\" +\n                encodedName +\n                \":\\n\" +\n                \" \".repeat(enclosingCol) +\n                \"_=>\" +\n                \"\\n\".repeat(line - enclosingLine) +\n                \" \".repeat(col) +\n                \"_()})\");\n      encodedName =\n        1 > enclosingLine\n          ? encodedName +\n            \"\\n/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */\"\n          : \"/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */\" +\n            encodedName;\n      filename.startsWith(\"/\") && (filename = \"file://\" + filename);\n      sourceMap\n        ? ((encodedName +=\n            \"\\n//# sourceURL=about://React/\" +\n            encodeURIComponent(environmentName) +\n            \"/\" +\n            encodeURI(filename) +\n            \"?\" +\n            fakeFunctionIdx++),\n          (encodedName += \"\\n//# sourceMappingURL=\" + sourceMap))\n        : (encodedName = filename\n            ? encodedName + (\"\\n//# sourceURL=\" + encodeURI(filename))\n            : encodedName + \"\\n//# sourceURL=<anonymous>\");\n      try {\n        var fn = (0, eval)(encodedName)[name];\n      } catch (x) {\n        fn = function (_) {\n          return _();\n        };\n      }\n      return fn;\n    }\n    function buildFakeCallStack(\n      response,\n      stack,\n      environmentName,\n      useEnclosingLine,\n      innerCall\n    ) {\n      for (var i = 0; i < stack.length; i++) {\n        var frame = stack[i],\n          frameKey =\n            frame.join(\"-\") +\n            \"-\" +\n            environmentName +\n            (useEnclosingLine ? \"-e\" : \"-n\"),\n          fn = fakeFunctionCache.get(frameKey);\n        if (void 0 === fn) {\n          fn = frame[0];\n          var filename = frame[1],\n            line = frame[2],\n            col = frame[3],\n            enclosingLine = frame[4];\n          frame = frame[5];\n          var findSourceMapURL = response._debugFindSourceMapURL;\n          findSourceMapURL = findSourceMapURL\n            ? findSourceMapURL(filename, environmentName)\n            : null;\n          fn = createFakeFunction(\n            fn,\n            filename,\n            findSourceMapURL,\n            line,\n            col,\n            useEnclosingLine ? line : enclosingLine,\n            useEnclosingLine ? col : frame,\n            environmentName\n          );\n          fakeFunctionCache.set(frameKey, fn);\n        }\n        innerCall = fn.bind(null, innerCall);\n      }\n      return innerCall;\n    }\n    function getRootTask(response, childEnvironmentName) {\n      var rootTask = response._debugRootTask;\n      return rootTask\n        ? response._rootEnvironmentName !== childEnvironmentName\n          ? ((response = console.createTask.bind(\n              console,\n              '\"use ' + childEnvironmentName.toLowerCase() + '\"'\n            )),\n            rootTask.run(response))\n          : rootTask\n        : null;\n    }\n    function initializeFakeTask(response, debugInfo) {\n      if (!supportsCreateTask || null == debugInfo.stack) return null;\n      var cachedEntry = debugInfo.debugTask;\n      if (void 0 !== cachedEntry) return cachedEntry;\n      var useEnclosingLine = void 0 === debugInfo.key,\n        stack = debugInfo.stack,\n        env =\n          null == debugInfo.env ? response._rootEnvironmentName : debugInfo.env;\n      cachedEntry =\n        null == debugInfo.owner || null == debugInfo.owner.env\n          ? response._rootEnvironmentName\n          : debugInfo.owner.env;\n      var ownerTask =\n        null == debugInfo.owner\n          ? null\n          : initializeFakeTask(response, debugInfo.owner);\n      env =\n        env !== cachedEntry\n          ? '\"use ' + env.toLowerCase() + '\"'\n          : void 0 !== debugInfo.key\n            ? \"<\" + (debugInfo.name || \"...\") + \">\"\n            : void 0 !== debugInfo.name\n              ? debugInfo.name || \"unknown\"\n              : \"await \" + (debugInfo.awaited.name || \"unknown\");\n      env = console.createTask.bind(console, env);\n      useEnclosingLine = buildFakeCallStack(\n        response,\n        stack,\n        cachedEntry,\n        useEnclosingLine,\n        env\n      );\n      null === ownerTask\n        ? ((response = getRootTask(response, cachedEntry)),\n          (response =\n            null != response\n              ? response.run(useEnclosingLine)\n              : useEnclosingLine()))\n        : (response = ownerTask.run(useEnclosingLine));\n      return (debugInfo.debugTask = response);\n    }\n    function fakeJSXCallSite() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function initializeFakeStack(response, debugInfo) {\n      if (void 0 === debugInfo.debugStack) {\n        null != debugInfo.stack &&\n          (debugInfo.debugStack = createFakeJSXCallStackInDEV(\n            response,\n            debugInfo.stack,\n            null == debugInfo.env ? \"\" : debugInfo.env\n          ));\n        var owner = debugInfo.owner;\n        null != owner &&\n          (initializeFakeStack(response, owner),\n          void 0 === owner.debugLocation &&\n            null != debugInfo.debugStack &&\n            (owner.debugLocation = debugInfo.debugStack));\n      }\n    }\n    function initializeDebugInfo(response, debugInfo) {\n      void 0 !== debugInfo.stack && initializeFakeTask(response, debugInfo);\n      if (null == debugInfo.owner && null != response._debugRootOwner) {\n        var _componentInfoOrAsyncInfo = debugInfo;\n        _componentInfoOrAsyncInfo.owner = response._debugRootOwner;\n        _componentInfoOrAsyncInfo.stack = null;\n        _componentInfoOrAsyncInfo.debugStack = response._debugRootStack;\n        _componentInfoOrAsyncInfo.debugTask = response._debugRootTask;\n      } else\n        void 0 !== debugInfo.stack && initializeFakeStack(response, debugInfo);\n      \"number\" === typeof debugInfo.time &&\n        (debugInfo = { time: debugInfo.time + response._timeOrigin });\n      return debugInfo;\n    }\n    function getCurrentStackInDEV() {\n      var owner = currentOwnerInDEV;\n      if (null === owner) return \"\";\n      try {\n        var info = \"\";\n        if (owner.owner || \"string\" !== typeof owner.name) {\n          for (; owner; ) {\n            var ownerStack = owner.debugStack;\n            if (null != ownerStack) {\n              if ((owner = owner.owner)) {\n                var JSCompiler_temp_const = info;\n                var error = ownerStack,\n                  prevPrepareStackTrace = Error.prepareStackTrace;\n                Error.prepareStackTrace = void 0;\n                var stack = error.stack;\n                Error.prepareStackTrace = prevPrepareStackTrace;\n                stack.startsWith(\"Error: react-stack-top-frame\\n\") &&\n                  (stack = stack.slice(29));\n                var idx = stack.indexOf(\"\\n\");\n                -1 !== idx && (stack = stack.slice(idx + 1));\n                idx = stack.indexOf(\"react_stack_bottom_frame\");\n                -1 !== idx && (idx = stack.lastIndexOf(\"\\n\", idx));\n                var JSCompiler_inline_result =\n                  -1 !== idx ? (stack = stack.slice(0, idx)) : \"\";\n                info =\n                  JSCompiler_temp_const + (\"\\n\" + JSCompiler_inline_result);\n              }\n            } else break;\n          }\n          var JSCompiler_inline_result$jscomp$0 = info;\n        } else {\n          JSCompiler_temp_const = owner.name;\n          if (void 0 === prefix)\n            try {\n              throw Error();\n            } catch (x) {\n              (prefix =\n                ((error = x.stack.trim().match(/\\n( *(at )?)/)) && error[1]) ||\n                \"\"),\n                (suffix =\n                  -1 < x.stack.indexOf(\"\\n    at\")\n                    ? \" (<anonymous>)\"\n                    : -1 < x.stack.indexOf(\"@\")\n                      ? \"@unknown:0:0\"\n                      : \"\");\n            }\n          JSCompiler_inline_result$jscomp$0 =\n            \"\\n\" + prefix + JSCompiler_temp_const + suffix;\n        }\n      } catch (x) {\n        JSCompiler_inline_result$jscomp$0 =\n          \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n      }\n      return JSCompiler_inline_result$jscomp$0;\n    }\n    function resolveConsoleEntry(response, json) {\n      if (response._replayConsole) {\n        var blockedChunk = response._blockedConsole;\n        if (null == blockedChunk)\n          (blockedChunk = createResolvedModelChunk(response, json)),\n            initializeModelChunk(blockedChunk),\n            \"fulfilled\" === blockedChunk.status\n              ? replayConsoleWithCallStackInDEV(response, blockedChunk.value)\n              : (blockedChunk.then(\n                  function (v) {\n                    return replayConsoleWithCallStackInDEV(response, v);\n                  },\n                  function () {}\n                ),\n                (response._blockedConsole = blockedChunk));\n        else {\n          var _chunk4 = createPendingChunk(response);\n          _chunk4.then(\n            function (v) {\n              return replayConsoleWithCallStackInDEV(response, v);\n            },\n            function () {}\n          );\n          response._blockedConsole = _chunk4;\n          var unblock = function () {\n            response._blockedConsole === _chunk4 &&\n              (response._blockedConsole = null);\n            resolveModelChunk(response, _chunk4, json);\n          };\n          blockedChunk.then(unblock, unblock);\n        }\n      }\n    }\n    function initializeIOInfo(response, ioInfo) {\n      void 0 !== ioInfo.stack &&\n        (initializeFakeTask(response, ioInfo),\n        initializeFakeStack(response, ioInfo));\n      ioInfo.start += response._timeOrigin;\n      ioInfo.end += response._timeOrigin;\n      if (response._replayConsole) {\n        response = response._rootEnvironmentName;\n        var promise = ioInfo.value;\n        if (promise)\n          switch (promise.status) {\n            case \"fulfilled\":\n              logIOInfo(ioInfo, response, promise.value);\n              break;\n            case \"rejected\":\n              logIOInfoErrored(ioInfo, response, promise.reason);\n              break;\n            default:\n              promise.then(\n                logIOInfo.bind(null, ioInfo, response),\n                logIOInfoErrored.bind(null, ioInfo, response)\n              );\n          }\n        else logIOInfo(ioInfo, response, void 0);\n      }\n    }\n    function resolveIOInfo(response, id, model) {\n      var chunks = response._chunks,\n        chunk = chunks.get(id);\n      chunk\n        ? (resolveModelChunk(response, chunk, model),\n          \"resolved_model\" === chunk.status && initializeModelChunk(chunk))\n        : ((chunk = createResolvedModelChunk(response, model)),\n          chunks.set(id, chunk),\n          initializeModelChunk(chunk));\n      \"fulfilled\" === chunk.status\n        ? initializeIOInfo(response, chunk.value)\n        : chunk.then(\n            function (v) {\n              initializeIOInfo(response, v);\n            },\n            function () {}\n          );\n    }\n    function mergeBuffer(buffer, lastChunk) {\n      for (\n        var l = buffer.length, byteLength = lastChunk.length, i = 0;\n        i < l;\n        i++\n      )\n        byteLength += buffer[i].byteLength;\n      byteLength = new Uint8Array(byteLength);\n      for (var _i3 = (i = 0); _i3 < l; _i3++) {\n        var chunk = buffer[_i3];\n        byteLength.set(chunk, i);\n        i += chunk.byteLength;\n      }\n      byteLength.set(lastChunk, i);\n      return byteLength;\n    }\n    function resolveTypedArray(\n      response,\n      id,\n      buffer,\n      lastChunk,\n      constructor,\n      bytesPerElement,\n      streamState\n    ) {\n      buffer =\n        0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement\n          ? lastChunk\n          : mergeBuffer(buffer, lastChunk);\n      constructor = new constructor(\n        buffer.buffer,\n        buffer.byteOffset,\n        buffer.byteLength / bytesPerElement\n      );\n      resolveBuffer(response, id, constructor, streamState);\n    }\n    function flushComponentPerformance(\n      response$jscomp$0,\n      root,\n      trackIdx$jscomp$6,\n      trackTime,\n      parentEndTime\n    ) {\n      if (!isArrayImpl(root._children)) {\n        var previousResult = root._children,\n          previousEndTime = previousResult.endTime;\n        if (\n          -Infinity < parentEndTime &&\n          parentEndTime < previousEndTime &&\n          null !== previousResult.component\n        ) {\n          var componentInfo = previousResult.component,\n            trackIdx = trackIdx$jscomp$6,\n            startTime = parentEndTime;\n          if (supportsUserTiming && 0 <= previousEndTime && 10 > trackIdx) {\n            var color =\n                componentInfo.env === response$jscomp$0._rootEnvironmentName\n                  ? \"primary-light\"\n                  : \"secondary-light\",\n              entryName = componentInfo.name + \" [deduped]\",\n              debugTask = componentInfo.debugTask;\n            debugTask\n              ? debugTask.run(\n                  console.timeStamp.bind(\n                    console,\n                    entryName,\n                    0 > startTime ? 0 : startTime,\n                    previousEndTime,\n                    trackNames[trackIdx],\n                    \"Server Components \\u269b\",\n                    color\n                  )\n                )\n              : console.timeStamp(\n                  entryName,\n                  0 > startTime ? 0 : startTime,\n                  previousEndTime,\n                  trackNames[trackIdx],\n                  \"Server Components \\u269b\",\n                  color\n                );\n          }\n        }\n        previousResult.track = trackIdx$jscomp$6;\n        return previousResult;\n      }\n      var children = root._children;\n      var debugInfo = root._debugInfo;\n      if (0 === debugInfo.length && \"fulfilled\" === root.status) {\n        var resolvedValue = resolveLazy(root.value);\n        \"object\" === typeof resolvedValue &&\n          null !== resolvedValue &&\n          (isArrayImpl(resolvedValue) ||\n            \"function\" === typeof resolvedValue[ASYNC_ITERATOR] ||\n            resolvedValue.$$typeof === REACT_ELEMENT_TYPE ||\n            resolvedValue.$$typeof === REACT_LAZY_TYPE) &&\n          isArrayImpl(resolvedValue._debugInfo) &&\n          (debugInfo = resolvedValue._debugInfo);\n      }\n      if (debugInfo) {\n        for (var startTime$jscomp$0 = 0, i = 0; i < debugInfo.length; i++) {\n          var info = debugInfo[i];\n          \"number\" === typeof info.time && (startTime$jscomp$0 = info.time);\n          if (\"string\" === typeof info.name) {\n            startTime$jscomp$0 < trackTime && trackIdx$jscomp$6++;\n            trackTime = startTime$jscomp$0;\n            break;\n          }\n        }\n        for (var _i4 = debugInfo.length - 1; 0 <= _i4; _i4--) {\n          var _info = debugInfo[_i4];\n          if (\"number\" === typeof _info.time && _info.time > parentEndTime) {\n            parentEndTime = _info.time;\n            break;\n          }\n        }\n      }\n      var result = {\n        track: trackIdx$jscomp$6,\n        endTime: -Infinity,\n        component: null\n      };\n      root._children = result;\n      for (\n        var childrenEndTime = -Infinity,\n          childTrackIdx = trackIdx$jscomp$6,\n          childTrackTime = trackTime,\n          _i5 = 0;\n        _i5 < children.length;\n        _i5++\n      ) {\n        var childResult = flushComponentPerformance(\n          response$jscomp$0,\n          children[_i5],\n          childTrackIdx,\n          childTrackTime,\n          parentEndTime\n        );\n        null !== childResult.component &&\n          (result.component = childResult.component);\n        childTrackIdx = childResult.track;\n        var childEndTime = childResult.endTime;\n        childEndTime > childTrackTime && (childTrackTime = childEndTime);\n        childEndTime > childrenEndTime && (childrenEndTime = childEndTime);\n      }\n      if (debugInfo)\n        for (\n          var componentEndTime = 0,\n            isLastComponent = !0,\n            endTime = -1,\n            endTimeIdx = -1,\n            _i6 = debugInfo.length - 1;\n          0 <= _i6;\n          _i6--\n        ) {\n          var _info2 = debugInfo[_i6];\n          if (\"number\" === typeof _info2.time) {\n            0 === componentEndTime && (componentEndTime = _info2.time);\n            var time = _info2.time;\n            if (-1 < endTimeIdx)\n              for (var j = endTimeIdx - 1; j > _i6; j--) {\n                var candidateInfo = debugInfo[j];\n                if (\"string\" === typeof candidateInfo.name) {\n                  componentEndTime > childrenEndTime &&\n                    (childrenEndTime = componentEndTime);\n                  var componentInfo$jscomp$0 = candidateInfo,\n                    response = response$jscomp$0,\n                    componentInfo$jscomp$1 = componentInfo$jscomp$0,\n                    trackIdx$jscomp$0 = trackIdx$jscomp$6,\n                    startTime$jscomp$1 = time,\n                    componentEndTime$jscomp$0 = componentEndTime,\n                    childrenEndTime$jscomp$0 = childrenEndTime;\n                  if (\n                    isLastComponent &&\n                    \"rejected\" === root.status &&\n                    root.reason !== response._closedReason\n                  ) {\n                    var componentInfo$jscomp$2 = componentInfo$jscomp$1,\n                      trackIdx$jscomp$1 = trackIdx$jscomp$0,\n                      startTime$jscomp$2 = startTime$jscomp$1,\n                      childrenEndTime$jscomp$1 = childrenEndTime$jscomp$0,\n                      error = root.reason;\n                    if (supportsUserTiming) {\n                      var env = componentInfo$jscomp$2.env,\n                        name = componentInfo$jscomp$2.name,\n                        entryName$jscomp$0 =\n                          env === response._rootEnvironmentName ||\n                          void 0 === env\n                            ? name\n                            : name + \" [\" + env + \"]\",\n                        measureName = \"\\u200b\" + entryName$jscomp$0,\n                        properties = [\n                          [\n                            \"Error\",\n                            \"object\" === typeof error &&\n                            null !== error &&\n                            \"string\" === typeof error.message\n                              ? String(error.message)\n                              : String(error)\n                          ]\n                        ];\n                      null != componentInfo$jscomp$2.key &&\n                        addValueToProperties(\n                          \"key\",\n                          componentInfo$jscomp$2.key,\n                          properties,\n                          0,\n                          \"\"\n                        );\n                      null != componentInfo$jscomp$2.props &&\n                        addObjectToProperties(\n                          componentInfo$jscomp$2.props,\n                          properties,\n                          0,\n                          \"\"\n                        );\n                      performance.measure(measureName, {\n                        start: 0 > startTime$jscomp$2 ? 0 : startTime$jscomp$2,\n                        end: childrenEndTime$jscomp$1,\n                        detail: {\n                          devtools: {\n                            color: \"error\",\n                            track: trackNames[trackIdx$jscomp$1],\n                            trackGroup: \"Server Components \\u269b\",\n                            tooltipText: entryName$jscomp$0 + \" Errored\",\n                            properties: properties\n                          }\n                        }\n                      });\n                      performance.clearMeasures(measureName);\n                    }\n                  } else {\n                    var componentInfo$jscomp$3 = componentInfo$jscomp$1,\n                      trackIdx$jscomp$2 = trackIdx$jscomp$0,\n                      startTime$jscomp$3 = startTime$jscomp$1,\n                      childrenEndTime$jscomp$2 = childrenEndTime$jscomp$0;\n                    if (\n                      supportsUserTiming &&\n                      0 <= childrenEndTime$jscomp$2 &&\n                      10 > trackIdx$jscomp$2\n                    ) {\n                      var env$jscomp$0 = componentInfo$jscomp$3.env,\n                        name$jscomp$0 = componentInfo$jscomp$3.name,\n                        isPrimaryEnv =\n                          env$jscomp$0 === response._rootEnvironmentName,\n                        selfTime =\n                          componentEndTime$jscomp$0 - startTime$jscomp$3,\n                        color$jscomp$0 =\n                          0.5 > selfTime\n                            ? isPrimaryEnv\n                              ? \"primary-light\"\n                              : \"secondary-light\"\n                            : 50 > selfTime\n                              ? isPrimaryEnv\n                                ? \"primary\"\n                                : \"secondary\"\n                              : 500 > selfTime\n                                ? isPrimaryEnv\n                                  ? \"primary-dark\"\n                                  : \"secondary-dark\"\n                                : \"error\",\n                        debugTask$jscomp$0 = componentInfo$jscomp$3.debugTask,\n                        measureName$jscomp$0 =\n                          \"\\u200b\" +\n                          (isPrimaryEnv || void 0 === env$jscomp$0\n                            ? name$jscomp$0\n                            : name$jscomp$0 + \" [\" + env$jscomp$0 + \"]\");\n                      if (debugTask$jscomp$0) {\n                        var properties$jscomp$0 = [];\n                        null != componentInfo$jscomp$3.key &&\n                          addValueToProperties(\n                            \"key\",\n                            componentInfo$jscomp$3.key,\n                            properties$jscomp$0,\n                            0,\n                            \"\"\n                          );\n                        null != componentInfo$jscomp$3.props &&\n                          addObjectToProperties(\n                            componentInfo$jscomp$3.props,\n                            properties$jscomp$0,\n                            0,\n                            \"\"\n                          );\n                        debugTask$jscomp$0.run(\n                          performance.measure.bind(\n                            performance,\n                            measureName$jscomp$0,\n                            {\n                              start:\n                                0 > startTime$jscomp$3 ? 0 : startTime$jscomp$3,\n                              end: childrenEndTime$jscomp$2,\n                              detail: {\n                                devtools: {\n                                  color: color$jscomp$0,\n                                  track: trackNames[trackIdx$jscomp$2],\n                                  trackGroup: \"Server Components \\u269b\",\n                                  properties: properties$jscomp$0\n                                }\n                              }\n                            }\n                          )\n                        );\n                        performance.clearMeasures(measureName$jscomp$0);\n                      } else\n                        console.timeStamp(\n                          measureName$jscomp$0,\n                          0 > startTime$jscomp$3 ? 0 : startTime$jscomp$3,\n                          childrenEndTime$jscomp$2,\n                          trackNames[trackIdx$jscomp$2],\n                          \"Server Components \\u269b\",\n                          color$jscomp$0\n                        );\n                    }\n                  }\n                  componentEndTime = time;\n                  result.component = componentInfo$jscomp$0;\n                  isLastComponent = !1;\n                } else if (\n                  candidateInfo.awaited &&\n                  null != candidateInfo.awaited.env\n                ) {\n                  endTime > childrenEndTime && (childrenEndTime = endTime);\n                  var asyncInfo = candidateInfo,\n                    env$jscomp$1 = response$jscomp$0._rootEnvironmentName,\n                    promise = asyncInfo.awaited.value;\n                  if (promise) {\n                    var thenable = promise;\n                    switch (thenable.status) {\n                      case \"fulfilled\":\n                        logComponentAwait(\n                          asyncInfo,\n                          trackIdx$jscomp$6,\n                          time,\n                          endTime,\n                          env$jscomp$1,\n                          thenable.value\n                        );\n                        break;\n                      case \"rejected\":\n                        var asyncInfo$jscomp$0 = asyncInfo,\n                          trackIdx$jscomp$3 = trackIdx$jscomp$6,\n                          startTime$jscomp$4 = time,\n                          endTime$jscomp$0 = endTime,\n                          rootEnv = env$jscomp$1,\n                          error$jscomp$0 = thenable.reason;\n                        if (supportsUserTiming && 0 < endTime$jscomp$0) {\n                          var description = getIODescription(error$jscomp$0),\n                            entryName$jscomp$1 =\n                              \"await \" +\n                              getIOShortName(\n                                asyncInfo$jscomp$0.awaited,\n                                description,\n                                asyncInfo$jscomp$0.env,\n                                rootEnv\n                              ),\n                            debugTask$jscomp$1 =\n                              asyncInfo$jscomp$0.debugTask ||\n                              asyncInfo$jscomp$0.awaited.debugTask;\n                          if (debugTask$jscomp$1) {\n                            var properties$jscomp$1 = [\n                                [\n                                  \"Rejected\",\n                                  \"object\" === typeof error$jscomp$0 &&\n                                  null !== error$jscomp$0 &&\n                                  \"string\" === typeof error$jscomp$0.message\n                                    ? String(error$jscomp$0.message)\n                                    : String(error$jscomp$0)\n                                ]\n                              ],\n                              tooltipText =\n                                getIOLongName(\n                                  asyncInfo$jscomp$0.awaited,\n                                  description,\n                                  asyncInfo$jscomp$0.env,\n                                  rootEnv\n                                ) + \" Rejected\";\n                            debugTask$jscomp$1.run(\n                              performance.measure.bind(\n                                performance,\n                                entryName$jscomp$1,\n                                {\n                                  start:\n                                    0 > startTime$jscomp$4\n                                      ? 0\n                                      : startTime$jscomp$4,\n                                  end: endTime$jscomp$0,\n                                  detail: {\n                                    devtools: {\n                                      color: \"error\",\n                                      track: trackNames[trackIdx$jscomp$3],\n                                      trackGroup: \"Server Components \\u269b\",\n                                      properties: properties$jscomp$1,\n                                      tooltipText: tooltipText\n                                    }\n                                  }\n                                }\n                              )\n                            );\n                            performance.clearMeasures(entryName$jscomp$1);\n                          } else\n                            console.timeStamp(\n                              entryName$jscomp$1,\n                              0 > startTime$jscomp$4 ? 0 : startTime$jscomp$4,\n                              endTime$jscomp$0,\n                              trackNames[trackIdx$jscomp$3],\n                              \"Server Components \\u269b\",\n                              \"error\"\n                            );\n                        }\n                        break;\n                      default:\n                        logComponentAwait(\n                          asyncInfo,\n                          trackIdx$jscomp$6,\n                          time,\n                          endTime,\n                          env$jscomp$1,\n                          void 0\n                        );\n                    }\n                  } else\n                    logComponentAwait(\n                      asyncInfo,\n                      trackIdx$jscomp$6,\n                      time,\n                      endTime,\n                      env$jscomp$1,\n                      void 0\n                    );\n                }\n              }\n            else {\n              endTime = time;\n              for (var _j = debugInfo.length - 1; _j > _i6; _j--) {\n                var _candidateInfo = debugInfo[_j];\n                if (\"string\" === typeof _candidateInfo.name) {\n                  componentEndTime > childrenEndTime &&\n                    (childrenEndTime = componentEndTime);\n                  var _componentInfo = _candidateInfo,\n                    _env = response$jscomp$0._rootEnvironmentName,\n                    componentInfo$jscomp$4 = _componentInfo,\n                    trackIdx$jscomp$4 = trackIdx$jscomp$6,\n                    startTime$jscomp$5 = time,\n                    childrenEndTime$jscomp$3 = childrenEndTime;\n                  if (supportsUserTiming) {\n                    var env$jscomp$2 = componentInfo$jscomp$4.env,\n                      name$jscomp$1 = componentInfo$jscomp$4.name,\n                      entryName$jscomp$2 =\n                        env$jscomp$2 === _env || void 0 === env$jscomp$2\n                          ? name$jscomp$1\n                          : name$jscomp$1 + \" [\" + env$jscomp$2 + \"]\",\n                      measureName$jscomp$1 = \"\\u200b\" + entryName$jscomp$2,\n                      properties$jscomp$2 = [\n                        [\n                          \"Aborted\",\n                          \"The stream was aborted before this Component finished rendering.\"\n                        ]\n                      ];\n                    null != componentInfo$jscomp$4.key &&\n                      addValueToProperties(\n                        \"key\",\n                        componentInfo$jscomp$4.key,\n                        properties$jscomp$2,\n                        0,\n                        \"\"\n                      );\n                    null != componentInfo$jscomp$4.props &&\n                      addObjectToProperties(\n                        componentInfo$jscomp$4.props,\n                        properties$jscomp$2,\n                        0,\n                        \"\"\n                      );\n                    performance.measure(measureName$jscomp$1, {\n                      start: 0 > startTime$jscomp$5 ? 0 : startTime$jscomp$5,\n                      end: childrenEndTime$jscomp$3,\n                      detail: {\n                        devtools: {\n                          color: \"warning\",\n                          track: trackNames[trackIdx$jscomp$4],\n                          trackGroup: \"Server Components \\u269b\",\n                          tooltipText: entryName$jscomp$2 + \" Aborted\",\n                          properties: properties$jscomp$2\n                        }\n                      }\n                    });\n                    performance.clearMeasures(measureName$jscomp$1);\n                  }\n                  componentEndTime = time;\n                  result.component = _componentInfo;\n                  isLastComponent = !1;\n                } else if (\n                  _candidateInfo.awaited &&\n                  null != _candidateInfo.awaited.env\n                ) {\n                  var _asyncInfo = _candidateInfo,\n                    _env2 = response$jscomp$0._rootEnvironmentName;\n                  _asyncInfo.awaited.end > endTime &&\n                    (endTime = _asyncInfo.awaited.end);\n                  endTime > childrenEndTime && (childrenEndTime = endTime);\n                  var asyncInfo$jscomp$1 = _asyncInfo,\n                    trackIdx$jscomp$5 = trackIdx$jscomp$6,\n                    startTime$jscomp$6 = time,\n                    endTime$jscomp$1 = endTime,\n                    rootEnv$jscomp$0 = _env2;\n                  if (supportsUserTiming && 0 < endTime$jscomp$1) {\n                    var entryName$jscomp$3 =\n                        \"await \" +\n                        getIOShortName(\n                          asyncInfo$jscomp$1.awaited,\n                          \"\",\n                          asyncInfo$jscomp$1.env,\n                          rootEnv$jscomp$0\n                        ),\n                      debugTask$jscomp$2 =\n                        asyncInfo$jscomp$1.debugTask ||\n                        asyncInfo$jscomp$1.awaited.debugTask;\n                    if (debugTask$jscomp$2) {\n                      var tooltipText$jscomp$0 =\n                        getIOLongName(\n                          asyncInfo$jscomp$1.awaited,\n                          \"\",\n                          asyncInfo$jscomp$1.env,\n                          rootEnv$jscomp$0\n                        ) + \" Aborted\";\n                      debugTask$jscomp$2.run(\n                        performance.measure.bind(\n                          performance,\n                          entryName$jscomp$3,\n                          {\n                            start:\n                              0 > startTime$jscomp$6 ? 0 : startTime$jscomp$6,\n                            end: endTime$jscomp$1,\n                            detail: {\n                              devtools: {\n                                color: \"warning\",\n                                track: trackNames[trackIdx$jscomp$5],\n                                trackGroup: \"Server Components \\u269b\",\n                                properties: [\n                                  [\n                                    \"Aborted\",\n                                    \"The stream was aborted before this Promise resolved.\"\n                                  ]\n                                ],\n                                tooltipText: tooltipText$jscomp$0\n                              }\n                            }\n                          }\n                        )\n                      );\n                      performance.clearMeasures(entryName$jscomp$3);\n                    } else\n                      console.timeStamp(\n                        entryName$jscomp$3,\n                        0 > startTime$jscomp$6 ? 0 : startTime$jscomp$6,\n                        endTime$jscomp$1,\n                        trackNames[trackIdx$jscomp$5],\n                        \"Server Components \\u269b\",\n                        \"warning\"\n                      );\n                  }\n                }\n              }\n            }\n            endTime = time;\n            endTimeIdx = _i6;\n          }\n        }\n      result.endTime = childrenEndTime;\n      return result;\n    }\n    function flushInitialRenderPerformance(response) {\n      if (response._replayConsole) {\n        var rootChunk = getChunk(response, 0);\n        isArrayImpl(rootChunk._children) &&\n          (markAllTracksInOrder(),\n          flushComponentPerformance(\n            response,\n            rootChunk,\n            0,\n            -Infinity,\n            -Infinity\n          ));\n      }\n    }\n    function processFullBinaryRow(\n      response,\n      streamState,\n      id,\n      tag,\n      buffer,\n      chunk\n    ) {\n      switch (tag) {\n        case 65:\n          resolveBuffer(\n            response,\n            id,\n            mergeBuffer(buffer, chunk).buffer,\n            streamState\n          );\n          return;\n        case 79:\n          resolveTypedArray(\n            response,\n            id,\n            buffer,\n            chunk,\n            Int8Array,\n            1,\n            streamState\n          );\n          return;\n        case 111:\n          resolveBuffer(\n            response,\n            id,\n            0 === buffer.length ? chunk : mergeBuffer(buffer, chunk),\n            streamState\n          );\n          return;\n        case 85:\n          resolveTypedArray(\n            response,\n            id,\n            buffer,\n            chunk,\n            Uint8ClampedArray,\n            1,\n            streamState\n          );\n          return;\n        case 83:\n          resolveTypedArray(\n            response,\n            id,\n            buffer,\n            chunk,\n            Int16Array,\n            2,\n            streamState\n          );\n          return;\n        case 115:\n          resolveTypedArray(\n            response,\n            id,\n            buffer,\n            chunk,\n            Uint16Array,\n            2,\n            streamState\n          );\n          return;\n        case 76:\n          resolveTypedArray(\n            response,\n            id,\n            buffer,\n            chunk,\n            Int32Array,\n            4,\n            streamState\n          );\n          return;\n        case 108:\n          resolveTypedArray(\n            response,\n            id,\n            buffer,\n            chunk,\n            Uint32Array,\n            4,\n            streamState\n          );\n          return;\n        case 71:\n          resolveTypedArray(\n            response,\n            id,\n            buffer,\n            chunk,\n            Float32Array,\n            4,\n            streamState\n          );\n          return;\n        case 103:\n          resolveTypedArray(\n            response,\n            id,\n            buffer,\n            chunk,\n            Float64Array,\n            8,\n            streamState\n          );\n          return;\n        case 77:\n          resolveTypedArray(\n            response,\n            id,\n            buffer,\n            chunk,\n            BigInt64Array,\n            8,\n            streamState\n          );\n          return;\n        case 109:\n          resolveTypedArray(\n            response,\n            id,\n            buffer,\n            chunk,\n            BigUint64Array,\n            8,\n            streamState\n          );\n          return;\n        case 86:\n          resolveTypedArray(\n            response,\n            id,\n            buffer,\n            chunk,\n            DataView,\n            1,\n            streamState\n          );\n          return;\n      }\n      for (\n        var stringDecoder = response._stringDecoder, row = \"\", i = 0;\n        i < buffer.length;\n        i++\n      )\n        row += stringDecoder.decode(buffer[i], decoderOptions);\n      row += stringDecoder.decode(chunk);\n      processFullStringRow(response, streamState, id, tag, row);\n    }\n    function processFullStringRow(response, streamState, id, tag, row) {\n      switch (tag) {\n        case 73:\n          resolveModule(response, id, row, streamState);\n          break;\n        case 72:\n          id = row[0];\n          streamState = row.slice(1);\n          response = JSON.parse(streamState, response._fromJSON);\n          streamState = ReactDOMSharedInternals.d;\n          switch (id) {\n            case \"D\":\n              streamState.D(response);\n              break;\n            case \"C\":\n              \"string\" === typeof response\n                ? streamState.C(response)\n                : streamState.C(response[0], response[1]);\n              break;\n            case \"L\":\n              id = response[0];\n              row = response[1];\n              3 === response.length\n                ? streamState.L(id, row, response[2])\n                : streamState.L(id, row);\n              break;\n            case \"m\":\n              \"string\" === typeof response\n                ? streamState.m(response)\n                : streamState.m(response[0], response[1]);\n              break;\n            case \"X\":\n              \"string\" === typeof response\n                ? streamState.X(response)\n                : streamState.X(response[0], response[1]);\n              break;\n            case \"S\":\n              \"string\" === typeof response\n                ? streamState.S(response)\n                : streamState.S(\n                    response[0],\n                    0 === response[1] ? void 0 : response[1],\n                    3 === response.length ? response[2] : void 0\n                  );\n              break;\n            case \"M\":\n              \"string\" === typeof response\n                ? streamState.M(response)\n                : streamState.M(response[0], response[1]);\n          }\n          break;\n        case 69:\n          tag = response._chunks;\n          var chunk = tag.get(id);\n          row = JSON.parse(row);\n          var error = resolveErrorDev(response, row);\n          error.digest = row.digest;\n          chunk\n            ? (resolveChunkDebugInfo(response, streamState, chunk),\n              triggerErrorOnChunk(response, chunk, error))\n            : ((row = new ReactPromise(\"rejected\", null, error)),\n              resolveChunkDebugInfo(response, streamState, row),\n              tag.set(id, row));\n          break;\n        case 84:\n          tag = response._chunks;\n          (chunk = tag.get(id)) && \"pending\" !== chunk.status\n            ? chunk.reason.enqueueValue(row)\n            : (chunk && releasePendingChunk(response, chunk),\n              (row = new ReactPromise(\"fulfilled\", row, null)),\n              resolveChunkDebugInfo(response, streamState, row),\n              tag.set(id, row));\n          break;\n        case 78:\n          response._timeOrigin = +row - performance.timeOrigin;\n          break;\n        case 68:\n          id = getChunk(response, id);\n          \"fulfilled\" !== id.status &&\n            \"rejected\" !== id.status &&\n            \"halted\" !== id.status &&\n            \"blocked\" !== id.status &&\n            \"resolved_module\" !== id.status &&\n            ((streamState = id._debugChunk),\n            (tag = createResolvedModelChunk(response, row)),\n            (tag._debugChunk = streamState),\n            (id._debugChunk = tag),\n            initializeDebugChunk(response, id),\n            \"blocked\" !== tag.status ||\n              (void 0 !== response._debugChannel &&\n                response._debugChannel.hasReadable) ||\n              '\"' !== row[0] ||\n              \"$\" !== row[1] ||\n              ((streamState = row.slice(2, row.length - 1).split(\":\")),\n              (streamState = parseInt(streamState[0], 16)),\n              \"pending\" === getChunk(response, streamState).status &&\n                (id._debugChunk = null)));\n          break;\n        case 74:\n          resolveIOInfo(response, id, row);\n          break;\n        case 87:\n          resolveConsoleEntry(response, row);\n          break;\n        case 82:\n          startReadableStream(response, id, void 0, streamState);\n          break;\n        case 114:\n          startReadableStream(response, id, \"bytes\", streamState);\n          break;\n        case 88:\n          startAsyncIterable(response, id, !1, streamState);\n          break;\n        case 120:\n          startAsyncIterable(response, id, !0, streamState);\n          break;\n        case 67:\n          (id = response._chunks.get(id)) &&\n            \"fulfilled\" === id.status &&\n            (0 === --response._pendingChunks &&\n              (response._weakResponse.response = null),\n            id.reason.close(\"\" === row ? '\"$undefined\"' : row));\n          break;\n        default:\n          if (\"\" === row) {\n            if (\n              ((streamState = response._chunks),\n              (row = streamState.get(id)) ||\n                streamState.set(id, (row = createPendingChunk(response))),\n              \"pending\" === row.status || \"blocked\" === row.status)\n            )\n              releasePendingChunk(response, row),\n                (response = row),\n                (response.status = \"halted\"),\n                (response.value = null),\n                (response.reason = null);\n          } else\n            (tag = response._chunks),\n              (chunk = tag.get(id))\n                ? (resolveChunkDebugInfo(response, streamState, chunk),\n                  resolveModelChunk(response, chunk, row))\n                : ((row = createResolvedModelChunk(response, row)),\n                  resolveChunkDebugInfo(response, streamState, row),\n                  tag.set(id, row));\n      }\n    }\n    function processBinaryChunk(weakResponse, streamState, chunk) {\n      if (void 0 !== weakResponse.weak.deref()) {\n        weakResponse = unwrapWeakResponse(weakResponse);\n        var i = 0,\n          rowState = streamState._rowState,\n          rowID = streamState._rowID,\n          rowTag = streamState._rowTag,\n          rowLength = streamState._rowLength,\n          buffer = streamState._buffer,\n          chunkLength = chunk.length;\n        for (\n          incrementChunkDebugInfo(streamState, chunkLength);\n          i < chunkLength;\n\n        ) {\n          var lastIdx = -1;\n          switch (rowState) {\n            case 0:\n              lastIdx = chunk[i++];\n              58 === lastIdx\n                ? (rowState = 1)\n                : (rowID =\n                    (rowID << 4) |\n                    (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));\n              continue;\n            case 1:\n              rowState = chunk[i];\n              84 === rowState ||\n              65 === rowState ||\n              79 === rowState ||\n              111 === rowState ||\n              98 === rowState ||\n              85 === rowState ||\n              83 === rowState ||\n              115 === rowState ||\n              76 === rowState ||\n              108 === rowState ||\n              71 === rowState ||\n              103 === rowState ||\n              77 === rowState ||\n              109 === rowState ||\n              86 === rowState\n                ? ((rowTag = rowState), (rowState = 2), i++)\n                : (64 < rowState && 91 > rowState) ||\n                    35 === rowState ||\n                    114 === rowState ||\n                    120 === rowState\n                  ? ((rowTag = rowState), (rowState = 3), i++)\n                  : ((rowTag = 0), (rowState = 3));\n              continue;\n            case 2:\n              lastIdx = chunk[i++];\n              44 === lastIdx\n                ? (rowState = 4)\n                : (rowLength =\n                    (rowLength << 4) |\n                    (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));\n              continue;\n            case 3:\n              lastIdx = chunk.indexOf(10, i);\n              break;\n            case 4:\n              (lastIdx = i + rowLength),\n                lastIdx > chunk.length && (lastIdx = -1);\n          }\n          var offset = chunk.byteOffset + i;\n          if (-1 < lastIdx)\n            (rowLength = new Uint8Array(chunk.buffer, offset, lastIdx - i)),\n              98 === rowTag\n                ? resolveBuffer(\n                    weakResponse,\n                    rowID,\n                    lastIdx === chunkLength ? rowLength : rowLength.slice(),\n                    streamState\n                  )\n                : processFullBinaryRow(\n                    weakResponse,\n                    streamState,\n                    rowID,\n                    rowTag,\n                    buffer,\n                    rowLength\n                  ),\n              (i = lastIdx),\n              3 === rowState && i++,\n              (rowLength = rowID = rowTag = rowState = 0),\n              (buffer.length = 0);\n          else {\n            chunk = new Uint8Array(chunk.buffer, offset, chunk.byteLength - i);\n            98 === rowTag\n              ? ((rowLength -= chunk.byteLength),\n                resolveBuffer(weakResponse, rowID, chunk, streamState))\n              : (buffer.push(chunk), (rowLength -= chunk.byteLength));\n            break;\n          }\n        }\n        streamState._rowState = rowState;\n        streamState._rowID = rowID;\n        streamState._rowTag = rowTag;\n        streamState._rowLength = rowLength;\n      }\n    }\n    function createFromJSONCallback(response) {\n      return function (key, value) {\n        if (\"__proto__\" !== key) {\n          if (\"string\" === typeof value)\n            return parseModelString(response, this, key, value);\n          if (\"object\" === typeof value && null !== value) {\n            if (value[0] === REACT_ELEMENT_TYPE)\n              b: {\n                var owner = value[4],\n                  stack = value[5];\n                key = value[6];\n                value = {\n                  $$typeof: REACT_ELEMENT_TYPE,\n                  type: value[1],\n                  key: value[2],\n                  props: value[3],\n                  _owner: void 0 === owner ? null : owner\n                };\n                Object.defineProperty(value, \"ref\", {\n                  enumerable: !1,\n                  get: nullRefGetter\n                });\n                value._store = {};\n                Object.defineProperty(value._store, \"validated\", {\n                  configurable: !1,\n                  enumerable: !1,\n                  writable: !0,\n                  value: key\n                });\n                Object.defineProperty(value, \"_debugInfo\", {\n                  configurable: !1,\n                  enumerable: !1,\n                  writable: !0,\n                  value: null\n                });\n                Object.defineProperty(value, \"_debugStack\", {\n                  configurable: !1,\n                  enumerable: !1,\n                  writable: !0,\n                  value: void 0 === stack ? null : stack\n                });\n                Object.defineProperty(value, \"_debugTask\", {\n                  configurable: !1,\n                  enumerable: !1,\n                  writable: !0,\n                  value: null\n                });\n                if (null !== initializingHandler) {\n                  owner = initializingHandler;\n                  initializingHandler = owner.parent;\n                  if (owner.errored) {\n                    stack = new ReactPromise(\"rejected\", null, owner.reason);\n                    initializeElement(response, value, null);\n                    owner = {\n                      name: getComponentNameFromType(value.type) || \"\",\n                      owner: value._owner\n                    };\n                    owner.debugStack = value._debugStack;\n                    supportsCreateTask && (owner.debugTask = value._debugTask);\n                    stack._debugInfo = [owner];\n                    key = createLazyChunkWrapper(stack, key);\n                    break b;\n                  }\n                  if (0 < owner.deps) {\n                    stack = new ReactPromise(\"blocked\", null, null);\n                    owner.value = value;\n                    owner.chunk = stack;\n                    key = createLazyChunkWrapper(stack, key);\n                    value = initializeElement.bind(null, response, value, key);\n                    stack.then(value, value);\n                    break b;\n                  }\n                }\n                initializeElement(response, value, null);\n                key = value;\n              }\n            else key = value;\n            return key;\n          }\n          return value;\n        }\n      };\n    }\n    function close(weakResponse) {\n      reportGlobalError(weakResponse, Error(\"Connection closed.\"));\n    }\n    function createDebugCallbackFromWritableStream(debugWritable) {\n      var textEncoder = new TextEncoder(),\n        writer = debugWritable.getWriter();\n      return function (message) {\n        \"\" === message\n          ? writer.close()\n          : writer\n              .write(textEncoder.encode(message + \"\\n\"))\n              .catch(console.error);\n      };\n    }\n    function createResponseFromOptions(options) {\n      var debugChannel =\n        options && void 0 !== options.debugChannel\n          ? {\n              hasReadable: void 0 !== options.debugChannel.readable,\n              callback:\n                void 0 !== options.debugChannel.writable\n                  ? createDebugCallbackFromWritableStream(\n                      options.debugChannel.writable\n                    )\n                  : null\n            }\n          : void 0;\n      return new ResponseInstance(\n        null,\n        null,\n        null,\n        options && options.callServer ? options.callServer : void 0,\n        void 0,\n        void 0,\n        options && options.temporaryReferences\n          ? options.temporaryReferences\n          : void 0,\n        options && options.findSourceMapURL ? options.findSourceMapURL : void 0,\n        options ? !1 !== options.replayConsoleLogs : !0,\n        options && options.environmentName ? options.environmentName : void 0,\n        options && null != options.startTime ? options.startTime : void 0,\n        options && null != options.endTime ? options.endTime : void 0,\n        debugChannel\n      )._weakResponse;\n    }\n    function startReadingFromUniversalStream(\n      response$jscomp$0,\n      stream,\n      onDone\n    ) {\n      function progress(_ref) {\n        var value = _ref.value;\n        if (_ref.done) return onDone();\n        if (value instanceof ArrayBuffer)\n          processBinaryChunk(\n            response$jscomp$0,\n            streamState,\n            new Uint8Array(value)\n          );\n        else if (\"string\" === typeof value) {\n          if (\n            ((_ref = streamState), void 0 !== response$jscomp$0.weak.deref())\n          ) {\n            var response = unwrapWeakResponse(response$jscomp$0),\n              i = 0,\n              rowState = _ref._rowState,\n              rowID = _ref._rowID,\n              rowTag = _ref._rowTag,\n              rowLength = _ref._rowLength,\n              buffer = _ref._buffer,\n              chunkLength = value.length;\n            for (\n              incrementChunkDebugInfo(_ref, chunkLength);\n              i < chunkLength;\n\n            ) {\n              var lastIdx = -1;\n              switch (rowState) {\n                case 0:\n                  lastIdx = value.charCodeAt(i++);\n                  58 === lastIdx\n                    ? (rowState = 1)\n                    : (rowID =\n                        (rowID << 4) |\n                        (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));\n                  continue;\n                case 1:\n                  rowState = value.charCodeAt(i);\n                  84 === rowState ||\n                  65 === rowState ||\n                  79 === rowState ||\n                  111 === rowState ||\n                  85 === rowState ||\n                  83 === rowState ||\n                  115 === rowState ||\n                  76 === rowState ||\n                  108 === rowState ||\n                  71 === rowState ||\n                  103 === rowState ||\n                  77 === rowState ||\n                  109 === rowState ||\n                  86 === rowState\n                    ? ((rowTag = rowState), (rowState = 2), i++)\n                    : (64 < rowState && 91 > rowState) ||\n                        114 === rowState ||\n                        120 === rowState\n                      ? ((rowTag = rowState), (rowState = 3), i++)\n                      : ((rowTag = 0), (rowState = 3));\n                  continue;\n                case 2:\n                  lastIdx = value.charCodeAt(i++);\n                  44 === lastIdx\n                    ? (rowState = 4)\n                    : (rowLength =\n                        (rowLength << 4) |\n                        (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));\n                  continue;\n                case 3:\n                  lastIdx = value.indexOf(\"\\n\", i);\n                  break;\n                case 4:\n                  if (84 !== rowTag)\n                    throw Error(\n                      \"Binary RSC chunks cannot be encoded as strings. This is a bug in the wiring of the React streams.\"\n                    );\n                  if (rowLength < value.length || value.length > 3 * rowLength)\n                    throw Error(\n                      \"String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.\"\n                    );\n                  lastIdx = value.length;\n              }\n              if (-1 < lastIdx) {\n                if (0 < buffer.length)\n                  throw Error(\n                    \"String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.\"\n                  );\n                i = value.slice(i, lastIdx);\n                processFullStringRow(response, _ref, rowID, rowTag, i);\n                i = lastIdx;\n                3 === rowState && i++;\n                rowLength = rowID = rowTag = rowState = 0;\n                buffer.length = 0;\n              } else if (value.length !== i)\n                throw Error(\n                  \"String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.\"\n                );\n            }\n            _ref._rowState = rowState;\n            _ref._rowID = rowID;\n            _ref._rowTag = rowTag;\n            _ref._rowLength = rowLength;\n          }\n        } else processBinaryChunk(response$jscomp$0, streamState, value);\n        return reader.read().then(progress).catch(error);\n      }\n      function error(e) {\n        reportGlobalError(response$jscomp$0, e);\n      }\n      var streamState = createStreamState(response$jscomp$0, stream),\n        reader = stream.getReader();\n      reader.read().then(progress).catch(error);\n    }\n    function startReadingFromStream(response, stream, onDone, debugValue) {\n      function progress(_ref2) {\n        var value = _ref2.value;\n        if (_ref2.done) return onDone();\n        processBinaryChunk(response, streamState, value);\n        return reader.read().then(progress).catch(error);\n      }\n      function error(e) {\n        reportGlobalError(response, e);\n      }\n      var streamState = createStreamState(response, debugValue),\n        reader = stream.getReader();\n      reader.read().then(progress).catch(error);\n    }\n    var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      ReactDOM = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"),\n      decoderOptions = { stream: !0 },\n      bind = Function.prototype.bind,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      chunkCache = new Map(),\n      chunkMap = new Map(),\n      webpackGetChunkFilename = __webpack_require__.u;\n    __webpack_require__.u = function (chunkId) {\n      var flightChunk = chunkMap.get(chunkId);\n      return void 0 !== flightChunk\n        ? flightChunk\n        : webpackGetChunkFilename(chunkId);\n    };\n    var chunkIOInfoCache = new Map(),\n      ReactDOMSharedInternals =\n        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      ASYNC_ITERATOR = Symbol.asyncIterator,\n      isArrayImpl = Array.isArray,\n      getPrototypeOf = Object.getPrototypeOf,\n      jsxPropsParents = new WeakMap(),\n      jsxChildrenParents = new WeakMap(),\n      CLIENT_REFERENCE_TAG = Symbol.for(\"react.client.reference\"),\n      ObjectPrototype = Object.prototype,\n      knownServerReferences = new WeakMap(),\n      fakeServerFunctionIdx = 0,\n      v8FrameRegExp =\n        /^ {3} at (?:(.+) \\((.+):(\\d+):(\\d+)\\)|(?:async )?(.+):(\\d+):(\\d+))$/,\n      jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\\d+):(\\d+)/,\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      supportsUserTiming =\n        \"undefined\" !== typeof console &&\n        \"function\" === typeof console.timeStamp &&\n        \"undefined\" !== typeof performance &&\n        \"function\" === typeof performance.measure,\n      trackNames =\n        \"Primary Parallel Parallel\\u200b Parallel\\u200b\\u200b Parallel\\u200b\\u200b\\u200b Parallel\\u200b\\u200b\\u200b\\u200b Parallel\\u200b\\u200b\\u200b\\u200b\\u200b Parallel\\u200b\\u200b\\u200b\\u200b\\u200b\\u200b Parallel\\u200b\\u200b\\u200b\\u200b\\u200b\\u200b\\u200b Parallel\\u200b\\u200b\\u200b\\u200b\\u200b\\u200b\\u200b\\u200b\".split(\n          \" \"\n        ),\n      prefix,\n      suffix;\n    new (\"function\" === typeof WeakMap ? WeakMap : Map)();\n    var ReactSharedInteralsServer =\n        React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE ||\n        ReactSharedInteralsServer;\n    ReactPromise.prototype = Object.create(Promise.prototype);\n    ReactPromise.prototype.then = function (resolve, reject) {\n      var _this = this;\n      switch (this.status) {\n        case \"resolved_model\":\n          initializeModelChunk(this);\n          break;\n        case \"resolved_module\":\n          initializeModuleChunk(this);\n      }\n      var resolveCallback = resolve,\n        rejectCallback = reject,\n        wrapperPromise = new Promise(function (res, rej) {\n          resolve = function (value) {\n            wrapperPromise._debugInfo = _this._debugInfo;\n            res(value);\n          };\n          reject = function (reason) {\n            wrapperPromise._debugInfo = _this._debugInfo;\n            rej(reason);\n          };\n        });\n      wrapperPromise.then(resolveCallback, rejectCallback);\n      switch (this.status) {\n        case \"fulfilled\":\n          \"function\" === typeof resolve && resolve(this.value);\n          break;\n        case \"pending\":\n        case \"blocked\":\n          \"function\" === typeof resolve &&\n            (null === this.value && (this.value = []),\n            this.value.push(resolve));\n          \"function\" === typeof reject &&\n            (null === this.reason && (this.reason = []),\n            this.reason.push(reject));\n          break;\n        case \"halted\":\n          break;\n        default:\n          \"function\" === typeof reject && reject(this.reason);\n      }\n    };\n    var debugChannelRegistry =\n        \"function\" === typeof FinalizationRegistry\n          ? new FinalizationRegistry(closeDebugChannel)\n          : null,\n      initializingHandler = null,\n      initializingChunk = null,\n      mightHaveStaticConstructor = /\\bclass\\b.*\\bstatic\\b/,\n      MIN_CHUNK_SIZE = 65536,\n      supportsCreateTask = !!console.createTask,\n      fakeFunctionCache = new Map(),\n      fakeFunctionIdx = 0,\n      createFakeJSXCallStack = {\n        react_stack_bottom_frame: function (response, stack, environmentName) {\n          return buildFakeCallStack(\n            response,\n            stack,\n            environmentName,\n            !1,\n            fakeJSXCallSite\n          )();\n        }\n      },\n      createFakeJSXCallStackInDEV =\n        createFakeJSXCallStack.react_stack_bottom_frame.bind(\n          createFakeJSXCallStack\n        ),\n      currentOwnerInDEV = null,\n      replayConsoleWithCallStack = {\n        react_stack_bottom_frame: function (response, payload) {\n          var methodName = payload[0],\n            stackTrace = payload[1],\n            owner = payload[2],\n            env = payload[3];\n          payload = payload.slice(4);\n          var prevStack = ReactSharedInternals.getCurrentStack;\n          ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;\n          currentOwnerInDEV = null === owner ? response._debugRootOwner : owner;\n          try {\n            a: {\n              var offset = 0;\n              switch (methodName) {\n                case \"dir\":\n                case \"dirxml\":\n                case \"groupEnd\":\n                case \"table\":\n                  var JSCompiler_inline_result = bind.apply(\n                    console[methodName],\n                    [console].concat(payload)\n                  );\n                  break a;\n                case \"assert\":\n                  offset = 1;\n              }\n              var newArgs = payload.slice(0);\n              \"string\" === typeof newArgs[offset]\n                ? newArgs.splice(\n                    offset,\n                    1,\n                    \"%c%s%c \" + newArgs[offset],\n                    \"background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px\",\n                    \" \" + env + \" \",\n                    \"\"\n                  )\n                : newArgs.splice(\n                    offset,\n                    0,\n                    \"%c%s%c\",\n                    \"background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px\",\n                    \" \" + env + \" \",\n                    \"\"\n                  );\n              newArgs.unshift(console);\n              JSCompiler_inline_result = bind.apply(\n                console[methodName],\n                newArgs\n              );\n            }\n            var callStack = buildFakeCallStack(\n              response,\n              stackTrace,\n              env,\n              !1,\n              JSCompiler_inline_result\n            );\n            if (null != owner) {\n              var task = initializeFakeTask(response, owner);\n              initializeFakeStack(response, owner);\n              if (null !== task) {\n                task.run(callStack);\n                return;\n              }\n            }\n            var rootTask = getRootTask(response, env);\n            null != rootTask ? rootTask.run(callStack) : callStack();\n          } finally {\n            (currentOwnerInDEV = null),\n              (ReactSharedInternals.getCurrentStack = prevStack);\n          }\n        }\n      },\n      replayConsoleWithCallStackInDEV =\n        replayConsoleWithCallStack.react_stack_bottom_frame.bind(\n          replayConsoleWithCallStack\n        );\n    (function (internals) {\n      if (\"undefined\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;\n      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n      if (hook.isDisabled || !hook.supportsFlight) return !0;\n      try {\n        hook.inject(internals);\n      } catch (err) {\n        console.error(\"React instrumentation encountered an error: %o.\", err);\n      }\n      return hook.checkDCE ? !0 : !1;\n    })({\n      bundleType: 1,\n      version: \"19.3.0-canary-cbec50fd-20260122\",\n      rendererPackageName: \"react-server-dom-webpack\",\n      currentDispatcherRef: ReactSharedInternals,\n      reconcilerVersion: \"19.3.0-canary-cbec50fd-20260122\",\n      getCurrentComponentInfo: function () {\n        return currentOwnerInDEV;\n      }\n    });\n    exports.createFromFetch = function (promiseForResponse, options) {\n      var response = createResponseFromOptions(options);\n      promiseForResponse.then(\n        function (r) {\n          if (\n            options &&\n            options.debugChannel &&\n            options.debugChannel.readable\n          ) {\n            var streamDoneCount = 0,\n              handleDone = function () {\n                2 === ++streamDoneCount && close(response);\n              };\n            startReadingFromUniversalStream(\n              response,\n              options.debugChannel.readable,\n              handleDone\n            );\n            startReadingFromStream(response, r.body, handleDone, r);\n          } else\n            startReadingFromStream(\n              response,\n              r.body,\n              close.bind(null, response),\n              r\n            );\n        },\n        function (e) {\n          reportGlobalError(response, e);\n        }\n      );\n      return getRoot(response);\n    };\n    exports.createFromReadableStream = function (stream, options) {\n      var response = createResponseFromOptions(options);\n      if (options && options.debugChannel && options.debugChannel.readable) {\n        var streamDoneCount = 0,\n          handleDone = function () {\n            2 === ++streamDoneCount && close(response);\n          };\n        startReadingFromUniversalStream(\n          response,\n          options.debugChannel.readable,\n          handleDone\n        );\n        startReadingFromStream(response, stream, handleDone, stream);\n      } else\n        startReadingFromStream(\n          response,\n          stream,\n          close.bind(null, response),\n          stream\n        );\n      return getRoot(response);\n    };\n    exports.createServerReference = function (\n      id,\n      callServer,\n      encodeFormAction,\n      findSourceMapURL,\n      functionName\n    ) {\n      function action() {\n        var args = Array.prototype.slice.call(arguments);\n        return callServer(id, args);\n      }\n      var location = parseStackLocation(Error(\"react-stack-top-frame\"));\n      if (null !== location) {\n        encodeFormAction = location[1];\n        var line = location[2];\n        location = location[3];\n        findSourceMapURL =\n          null == findSourceMapURL\n            ? null\n            : findSourceMapURL(encodeFormAction, \"Client\");\n        action = createFakeServerFunction(\n          functionName || \"\",\n          encodeFormAction,\n          findSourceMapURL,\n          line,\n          location,\n          \"Client\",\n          action\n        );\n      }\n      registerBoundServerReference(action, id, null);\n      return action;\n    };\n    exports.createTemporaryReferenceSet = function () {\n      return new Map();\n    };\n    exports.encodeReply = function (value, options) {\n      return new Promise(function (resolve, reject) {\n        var abort = processReply(\n          value,\n          \"\",\n          options && options.temporaryReferences\n            ? options.temporaryReferences\n            : void 0,\n          resolve,\n          reject\n        );\n        if (options && options.signal) {\n          var signal = options.signal;\n          if (signal.aborted) abort(signal.reason);\n          else {\n            var listener = function () {\n              abort(signal.reason);\n              signal.removeEventListener(\"abort\", listener);\n            };\n            signal.addEventListener(\"abort\", listener);\n          }\n        }\n      });\n    };\n    exports.registerServerReference = function (reference, id) {\n      registerBoundServerReference(reference, id, null);\n      return reference;\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2Nqcy9yZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2stY2xpZW50LmJyb3dzZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZDQUE2QztBQUNuRSxzQkFBc0IsNENBQTRDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxpQkFBaUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFzRDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkJBQTZCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHVCQUF1QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZCQUE2QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2QkFBNkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9DQUFvQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBK0I7QUFDaEU7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGFBQWE7QUFDcEU7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsdUJBQXVCLDZDQUE2QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHNCQUFzQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSx1QkFBdUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFnQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkJBQTZCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1DQUFtQztBQUN2QztBQUNBO0FBQ0EsSUFBSSxtQkFBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL3J5YW5yb3N6dG9jenkvRGV2ZWxvcG1lbnQvbWFpbnN0cmVldGFpLXdlYnNpdGUvYXBwcy9tZW1iZXJzL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2Nqcy9yZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2stY2xpZW50LmJyb3dzZXIuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrLWNsaWVudC5icm93c2VyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHJlc29sdmVDbGllbnRSZWZlcmVuY2UoYnVuZGxlckNvbmZpZywgbWV0YWRhdGEpIHtcbiAgICAgIGlmIChidW5kbGVyQ29uZmlnKSB7XG4gICAgICAgIHZhciBtb2R1bGVFeHBvcnRzID0gYnVuZGxlckNvbmZpZ1ttZXRhZGF0YVswXV07XG4gICAgICAgIGlmICgoYnVuZGxlckNvbmZpZyA9IG1vZHVsZUV4cG9ydHMgJiYgbW9kdWxlRXhwb3J0c1ttZXRhZGF0YVsyXV0pKVxuICAgICAgICAgIG1vZHVsZUV4cG9ydHMgPSBidW5kbGVyQ29uZmlnLm5hbWU7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJ1bmRsZXJDb25maWcgPSBtb2R1bGVFeHBvcnRzICYmIG1vZHVsZUV4cG9ydHNbXCIqXCJdO1xuICAgICAgICAgIGlmICghYnVuZGxlckNvbmZpZylcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAnQ291bGQgbm90IGZpbmQgdGhlIG1vZHVsZSBcIicgK1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhWzBdICtcbiAgICAgICAgICAgICAgICAnXCIgaW4gdGhlIFJlYWN0IFNlcnZlciBDb25zdW1lciBNYW5pZmVzdC4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiB0aGUgUmVhY3QgU2VydmVyIENvbXBvbmVudHMgYnVuZGxlci4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIG1vZHVsZUV4cG9ydHMgPSBtZXRhZGF0YVsyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gNCA9PT0gbWV0YWRhdGEubGVuZ3RoXG4gICAgICAgICAgPyBbYnVuZGxlckNvbmZpZy5pZCwgYnVuZGxlckNvbmZpZy5jaHVua3MsIG1vZHVsZUV4cG9ydHMsIDFdXG4gICAgICAgICAgOiBbYnVuZGxlckNvbmZpZy5pZCwgYnVuZGxlckNvbmZpZy5jaHVua3MsIG1vZHVsZUV4cG9ydHNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlU2VydmVyUmVmZXJlbmNlKGJ1bmRsZXJDb25maWcsIGlkKSB7XG4gICAgICB2YXIgbmFtZSA9IFwiXCIsXG4gICAgICAgIHJlc29sdmVkTW9kdWxlRGF0YSA9IGJ1bmRsZXJDb25maWdbaWRdO1xuICAgICAgaWYgKHJlc29sdmVkTW9kdWxlRGF0YSkgbmFtZSA9IHJlc29sdmVkTW9kdWxlRGF0YS5uYW1lO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBpZHggPSBpZC5sYXN0SW5kZXhPZihcIiNcIik7XG4gICAgICAgIC0xICE9PSBpZHggJiZcbiAgICAgICAgICAoKG5hbWUgPSBpZC5zbGljZShpZHggKyAxKSksXG4gICAgICAgICAgKHJlc29sdmVkTW9kdWxlRGF0YSA9IGJ1bmRsZXJDb25maWdbaWQuc2xpY2UoMCwgaWR4KV0pKTtcbiAgICAgICAgaWYgKCFyZXNvbHZlZE1vZHVsZURhdGEpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAnQ291bGQgbm90IGZpbmQgdGhlIG1vZHVsZSBcIicgK1xuICAgICAgICAgICAgICBpZCArXG4gICAgICAgICAgICAgICdcIiBpbiB0aGUgUmVhY3QgU2VydmVyIE1hbmlmZXN0LiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIHRoZSBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50cyBidW5kbGVyLidcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc29sdmVkTW9kdWxlRGF0YS5hc3luY1xuICAgICAgICA/IFtyZXNvbHZlZE1vZHVsZURhdGEuaWQsIHJlc29sdmVkTW9kdWxlRGF0YS5jaHVua3MsIG5hbWUsIDFdXG4gICAgICAgIDogW3Jlc29sdmVkTW9kdWxlRGF0YS5pZCwgcmVzb2x2ZWRNb2R1bGVEYXRhLmNodW5rcywgbmFtZV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVpcmVBc3luY01vZHVsZShpZCkge1xuICAgICAgdmFyIHByb21pc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwcm9taXNlLnRoZW4gfHwgXCJmdWxmaWxsZWRcIiA9PT0gcHJvbWlzZS5zdGF0dXMpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgcHJvbWlzZS50aGVuKFxuICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBwcm9taXNlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgcHJvbWlzZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgcHJvbWlzZS5yZWFzb24gPSByZWFzb247XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaWdub3JlUmVqZWN0KCkge31cbiAgICBmdW5jdGlvbiBwcmVsb2FkTW9kdWxlKG1ldGFkYXRhKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgY2h1bmtzID0gbWV0YWRhdGFbMV0sIHByb21pc2VzID0gW10sIGkgPSAwO1xuICAgICAgICBpIDwgY2h1bmtzLmxlbmd0aDtcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBjaHVua0lkID0gY2h1bmtzW2krK10sXG4gICAgICAgICAgY2h1bmtGaWxlbmFtZSA9IGNodW5rc1tpKytdLFxuICAgICAgICAgIGVudHJ5ID0gY2h1bmtDYWNoZS5nZXQoY2h1bmtJZCk7XG4gICAgICAgIHZvaWQgMCA9PT0gZW50cnlcbiAgICAgICAgICA/ICgoY2h1bmtGaWxlbmFtZSA9IGxvYWRDaHVuayhjaHVua0lkLCBjaHVua0ZpbGVuYW1lKSksXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGNodW5rRmlsZW5hbWUpLFxuICAgICAgICAgICAgKGVudHJ5ID0gY2h1bmtDYWNoZS5zZXQuYmluZChjaHVua0NhY2hlLCBjaHVua0lkLCBudWxsKSksXG4gICAgICAgICAgICBjaHVua0ZpbGVuYW1lLnRoZW4oZW50cnksIGlnbm9yZVJlamVjdCksXG4gICAgICAgICAgICBjaHVua0NhY2hlLnNldChjaHVua0lkLCBjaHVua0ZpbGVuYW1lKSlcbiAgICAgICAgICA6IG51bGwgIT09IGVudHJ5ICYmIHByb21pc2VzLnB1c2goZW50cnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDQgPT09IG1ldGFkYXRhLmxlbmd0aFxuICAgICAgICA/IDAgPT09IHByb21pc2VzLmxlbmd0aFxuICAgICAgICAgID8gcmVxdWlyZUFzeW5jTW9kdWxlKG1ldGFkYXRhWzBdKVxuICAgICAgICAgIDogUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVxdWlyZUFzeW5jTW9kdWxlKG1ldGFkYXRhWzBdKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIDogMCA8IHByb21pc2VzLmxlbmd0aFxuICAgICAgICAgID8gUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1aXJlTW9kdWxlKG1ldGFkYXRhKSB7XG4gICAgICB2YXIgbW9kdWxlRXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18obWV0YWRhdGFbMF0pO1xuICAgICAgaWYgKDQgPT09IG1ldGFkYXRhLmxlbmd0aCAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBtb2R1bGVFeHBvcnRzLnRoZW4pXG4gICAgICAgIGlmIChcImZ1bGZpbGxlZFwiID09PSBtb2R1bGVFeHBvcnRzLnN0YXR1cylcbiAgICAgICAgICBtb2R1bGVFeHBvcnRzID0gbW9kdWxlRXhwb3J0cy52YWx1ZTtcbiAgICAgICAgZWxzZSB0aHJvdyBtb2R1bGVFeHBvcnRzLnJlYXNvbjtcbiAgICAgIGlmIChcIipcIiA9PT0gbWV0YWRhdGFbMl0pIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICAgICAgaWYgKFwiXCIgPT09IG1ldGFkYXRhWzJdKVxuICAgICAgICByZXR1cm4gbW9kdWxlRXhwb3J0cy5fX2VzTW9kdWxlID8gbW9kdWxlRXhwb3J0cy5kZWZhdWx0IDogbW9kdWxlRXhwb3J0cztcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZHVsZUV4cG9ydHMsIG1ldGFkYXRhWzJdKSlcbiAgICAgICAgcmV0dXJuIG1vZHVsZUV4cG9ydHNbbWV0YWRhdGFbMl1dO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2FkQ2h1bmsoY2h1bmtJZCwgZmlsZW5hbWUpIHtcbiAgICAgIGNodW5rTWFwLnNldChjaHVua0lkLCBmaWxlbmFtZSk7XG4gICAgICByZXR1cm4gX193ZWJwYWNrX2NodW5rX2xvYWRfXyhjaHVua0lkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gbWF5YmVJdGVyYWJsZSB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBtYXliZUl0ZXJhYmxlID1cbiAgICAgICAgKE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICAgIG1heWJlSXRlcmFibGVbXCJAQGl0ZXJhdG9yXCJdO1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG1heWJlSXRlcmFibGUgPyBtYXliZUl0ZXJhYmxlIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNPYmplY3RQcm90b3R5cGUob2JqZWN0KSB7XG4gICAgICBpZiAoIW9iamVjdCkgcmV0dXJuICExO1xuICAgICAgdmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG4gICAgICBpZiAob2JqZWN0ID09PSBPYmplY3RQcm90b3R5cGUpIHJldHVybiAhMDtcbiAgICAgIGlmIChnZXRQcm90b3R5cGVPZihvYmplY3QpKSByZXR1cm4gITE7XG4gICAgICBvYmplY3QgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghKG9iamVjdFtpXSBpbiBPYmplY3RQcm90b3R5cGUpKSByZXR1cm4gITE7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzU2ltcGxlT2JqZWN0KG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdFByb3RvdHlwZShnZXRQcm90b3R5cGVPZihvYmplY3QpKSkgcmV0dXJuICExO1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KSwgaSA9IDA7XG4gICAgICAgIGkgPCBuYW1lcy5sZW5ndGg7XG4gICAgICAgIGkrK1xuICAgICAgKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIG5hbWVzW2ldKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFkZXNjcmlwdG9yIHx8XG4gICAgICAgICAgKCFkZXNjcmlwdG9yLmVudW1lcmFibGUgJiZcbiAgICAgICAgICAgICgoXCJrZXlcIiAhPT0gbmFtZXNbaV0gJiYgXCJyZWZcIiAhPT0gbmFtZXNbaV0pIHx8XG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGRlc2NyaXB0b3IuZ2V0KSlcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gb2JqZWN0TmFtZShvYmplY3QpIHtcbiAgICAgIG9iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpO1xuICAgICAgcmV0dXJuIG9iamVjdC5zbGljZSg4LCBvYmplY3QubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKGtleSkge1xuICAgICAgdmFyIGVuY29kZWRLZXkgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgICAgcmV0dXJuICdcIicgKyBrZXkgKyAnXCInID09PSBlbmNvZGVkS2V5ID8ga2V5IDogZW5jb2RlZEtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZSh2YWx1ZSkge1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIDEwID49IHZhbHVlLmxlbmd0aCA/IHZhbHVlIDogdmFsdWUuc2xpY2UoMCwgMTApICsgXCIuLi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwodmFsdWUpKSByZXR1cm4gXCJbLi4uXVwiO1xuICAgICAgICAgIGlmIChudWxsICE9PSB2YWx1ZSAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gQ0xJRU5UX1JFRkVSRU5DRV9UQUcpXG4gICAgICAgICAgICByZXR1cm4gXCJjbGllbnRcIjtcbiAgICAgICAgICB2YWx1ZSA9IG9iamVjdE5hbWUodmFsdWUpO1xuICAgICAgICAgIHJldHVybiBcIk9iamVjdFwiID09PSB2YWx1ZSA/IFwiey4uLn1cIiA6IHZhbHVlO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICByZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IENMSUVOVF9SRUZFUkVOQ0VfVEFHXG4gICAgICAgICAgICA/IFwiY2xpZW50XCJcbiAgICAgICAgICAgIDogKHZhbHVlID0gdmFsdWUuZGlzcGxheU5hbWUgfHwgdmFsdWUubmFtZSlcbiAgICAgICAgICAgICAgPyBcImZ1bmN0aW9uIFwiICsgdmFsdWVcbiAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZSkge1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfVklFV19UUkFOU0lUSU9OX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiVmlld1RyYW5zaXRpb25cIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZS5yZW5kZXIpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZS50eXBlKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZShwYXlsb2FkKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2Uob2JqZWN0T3JBcnJheSwgZXhwYW5kZWROYW1lKSB7XG4gICAgICB2YXIgb2JqS2luZCA9IG9iamVjdE5hbWUob2JqZWN0T3JBcnJheSk7XG4gICAgICBpZiAoXCJPYmplY3RcIiAhPT0gb2JqS2luZCAmJiBcIkFycmF5XCIgIT09IG9iaktpbmQpIHJldHVybiBvYmpLaW5kO1xuICAgICAgdmFyIHN0YXJ0ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBpZiAoaXNBcnJheUltcGwob2JqZWN0T3JBcnJheSkpXG4gICAgICAgIGlmIChqc3hDaGlsZHJlblBhcmVudHMuaGFzKG9iamVjdE9yQXJyYXkpKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBqc3hDaGlsZHJlblBhcmVudHMuZ2V0KG9iamVjdE9yQXJyYXkpO1xuICAgICAgICAgIG9iaktpbmQgPSBcIjxcIiArIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZSkgKyBcIj5cIjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdE9yQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdE9yQXJyYXlbaV07XG4gICAgICAgICAgICB2YWx1ZSA9XG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgICAgICA6IFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJiBudWxsICE9PSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgPyBcIntcIiArIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHZhbHVlKSArIFwifVwiXG4gICAgICAgICAgICAgICAgICA6IFwie1wiICsgZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZSh2YWx1ZSkgKyBcIn1cIjtcbiAgICAgICAgICAgIFwiXCIgKyBpID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgICAgICAgPyAoKHN0YXJ0ID0gb2JqS2luZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIChsZW5ndGggPSB2YWx1ZS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIChvYmpLaW5kICs9IHZhbHVlKSlcbiAgICAgICAgICAgICAgOiAob2JqS2luZCA9XG4gICAgICAgICAgICAgICAgICAxNSA+IHZhbHVlLmxlbmd0aCAmJiA0MCA+IG9iaktpbmQubGVuZ3RoICsgdmFsdWUubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gb2JqS2luZCArIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogb2JqS2luZCArIFwiey4uLn1cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iaktpbmQgKz0gXCI8L1wiICsgZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKSArIFwiPlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iaktpbmQgPSBcIltcIjtcbiAgICAgICAgICBmb3IgKHR5cGUgPSAwOyB0eXBlIDwgb2JqZWN0T3JBcnJheS5sZW5ndGg7IHR5cGUrKylcbiAgICAgICAgICAgIDAgPCB0eXBlICYmIChvYmpLaW5kICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgIChpID0gb2JqZWN0T3JBcnJheVt0eXBlXSksXG4gICAgICAgICAgICAgIChpID1cbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgaSAmJiBudWxsICE9PSBpXG4gICAgICAgICAgICAgICAgICA/IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKGkpXG4gICAgICAgICAgICAgICAgICA6IGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UoaSkpLFxuICAgICAgICAgICAgICBcIlwiICsgdHlwZSA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgICAgICAgICAgPyAoKHN0YXJ0ID0gb2JqS2luZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgKGxlbmd0aCA9IGkubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIChvYmpLaW5kICs9IGkpKVxuICAgICAgICAgICAgICAgIDogKG9iaktpbmQgPVxuICAgICAgICAgICAgICAgICAgICAxMCA+IGkubGVuZ3RoICYmIDQwID4gb2JqS2luZC5sZW5ndGggKyBpLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgID8gb2JqS2luZCArIGlcbiAgICAgICAgICAgICAgICAgICAgICA6IG9iaktpbmQgKyBcIi4uLlwiKTtcbiAgICAgICAgICBvYmpLaW5kICs9IFwiXVwiO1xuICAgICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3RPckFycmF5LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpXG4gICAgICAgIG9iaktpbmQgPSBcIjxcIiArIGRlc2NyaWJlRWxlbWVudFR5cGUob2JqZWN0T3JBcnJheS50eXBlKSArIFwiLz5cIjtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAob2JqZWN0T3JBcnJheS4kJHR5cGVvZiA9PT0gQ0xJRU5UX1JFRkVSRU5DRV9UQUcpIHJldHVybiBcImNsaWVudFwiO1xuICAgICAgICBpZiAoanN4UHJvcHNQYXJlbnRzLmhhcyhvYmplY3RPckFycmF5KSkge1xuICAgICAgICAgIG9iaktpbmQgPSBqc3hQcm9wc1BhcmVudHMuZ2V0KG9iamVjdE9yQXJyYXkpO1xuICAgICAgICAgIG9iaktpbmQgPSBcIjxcIiArIChkZXNjcmliZUVsZW1lbnRUeXBlKG9iaktpbmQpIHx8IFwiLi4uXCIpO1xuICAgICAgICAgIHR5cGUgPSBPYmplY3Qua2V5cyhvYmplY3RPckFycmF5KTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb2JqS2luZCArPSBcIiBcIjtcbiAgICAgICAgICAgIHZhbHVlID0gdHlwZVtpXTtcbiAgICAgICAgICAgIG9iaktpbmQgKz0gZGVzY3JpYmVLZXlGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgXCI9XCI7XG4gICAgICAgICAgICB2YXIgX3ZhbHVlMiA9IG9iamVjdE9yQXJyYXlbdmFsdWVdO1xuICAgICAgICAgICAgdmFyIF9zdWJzdHIyID1cbiAgICAgICAgICAgICAgdmFsdWUgPT09IGV4cGFuZGVkTmFtZSAmJlxuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgX3ZhbHVlMiAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBfdmFsdWUyXG4gICAgICAgICAgICAgICAgPyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShfdmFsdWUyKVxuICAgICAgICAgICAgICAgIDogZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZShfdmFsdWUyKTtcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBfdmFsdWUyICYmIChfc3Vic3RyMiA9IFwie1wiICsgX3N1YnN0cjIgKyBcIn1cIik7XG4gICAgICAgICAgICB2YWx1ZSA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgICAgICAgID8gKChzdGFydCA9IG9iaktpbmQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAobGVuZ3RoID0gX3N1YnN0cjIubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAob2JqS2luZCArPSBfc3Vic3RyMikpXG4gICAgICAgICAgICAgIDogKG9iaktpbmQgPVxuICAgICAgICAgICAgICAgICAgMTAgPiBfc3Vic3RyMi5sZW5ndGggJiYgNDAgPiBvYmpLaW5kLmxlbmd0aCArIF9zdWJzdHIyLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICA/IG9iaktpbmQgKyBfc3Vic3RyMlxuICAgICAgICAgICAgICAgICAgICA6IG9iaktpbmQgKyBcIi4uLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqS2luZCArPSBcIj5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpLaW5kID0gXCJ7XCI7XG4gICAgICAgICAgdHlwZSA9IE9iamVjdC5rZXlzKG9iamVjdE9yQXJyYXkpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgMCA8IGkgJiYgKG9iaktpbmQgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgKHZhbHVlID0gdHlwZVtpXSksXG4gICAgICAgICAgICAgIChvYmpLaW5kICs9IGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKHZhbHVlKSArIFwiOiBcIiksXG4gICAgICAgICAgICAgIChfdmFsdWUyID0gb2JqZWN0T3JBcnJheVt2YWx1ZV0pLFxuICAgICAgICAgICAgICAoX3ZhbHVlMiA9XG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIF92YWx1ZTIgJiYgbnVsbCAhPT0gX3ZhbHVlMlxuICAgICAgICAgICAgICAgICAgPyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShfdmFsdWUyKVxuICAgICAgICAgICAgICAgICAgOiBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKF92YWx1ZTIpKSxcbiAgICAgICAgICAgICAgdmFsdWUgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICAgICAgICAgID8gKChzdGFydCA9IG9iaktpbmQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIChsZW5ndGggPSBfdmFsdWUyLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAob2JqS2luZCArPSBfdmFsdWUyKSlcbiAgICAgICAgICAgICAgICA6IChvYmpLaW5kID1cbiAgICAgICAgICAgICAgICAgICAgMTAgPiBfdmFsdWUyLmxlbmd0aCAmJiA0MCA+IG9iaktpbmQubGVuZ3RoICsgX3ZhbHVlMi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICA/IG9iaktpbmQgKyBfdmFsdWUyXG4gICAgICAgICAgICAgICAgICAgICAgOiBvYmpLaW5kICsgXCIuLi5cIik7XG4gICAgICAgICAgb2JqS2luZCArPSBcIn1cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgID8gb2JqS2luZFxuICAgICAgICA6IC0xIDwgc3RhcnQgJiYgMCA8IGxlbmd0aFxuICAgICAgICAgID8gKChvYmplY3RPckFycmF5ID0gXCIgXCIucmVwZWF0KHN0YXJ0KSArIFwiXlwiLnJlcGVhdChsZW5ndGgpKSxcbiAgICAgICAgICAgIFwiXFxuICBcIiArIG9iaktpbmQgKyBcIlxcbiAgXCIgKyBvYmplY3RPckFycmF5KVxuICAgICAgICAgIDogXCJcXG4gIFwiICsgb2JqS2luZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VyaWFsaXplTnVtYmVyKG51bWJlcikge1xuICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShudW1iZXIpXG4gICAgICAgID8gMCA9PT0gbnVtYmVyICYmIC1JbmZpbml0eSA9PT0gMSAvIG51bWJlclxuICAgICAgICAgID8gXCIkLTBcIlxuICAgICAgICAgIDogbnVtYmVyXG4gICAgICAgIDogSW5maW5pdHkgPT09IG51bWJlclxuICAgICAgICAgID8gXCIkSW5maW5pdHlcIlxuICAgICAgICAgIDogLUluZmluaXR5ID09PSBudW1iZXJcbiAgICAgICAgICAgID8gXCIkLUluZmluaXR5XCJcbiAgICAgICAgICAgIDogXCIkTmFOXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NSZXBseShcbiAgICAgIHJvb3QsXG4gICAgICBmb3JtRmllbGRQcmVmaXgsXG4gICAgICB0ZW1wb3JhcnlSZWZlcmVuY2VzLFxuICAgICAgcmVzb2x2ZSxcbiAgICAgIHJlamVjdFxuICAgICkge1xuICAgICAgZnVuY3Rpb24gc2VyaWFsaXplVHlwZWRBcnJheSh0YWcsIHR5cGVkQXJyYXkpIHtcbiAgICAgICAgdHlwZWRBcnJheSA9IG5ldyBCbG9iKFtcbiAgICAgICAgICBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgIHR5cGVkQXJyYXkuYnVmZmVyLFxuICAgICAgICAgICAgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgdHlwZWRBcnJheS5ieXRlTGVuZ3RoXG4gICAgICAgICAgKVxuICAgICAgICBdKTtcbiAgICAgICAgdmFyIGJsb2JJZCA9IG5leHRQYXJ0SWQrKztcbiAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsgYmxvYklkLCB0eXBlZEFycmF5KTtcbiAgICAgICAgcmV0dXJuIFwiJFwiICsgdGFnICsgYmxvYklkLnRvU3RyaW5nKDE2KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZUJpbmFyeVJlYWRlcihyZWFkZXIpIHtcbiAgICAgICAgZnVuY3Rpb24gcHJvZ3Jlc3MoZW50cnkpIHtcbiAgICAgICAgICBlbnRyeS5kb25lXG4gICAgICAgICAgICA/ICgoZW50cnkgPSBuZXh0UGFydElkKyspLFxuICAgICAgICAgICAgICBkYXRhLmFwcGVuZChmb3JtRmllbGRQcmVmaXggKyBlbnRyeSwgbmV3IEJsb2IoYnVmZmVyKSksXG4gICAgICAgICAgICAgIGRhdGEuYXBwZW5kKFxuICAgICAgICAgICAgICAgIGZvcm1GaWVsZFByZWZpeCArIHN0cmVhbUlkLFxuICAgICAgICAgICAgICAgICdcIiRvJyArIGVudHJ5LnRvU3RyaW5nKDE2KSArICdcIidcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgZGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsgc3RyZWFtSWQsIFwiQ1wiKSxcbiAgICAgICAgICAgICAgcGVuZGluZ1BhcnRzLS0sXG4gICAgICAgICAgICAgIDAgPT09IHBlbmRpbmdQYXJ0cyAmJiByZXNvbHZlKGRhdGEpKVxuICAgICAgICAgICAgOiAoYnVmZmVyLnB1c2goZW50cnkudmFsdWUpLFxuICAgICAgICAgICAgICByZWFkZXIucmVhZChuZXcgVWludDhBcnJheSgxMDI0KSkudGhlbihwcm9ncmVzcywgcmVqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpO1xuICAgICAgICB2YXIgZGF0YSA9IGZvcm1EYXRhO1xuICAgICAgICBwZW5kaW5nUGFydHMrKztcbiAgICAgICAgdmFyIHN0cmVhbUlkID0gbmV4dFBhcnRJZCsrLFxuICAgICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgICAgICByZWFkZXIucmVhZChuZXcgVWludDhBcnJheSgxMDI0KSkudGhlbihwcm9ncmVzcywgcmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIFwiJHJcIiArIHN0cmVhbUlkLnRvU3RyaW5nKDE2KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZVJlYWRlcihyZWFkZXIpIHtcbiAgICAgICAgZnVuY3Rpb24gcHJvZ3Jlc3MoZW50cnkpIHtcbiAgICAgICAgICBpZiAoZW50cnkuZG9uZSlcbiAgICAgICAgICAgIGRhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIHN0cmVhbUlkLCBcIkNcIiksXG4gICAgICAgICAgICAgIHBlbmRpbmdQYXJ0cy0tLFxuICAgICAgICAgICAgICAwID09PSBwZW5kaW5nUGFydHMgJiYgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgcGFydEpTT04gPSBKU09OLnN0cmluZ2lmeShlbnRyeS52YWx1ZSwgcmVzb2x2ZVRvSlNPTik7XG4gICAgICAgICAgICAgIGRhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIHN0cmVhbUlkLCBwYXJ0SlNPTik7XG4gICAgICAgICAgICAgIHJlYWRlci5yZWFkKCkudGhlbihwcm9ncmVzcywgcmVqZWN0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bGwgPT09IGZvcm1EYXRhICYmIChmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpKTtcbiAgICAgICAgdmFyIGRhdGEgPSBmb3JtRGF0YTtcbiAgICAgICAgcGVuZGluZ1BhcnRzKys7XG4gICAgICAgIHZhciBzdHJlYW1JZCA9IG5leHRQYXJ0SWQrKztcbiAgICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKHByb2dyZXNzLCByZWplY3QpO1xuICAgICAgICByZXR1cm4gXCIkUlwiICsgc3RyZWFtSWQudG9TdHJpbmcoMTYpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc2VyaWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGJpbmFyeVJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoeyBtb2RlOiBcImJ5b2JcIiB9KTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIHJldHVybiBzZXJpYWxpemVSZWFkZXIoc3RyZWFtLmdldFJlYWRlcigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplQmluYXJ5UmVhZGVyKGJpbmFyeVJlYWRlcik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzZXJpYWxpemVBc3luY0l0ZXJhYmxlKGl0ZXJhYmxlLCBpdGVyYXRvcikge1xuICAgICAgICBmdW5jdGlvbiBwcm9ncmVzcyhlbnRyeSkge1xuICAgICAgICAgIGlmIChlbnRyeS5kb25lKSB7XG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSBlbnRyeS52YWx1ZSlcbiAgICAgICAgICAgICAgZGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsgc3RyZWFtSWQsIFwiQ1wiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydEpTT04gPSBKU09OLnN0cmluZ2lmeShlbnRyeS52YWx1ZSwgcmVzb2x2ZVRvSlNPTik7XG4gICAgICAgICAgICAgICAgZGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsgc3RyZWFtSWQsIFwiQ1wiICsgcGFydEpTT04pO1xuICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVuZGluZ1BhcnRzLS07XG4gICAgICAgICAgICAwID09PSBwZW5kaW5nUGFydHMgJiYgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBfcGFydEpTT04gPSBKU09OLnN0cmluZ2lmeShlbnRyeS52YWx1ZSwgcmVzb2x2ZVRvSlNPTik7XG4gICAgICAgICAgICAgIGRhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIHN0cmVhbUlkLCBfcGFydEpTT04pO1xuICAgICAgICAgICAgICBpdGVyYXRvci5uZXh0KCkudGhlbihwcm9ncmVzcywgcmVqZWN0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICByZWplY3QoeCQwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBudWxsID09PSBmb3JtRGF0YSAmJiAoZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKSk7XG4gICAgICAgIHZhciBkYXRhID0gZm9ybURhdGE7XG4gICAgICAgIHBlbmRpbmdQYXJ0cysrO1xuICAgICAgICB2YXIgc3RyZWFtSWQgPSBuZXh0UGFydElkKys7XG4gICAgICAgIGl0ZXJhYmxlID0gaXRlcmFibGUgPT09IGl0ZXJhdG9yO1xuICAgICAgICBpdGVyYXRvci5uZXh0KCkudGhlbihwcm9ncmVzcywgcmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIFwiJFwiICsgKGl0ZXJhYmxlID8gXCJ4XCIgOiBcIlhcIikgKyBzdHJlYW1JZC50b1N0cmluZygxNik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZXNvbHZlVG9KU09OKGtleSwgdmFsdWUpIHtcbiAgICAgICAgXCJfX3Byb3RvX19cIiA9PT0ga2V5ICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgbm90IHRvIHNlcmlhbGl6ZSBhbiBvYmplY3Qgd2l0aCBvd24gcHJvcGVydHkgYF9fcHJvdG9fX2AuIFdoZW4gcGFyc2VkIHRoaXMgcHJvcGVydHkgd2lsbCBiZSBvbWl0dGVkLiVzXCIsXG4gICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZSh0aGlzLCBrZXkpXG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIG9yaWdpbmFsVmFsdWUgPSB0aGlzW2tleV07XG4gICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvcmlnaW5hbFZhbHVlIHx8XG4gICAgICAgICAgb3JpZ2luYWxWYWx1ZSA9PT0gdmFsdWUgfHxcbiAgICAgICAgICBvcmlnaW5hbFZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICAgIChcIk9iamVjdFwiICE9PSBvYmplY3ROYW1lKG9yaWdpbmFsVmFsdWUpXG4gICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJPbmx5IHBsYWluIG9iamVjdHMgY2FuIGJlIHBhc3NlZCB0byBTZXJ2ZXIgRnVuY3Rpb25zIGZyb20gdGhlIENsaWVudC4gJXMgb2JqZWN0cyBhcmUgbm90IHN1cHBvcnRlZC4lc1wiLFxuICAgICAgICAgICAgICAgIG9iamVjdE5hbWUob3JpZ2luYWxWYWx1ZSksXG4gICAgICAgICAgICAgICAgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UodGhpcywga2V5KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJPbmx5IHBsYWluIG9iamVjdHMgY2FuIGJlIHBhc3NlZCB0byBTZXJ2ZXIgRnVuY3Rpb25zIGZyb20gdGhlIENsaWVudC4gT2JqZWN0cyB3aXRoIHRvSlNPTiBtZXRob2RzIGFyZSBub3Qgc3VwcG9ydGVkLiBDb252ZXJ0IGl0IG1hbnVhbGx5IHRvIGEgc2ltcGxlIHZhbHVlIGJlZm9yZSBwYXNzaW5nIGl0IHRvIHByb3BzLiVzXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UodGhpcywga2V5KVxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgaWYgKG51bGwgPT09IHZhbHVlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIHN3aXRjaCAodmFsdWUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSB0ZW1wb3JhcnlSZWZlcmVuY2VzICYmIC0xID09PSBrZXkuaW5kZXhPZihcIjpcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50UmVmZXJlbmNlID0gd3JpdHRlbk9iamVjdHMuZ2V0KHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHBhcmVudFJlZmVyZW5jZSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIHRlbXBvcmFyeVJlZmVyZW5jZXMuc2V0KHBhcmVudFJlZmVyZW5jZSArIFwiOlwiICsga2V5LCB2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIFwiJFRcIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlJlYWN0IEVsZW1lbnQgY2Fubm90IGJlIHBhc3NlZCB0byBTZXJ2ZXIgRnVuY3Rpb25zIGZyb20gdGhlIENsaWVudCB3aXRob3V0IGEgdGVtcG9yYXJ5IHJlZmVyZW5jZSBzZXQuIFBhc3MgYSBUZW1wb3JhcnlSZWZlcmVuY2VTZXQgdG8gdGhlIG9wdGlvbnMuXCIgK1xuICAgICAgICAgICAgICAgICAgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UodGhpcywga2V5KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIG9yaWdpbmFsVmFsdWUgPSB2YWx1ZS5fcGF5bG9hZDtcbiAgICAgICAgICAgICAgdmFyIGluaXQgPSB2YWx1ZS5faW5pdDtcbiAgICAgICAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpO1xuICAgICAgICAgICAgICBwZW5kaW5nUGFydHMrKztcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJlbnRSZWZlcmVuY2UgPSBpbml0KG9yaWdpbmFsVmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhciBsYXp5SWQgPSBuZXh0UGFydElkKyssXG4gICAgICAgICAgICAgICAgICBwYXJ0SlNPTiA9IHNlcmlhbGl6ZU1vZGVsKHBhcmVudFJlZmVyZW5jZSwgbGF6eUlkKTtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsgbGF6eUlkLCBwYXJ0SlNPTik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiJFwiICsgbGF6eUlkLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB4ICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSB4ICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4LnRoZW5cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHBlbmRpbmdQYXJ0cysrO1xuICAgICAgICAgICAgICAgICAgdmFyIF9sYXp5SWQgPSBuZXh0UGFydElkKys7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRSZWZlcmVuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIF9wYXJ0SlNPTjIgPSBzZXJpYWxpemVNb2RlbCh2YWx1ZSwgX2xhenlJZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGF0YSA9IGZvcm1EYXRhO1xuICAgICAgICAgICAgICAgICAgICAgIF9kYXRhLmFwcGVuZChmb3JtRmllbGRQcmVmaXggKyBfbGF6eUlkLCBfcGFydEpTT04yKTtcbiAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUGFydHMtLTtcbiAgICAgICAgICAgICAgICAgICAgICAwID09PSBwZW5kaW5nUGFydHMgJiYgcmVzb2x2ZShfZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgeC50aGVuKHBhcmVudFJlZmVyZW5jZSwgcGFyZW50UmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIiRcIiArIF9sYXp5SWQudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWplY3QoeCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ1BhcnRzLS07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50UmVmZXJlbmNlID0gd3JpdHRlbk9iamVjdHMuZ2V0KHZhbHVlKTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUudGhlbikge1xuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gcGFyZW50UmVmZXJlbmNlKVxuICAgICAgICAgICAgICBpZiAobW9kZWxSb290ID09PSB2YWx1ZSkgbW9kZWxSb290ID0gbnVsbDtcbiAgICAgICAgICAgICAgZWxzZSByZXR1cm4gcGFyZW50UmVmZXJlbmNlO1xuICAgICAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpO1xuICAgICAgICAgICAgcGVuZGluZ1BhcnRzKys7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZUlkID0gbmV4dFBhcnRJZCsrO1xuICAgICAgICAgICAga2V5ID0gXCIkQFwiICsgcHJvbWlzZUlkLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHdyaXR0ZW5PYmplY3RzLnNldCh2YWx1ZSwga2V5KTtcbiAgICAgICAgICAgIHZhbHVlLnRoZW4oZnVuY3Rpb24gKHBhcnRWYWx1ZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1JlZmVyZW5jZSA9IHdyaXR0ZW5PYmplY3RzLmdldChwYXJ0VmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhciBfcGFydEpTT04zID1cbiAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gcHJldmlvdXNSZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeShwcmV2aW91c1JlZmVyZW5jZSlcbiAgICAgICAgICAgICAgICAgICAgOiBzZXJpYWxpemVNb2RlbChwYXJ0VmFsdWUsIHByb21pc2VJZCk7XG4gICAgICAgICAgICAgICAgcGFydFZhbHVlID0gZm9ybURhdGE7XG4gICAgICAgICAgICAgICAgcGFydFZhbHVlLmFwcGVuZChmb3JtRmllbGRQcmVmaXggKyBwcm9taXNlSWQsIF9wYXJ0SlNPTjMpO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdQYXJ0cy0tO1xuICAgICAgICAgICAgICAgIDAgPT09IHBlbmRpbmdQYXJ0cyAmJiByZXNvbHZlKHBhcnRWYWx1ZSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gcGFyZW50UmVmZXJlbmNlKVxuICAgICAgICAgICAgaWYgKG1vZGVsUm9vdCA9PT0gdmFsdWUpIG1vZGVsUm9vdCA9IG51bGw7XG4gICAgICAgICAgICBlbHNlIHJldHVybiBwYXJlbnRSZWZlcmVuY2U7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgLTEgPT09IGtleS5pbmRleE9mKFwiOlwiKSAmJlxuICAgICAgICAgICAgICAoKHBhcmVudFJlZmVyZW5jZSA9IHdyaXR0ZW5PYmplY3RzLmdldCh0aGlzKSksXG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gcGFyZW50UmVmZXJlbmNlICYmXG4gICAgICAgICAgICAgICAgKChwYXJlbnRSZWZlcmVuY2UgPSBwYXJlbnRSZWZlcmVuY2UgKyBcIjpcIiArIGtleSksXG4gICAgICAgICAgICAgICAgd3JpdHRlbk9iamVjdHMuc2V0KHZhbHVlLCBwYXJlbnRSZWZlcmVuY2UpLFxuICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gdGVtcG9yYXJ5UmVmZXJlbmNlcyAmJlxuICAgICAgICAgICAgICAgICAgdGVtcG9yYXJ5UmVmZXJlbmNlcy5zZXQocGFyZW50UmVmZXJlbmNlLCB2YWx1ZSkpKTtcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgICAgIG51bGwgPT09IGZvcm1EYXRhICYmIChmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpKTtcbiAgICAgICAgICAgIHZhciBfZGF0YTMgPSBmb3JtRGF0YTtcbiAgICAgICAgICAgIGtleSA9IG5leHRQYXJ0SWQrKztcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBmb3JtRmllbGRQcmVmaXggKyBrZXkgKyBcIl9cIjtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKG9yaWdpbmFsVmFsdWUsIG9yaWdpbmFsS2V5KSB7XG4gICAgICAgICAgICAgIF9kYXRhMy5hcHBlbmQocHJlZml4ICsgb3JpZ2luYWxLZXksIG9yaWdpbmFsVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gXCIkS1wiICsga2V5LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGtleSA9IG5leHRQYXJ0SWQrKyksXG4gICAgICAgICAgICAgIChwYXJlbnRSZWZlcmVuY2UgPSBzZXJpYWxpemVNb2RlbChBcnJheS5mcm9tKHZhbHVlKSwga2V5KSksXG4gICAgICAgICAgICAgIG51bGwgPT09IGZvcm1EYXRhICYmIChmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpKSxcbiAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIGtleSwgcGFyZW50UmVmZXJlbmNlKSxcbiAgICAgICAgICAgICAgXCIkUVwiICsga2V5LnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoa2V5ID0gbmV4dFBhcnRJZCsrKSxcbiAgICAgICAgICAgICAgKHBhcmVudFJlZmVyZW5jZSA9IHNlcmlhbGl6ZU1vZGVsKEFycmF5LmZyb20odmFsdWUpLCBrZXkpKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpLFxuICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsga2V5LCBwYXJlbnRSZWZlcmVuY2UpLFxuICAgICAgICAgICAgICBcIiRXXCIgKyBrZXkudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGtleSA9IG5ldyBCbG9iKFt2YWx1ZV0pKSxcbiAgICAgICAgICAgICAgKHBhcmVudFJlZmVyZW5jZSA9IG5leHRQYXJ0SWQrKyksXG4gICAgICAgICAgICAgIG51bGwgPT09IGZvcm1EYXRhICYmIChmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpKSxcbiAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIHBhcmVudFJlZmVyZW5jZSwga2V5KSxcbiAgICAgICAgICAgICAgXCIkQVwiICsgcGFyZW50UmVmZXJlbmNlLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZWRBcnJheShcIk9cIiwgdmFsdWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZWRBcnJheShcIm9cIiwgdmFsdWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGVkQXJyYXkoXCJVXCIsIHZhbHVlKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnQxNkFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGVkQXJyYXkoXCJTXCIsIHZhbHVlKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50MTZBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KFwic1wiLCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW50MzJBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KFwiTFwiLCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDMyQXJyYXkpXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZWRBcnJheShcImxcIiwgdmFsdWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KFwiR1wiLCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGVkQXJyYXkoXCJnXCIsIHZhbHVlKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaWdJbnQ2NEFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGVkQXJyYXkoXCJNXCIsIHZhbHVlKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaWdVaW50NjRBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KFwibVwiLCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXcpIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KFwiVlwiLCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEJsb2IgJiYgdmFsdWUgaW5zdGFuY2VvZiBCbG9iKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpLFxuICAgICAgICAgICAgICAoa2V5ID0gbmV4dFBhcnRJZCsrKSxcbiAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIGtleSwgdmFsdWUpLFxuICAgICAgICAgICAgICBcIiRCXCIgKyBrZXkudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmICgocGFyZW50UmVmZXJlbmNlID0gZ2V0SXRlcmF0b3JGbih2YWx1ZSkpKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHBhcmVudFJlZmVyZW5jZSA9IHBhcmVudFJlZmVyZW5jZS5jYWxsKHZhbHVlKSksXG4gICAgICAgICAgICAgIHBhcmVudFJlZmVyZW5jZSA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgICA/ICgoa2V5ID0gbmV4dFBhcnRJZCsrKSxcbiAgICAgICAgICAgICAgICAgIChwYXJlbnRSZWZlcmVuY2UgPSBzZXJpYWxpemVNb2RlbChcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkuZnJvbShwYXJlbnRSZWZlcmVuY2UpLFxuICAgICAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpLFxuICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIGtleSwgcGFyZW50UmVmZXJlbmNlKSxcbiAgICAgICAgICAgICAgICAgIFwiJGlcIiArIGtleS50b1N0cmluZygxNikpXG4gICAgICAgICAgICAgICAgOiBBcnJheS5mcm9tKHBhcmVudFJlZmVyZW5jZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgUmVhZGFibGVTdHJlYW0gJiZcbiAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1cbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplUmVhZGFibGVTdHJlYW0odmFsdWUpO1xuICAgICAgICAgIHBhcmVudFJlZmVyZW5jZSA9IHZhbHVlW0FTWU5DX0lURVJBVE9SXTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGFyZW50UmVmZXJlbmNlKVxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUFzeW5jSXRlcmFibGUodmFsdWUsIHBhcmVudFJlZmVyZW5jZS5jYWxsKHZhbHVlKSk7XG4gICAgICAgICAgcGFyZW50UmVmZXJlbmNlID0gZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHBhcmVudFJlZmVyZW5jZSAhPT0gT2JqZWN0UHJvdG90eXBlICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gcGFyZW50UmVmZXJlbmNlIHx8XG4gICAgICAgICAgICAgIG51bGwgIT09IGdldFByb3RvdHlwZU9mKHBhcmVudFJlZmVyZW5jZSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSB0ZW1wb3JhcnlSZWZlcmVuY2VzKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIk9ubHkgcGxhaW4gb2JqZWN0cywgYW5kIGEgZmV3IGJ1aWx0LWlucywgY2FuIGJlIHBhc3NlZCB0byBTZXJ2ZXIgRnVuY3Rpb25zLiBDbGFzc2VzIG9yIG51bGwgcHJvdG90eXBlcyBhcmUgbm90IHN1cHBvcnRlZC5cIiArXG4gICAgICAgICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZSh0aGlzLCBrZXkpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gXCIkVFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFXG4gICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJSZWFjdCBDb250ZXh0IFByb3ZpZGVycyBjYW5ub3QgYmUgcGFzc2VkIHRvIFNlcnZlciBGdW5jdGlvbnMgZnJvbSB0aGUgQ2xpZW50LiVzXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UodGhpcywga2V5KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IFwiT2JqZWN0XCIgIT09IG9iamVjdE5hbWUodmFsdWUpXG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiT25seSBwbGFpbiBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdG8gU2VydmVyIEZ1bmN0aW9ucyBmcm9tIHRoZSBDbGllbnQuICVzIG9iamVjdHMgYXJlIG5vdCBzdXBwb3J0ZWQuJXNcIixcbiAgICAgICAgICAgICAgICAgIG9iamVjdE5hbWUodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UodGhpcywga2V5KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBpc1NpbXBsZU9iamVjdCh2YWx1ZSlcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiZcbiAgICAgICAgICAgICAgICAgICgocGFyZW50UmVmZXJlbmNlID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSkpLFxuICAgICAgICAgICAgICAgICAgMCA8IHBhcmVudFJlZmVyZW5jZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIk9ubHkgcGxhaW4gb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHRvIFNlcnZlciBGdW5jdGlvbnMgZnJvbSB0aGUgQ2xpZW50LiBPYmplY3RzIHdpdGggc3ltYm9sIHByb3BlcnRpZXMgbGlrZSAlcyBhcmUgbm90IHN1cHBvcnRlZC4lc1wiLFxuICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJlZmVyZW5jZVswXS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZSh0aGlzLCBrZXkpXG4gICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIk9ubHkgcGxhaW4gb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHRvIFNlcnZlciBGdW5jdGlvbnMgZnJvbSB0aGUgQ2xpZW50LiBDbGFzc2VzIG9yIG90aGVyIG9iamVjdHMgd2l0aCBtZXRob2RzIGFyZSBub3Qgc3VwcG9ydGVkLiVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHRoaXMsIGtleSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoXCJaXCIgPT09IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICYmIHRoaXNba2V5XSBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgICAgICByZXR1cm4gXCIkRFwiICsgdmFsdWU7XG4gICAgICAgICAga2V5ID0gXCIkXCIgPT09IHZhbHVlWzBdID8gXCIkXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiYm9vbGVhblwiID09PSB0eXBlb2YgdmFsdWUpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgaWYgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB2YWx1ZSkgcmV0dXJuIHNlcmlhbGl6ZU51bWJlcih2YWx1ZSk7XG4gICAgICAgIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgdmFsdWUpIHJldHVybiBcIiR1bmRlZmluZWRcIjtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgcGFyZW50UmVmZXJlbmNlID0ga25vd25TZXJ2ZXJSZWZlcmVuY2VzLmdldCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gcGFyZW50UmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBrZXkgPSB3cml0dGVuT2JqZWN0cy5nZXQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0ga2V5KSByZXR1cm4ga2V5O1xuICAgICAgICAgICAga2V5ID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgIHsgaWQ6IHBhcmVudFJlZmVyZW5jZS5pZCwgYm91bmQ6IHBhcmVudFJlZmVyZW5jZS5ib3VuZCB9LFxuICAgICAgICAgICAgICByZXNvbHZlVG9KU09OXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpO1xuICAgICAgICAgICAgcGFyZW50UmVmZXJlbmNlID0gbmV4dFBhcnRJZCsrO1xuICAgICAgICAgICAgZm9ybURhdGEuc2V0KGZvcm1GaWVsZFByZWZpeCArIHBhcmVudFJlZmVyZW5jZSwga2V5KTtcbiAgICAgICAgICAgIGtleSA9IFwiJGhcIiArIHBhcmVudFJlZmVyZW5jZS50b1N0cmluZygxNik7XG4gICAgICAgICAgICB3cml0dGVuT2JqZWN0cy5zZXQodmFsdWUsIGtleSk7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB2b2lkIDAgIT09IHRlbXBvcmFyeVJlZmVyZW5jZXMgJiZcbiAgICAgICAgICAgIC0xID09PSBrZXkuaW5kZXhPZihcIjpcIikgJiZcbiAgICAgICAgICAgICgocGFyZW50UmVmZXJlbmNlID0gd3JpdHRlbk9iamVjdHMuZ2V0KHRoaXMpKSxcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gcGFyZW50UmVmZXJlbmNlKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHRlbXBvcmFyeVJlZmVyZW5jZXMuc2V0KHBhcmVudFJlZmVyZW5jZSArIFwiOlwiICsga2V5LCB2YWx1ZSksIFwiJFRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiQ2xpZW50IEZ1bmN0aW9ucyBjYW5ub3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIFNlcnZlciBGdW5jdGlvbnMuIE9ubHkgRnVuY3Rpb25zIHBhc3NlZCBmcm9tIHRoZSBTZXJ2ZXIgY2FuIGJlIHBhc3NlZCBiYWNrIGFnYWluLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdm9pZCAwICE9PSB0ZW1wb3JhcnlSZWZlcmVuY2VzICYmXG4gICAgICAgICAgICAtMSA9PT0ga2V5LmluZGV4T2YoXCI6XCIpICYmXG4gICAgICAgICAgICAoKHBhcmVudFJlZmVyZW5jZSA9IHdyaXR0ZW5PYmplY3RzLmdldCh0aGlzKSksXG4gICAgICAgICAgICB2b2lkIDAgIT09IHBhcmVudFJlZmVyZW5jZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB0ZW1wb3JhcnlSZWZlcmVuY2VzLnNldChwYXJlbnRSZWZlcmVuY2UgKyBcIjpcIiArIGtleSwgdmFsdWUpLCBcIiRUXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlN5bWJvbHMgY2Fubm90IGJlIHBhc3NlZCB0byBhIFNlcnZlciBGdW5jdGlvbiB3aXRob3V0IGEgdGVtcG9yYXJ5IHJlZmVyZW5jZSBzZXQuIFBhc3MgYSBUZW1wb3JhcnlSZWZlcmVuY2VTZXQgdG8gdGhlIG9wdGlvbnMuXCIgK1xuICAgICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZSh0aGlzLCBrZXkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHZhbHVlKSByZXR1cm4gXCIkblwiICsgdmFsdWUudG9TdHJpbmcoMTApO1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlR5cGUgXCIgK1xuICAgICAgICAgICAgdHlwZW9mIHZhbHVlICtcbiAgICAgICAgICAgIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYXMgYW4gYXJndW1lbnQgdG8gYSBTZXJ2ZXIgRnVuY3Rpb24uXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZU1vZGVsKG1vZGVsLCBpZCkge1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgbW9kZWwgJiZcbiAgICAgICAgICBudWxsICE9PSBtb2RlbCAmJlxuICAgICAgICAgICgoaWQgPSBcIiRcIiArIGlkLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgd3JpdHRlbk9iamVjdHMuc2V0KG1vZGVsLCBpZCksXG4gICAgICAgICAgdm9pZCAwICE9PSB0ZW1wb3JhcnlSZWZlcmVuY2VzICYmIHRlbXBvcmFyeVJlZmVyZW5jZXMuc2V0KGlkLCBtb2RlbCkpO1xuICAgICAgICBtb2RlbFJvb3QgPSBtb2RlbDtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1vZGVsLCByZXNvbHZlVG9KU09OKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0UGFydElkID0gMSxcbiAgICAgICAgcGVuZGluZ1BhcnRzID0gMCxcbiAgICAgICAgZm9ybURhdGEgPSBudWxsLFxuICAgICAgICB3cml0dGVuT2JqZWN0cyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICAgIG1vZGVsUm9vdCA9IHJvb3QsXG4gICAgICAgIGpzb24gPSBzZXJpYWxpemVNb2RlbChyb290LCAwKTtcbiAgICAgIG51bGwgPT09IGZvcm1EYXRhXG4gICAgICAgID8gcmVzb2x2ZShqc29uKVxuICAgICAgICA6IChmb3JtRGF0YS5zZXQoZm9ybUZpZWxkUHJlZml4ICsgXCIwXCIsIGpzb24pLFxuICAgICAgICAgIDAgPT09IHBlbmRpbmdQYXJ0cyAmJiByZXNvbHZlKGZvcm1EYXRhKSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAwIDwgcGVuZGluZ1BhcnRzICYmXG4gICAgICAgICAgKChwZW5kaW5nUGFydHMgPSAwKSxcbiAgICAgICAgICBudWxsID09PSBmb3JtRGF0YSA/IHJlc29sdmUoanNvbikgOiByZXNvbHZlKGZvcm1EYXRhKSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGYWtlU2VydmVyRnVuY3Rpb24oXG4gICAgICBuYW1lLFxuICAgICAgZmlsZW5hbWUsXG4gICAgICBzb3VyY2VNYXAsXG4gICAgICBsaW5lLFxuICAgICAgY29sLFxuICAgICAgZW52aXJvbm1lbnROYW1lLFxuICAgICAgaW5uZXJGdW5jdGlvblxuICAgICkge1xuICAgICAgbmFtZSB8fCAobmFtZSA9IFwiPGFub255bW91cz5cIik7XG4gICAgICB2YXIgZW5jb2RlZE5hbWUgPSBKU09OLnN0cmluZ2lmeShuYW1lKTtcbiAgICAgIDEgPj0gbGluZVxuICAgICAgICA/ICgobGluZSA9IGVuY29kZWROYW1lLmxlbmd0aCArIDcpLFxuICAgICAgICAgIChjb2wgPVxuICAgICAgICAgICAgXCJzPT4oe1wiICtcbiAgICAgICAgICAgIGVuY29kZWROYW1lICtcbiAgICAgICAgICAgIFwiIFwiLnJlcGVhdChjb2wgPCBsaW5lID8gMCA6IGNvbCAtIGxpbmUpICtcbiAgICAgICAgICAgIFwiOiguLi5hcmdzKSA9PiBzKC4uLmFyZ3MpfSlcXG4vKiBUaGlzIG1vZHVsZSBpcyBhIHByb3h5IHRvIGEgU2VydmVyIEFjdGlvbi4gVHVybiBvbiBTb3VyY2UgTWFwcyB0byBzZWUgdGhlIHNlcnZlciBzb3VyY2UuICovXCIpKVxuICAgICAgICA6IChjb2wgPVxuICAgICAgICAgICAgXCIvKiBUaGlzIG1vZHVsZSBpcyBhIHByb3h5IHRvIGEgU2VydmVyIEFjdGlvbi4gVHVybiBvbiBTb3VyY2UgTWFwcyB0byBzZWUgdGhlIHNlcnZlciBzb3VyY2UuICovXCIgK1xuICAgICAgICAgICAgXCJcXG5cIi5yZXBlYXQobGluZSAtIDIpICtcbiAgICAgICAgICAgIFwic2VydmVyPT4oe1wiICtcbiAgICAgICAgICAgIGVuY29kZWROYW1lICtcbiAgICAgICAgICAgIFwiOlxcblwiICtcbiAgICAgICAgICAgIFwiIFwiLnJlcGVhdCgxID4gY29sID8gMCA6IGNvbCAtIDEpICtcbiAgICAgICAgICAgIFwiKC4uLmFyZ3MpID0+IHNlcnZlciguLi5hcmdzKX0pXCIpO1xuICAgICAgZmlsZW5hbWUuc3RhcnRzV2l0aChcIi9cIikgJiYgKGZpbGVuYW1lID0gXCJmaWxlOi8vXCIgKyBmaWxlbmFtZSk7XG4gICAgICBzb3VyY2VNYXBcbiAgICAgICAgPyAoKGNvbCArPVxuICAgICAgICAgICAgXCJcXG4vLyMgc291cmNlVVJMPWFib3V0Oi8vUmVhY3QvXCIgK1xuICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGVudmlyb25tZW50TmFtZSkgK1xuICAgICAgICAgICAgXCIvXCIgK1xuICAgICAgICAgICAgZW5jb2RlVVJJKGZpbGVuYW1lKSArXG4gICAgICAgICAgICBcIj9zXCIgK1xuICAgICAgICAgICAgZmFrZVNlcnZlckZ1bmN0aW9uSWR4KyspLFxuICAgICAgICAgIChjb2wgKz0gXCJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1cIiArIHNvdXJjZU1hcCkpXG4gICAgICAgIDogZmlsZW5hbWUgJiYgKGNvbCArPSBcIlxcbi8vIyBzb3VyY2VVUkw9XCIgKyBmaWxlbmFtZSk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIGV2YWwpKGNvbCkoaW5uZXJGdW5jdGlvbilbbmFtZV07XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBpbm5lckZ1bmN0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWdpc3RlckJvdW5kU2VydmVyUmVmZXJlbmNlKHJlZmVyZW5jZSwgaWQsIGJvdW5kKSB7XG4gICAgICBrbm93blNlcnZlclJlZmVyZW5jZXMuaGFzKHJlZmVyZW5jZSkgfHxcbiAgICAgICAga25vd25TZXJ2ZXJSZWZlcmVuY2VzLnNldChyZWZlcmVuY2UsIHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgb3JpZ2luYWxCaW5kOiByZWZlcmVuY2UuYmluZCxcbiAgICAgICAgICBib3VuZDogYm91bmRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUJvdW5kU2VydmVyUmVmZXJlbmNlKFxuICAgICAgbWV0YURhdGEsXG4gICAgICBjYWxsU2VydmVyLFxuICAgICAgZW5jb2RlRm9ybUFjdGlvbixcbiAgICAgIGZpbmRTb3VyY2VNYXBVUkxcbiAgICApIHtcbiAgICAgIGZ1bmN0aW9uIGFjdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gYm91bmRcbiAgICAgICAgICA/IFwiZnVsZmlsbGVkXCIgPT09IGJvdW5kLnN0YXR1c1xuICAgICAgICAgICAgPyBjYWxsU2VydmVyKGlkLCBib3VuZC52YWx1ZS5jb25jYXQoYXJncykpXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZShib3VuZCkudGhlbihmdW5jdGlvbiAoYm91bmRBcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxTZXJ2ZXIoaWQsIGJvdW5kQXJncy5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIDogY2FsbFNlcnZlcihpZCwgYXJncyk7XG4gICAgICB9XG4gICAgICB2YXIgaWQgPSBtZXRhRGF0YS5pZCxcbiAgICAgICAgYm91bmQgPSBtZXRhRGF0YS5ib3VuZCxcbiAgICAgICAgbG9jYXRpb24gPSBtZXRhRGF0YS5sb2NhdGlvbjtcbiAgICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgICBlbmNvZGVGb3JtQWN0aW9uID0gbWV0YURhdGEubmFtZSB8fCBcIlwiO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBsb2NhdGlvblsxXSxcbiAgICAgICAgICBsaW5lID0gbG9jYXRpb25bMl07XG4gICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb25bM107XG4gICAgICAgIG1ldGFEYXRhID0gbWV0YURhdGEuZW52IHx8IFwiU2VydmVyXCI7XG4gICAgICAgIGZpbmRTb3VyY2VNYXBVUkwgPVxuICAgICAgICAgIG51bGwgPT0gZmluZFNvdXJjZU1hcFVSTFxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IGZpbmRTb3VyY2VNYXBVUkwoZmlsZW5hbWUsIG1ldGFEYXRhKTtcbiAgICAgICAgYWN0aW9uID0gY3JlYXRlRmFrZVNlcnZlckZ1bmN0aW9uKFxuICAgICAgICAgIGVuY29kZUZvcm1BY3Rpb24sXG4gICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgZmluZFNvdXJjZU1hcFVSTCxcbiAgICAgICAgICBsaW5lLFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIG1ldGFEYXRhLFxuICAgICAgICAgIGFjdGlvblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmVnaXN0ZXJCb3VuZFNlcnZlclJlZmVyZW5jZShhY3Rpb24sIGlkLCBib3VuZCk7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVN0YWNrTG9jYXRpb24oZXJyb3IpIHtcbiAgICAgIGVycm9yID0gZXJyb3Iuc3RhY2s7XG4gICAgICBlcnJvci5zdGFydHNXaXRoKFwiRXJyb3I6IHJlYWN0LXN0YWNrLXRvcC1mcmFtZVxcblwiKSAmJlxuICAgICAgICAoZXJyb3IgPSBlcnJvci5zbGljZSgyOSkpO1xuICAgICAgdmFyIGVuZE9mRmlyc3QgPSBlcnJvci5pbmRleE9mKFwiXFxuXCIpO1xuICAgICAgaWYgKC0xICE9PSBlbmRPZkZpcnN0KSB7XG4gICAgICAgIHZhciBlbmRPZlNlY29uZCA9IGVycm9yLmluZGV4T2YoXCJcXG5cIiwgZW5kT2ZGaXJzdCArIDEpO1xuICAgICAgICBlbmRPZkZpcnN0ID1cbiAgICAgICAgICAtMSA9PT0gZW5kT2ZTZWNvbmRcbiAgICAgICAgICAgID8gZXJyb3Iuc2xpY2UoZW5kT2ZGaXJzdCArIDEpXG4gICAgICAgICAgICA6IGVycm9yLnNsaWNlKGVuZE9mRmlyc3QgKyAxLCBlbmRPZlNlY29uZCk7XG4gICAgICB9IGVsc2UgZW5kT2ZGaXJzdCA9IGVycm9yO1xuICAgICAgZXJyb3IgPSB2OEZyYW1lUmVnRXhwLmV4ZWMoZW5kT2ZGaXJzdCk7XG4gICAgICBpZiAoXG4gICAgICAgICFlcnJvciAmJlxuICAgICAgICAoKGVycm9yID0ganNjU3BpZGVyTW9ua2V5RnJhbWVSZWdFeHAuZXhlYyhlbmRPZkZpcnN0KSksICFlcnJvcilcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBlbmRPZkZpcnN0ID0gZXJyb3JbMV0gfHwgXCJcIjtcbiAgICAgIFwiPGFub255bW91cz5cIiA9PT0gZW5kT2ZGaXJzdCAmJiAoZW5kT2ZGaXJzdCA9IFwiXCIpO1xuICAgICAgZW5kT2ZTZWNvbmQgPSBlcnJvclsyXSB8fCBlcnJvcls1XSB8fCBcIlwiO1xuICAgICAgXCI8YW5vbnltb3VzPlwiID09PSBlbmRPZlNlY29uZCAmJiAoZW5kT2ZTZWNvbmQgPSBcIlwiKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGVuZE9mRmlyc3QsXG4gICAgICAgIGVuZE9mU2Vjb25kLFxuICAgICAgICArKGVycm9yWzNdIHx8IGVycm9yWzZdKSxcbiAgICAgICAgKyhlcnJvcls0XSB8fCBlcnJvcls3XSlcbiAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfQUNUSVZJVFlfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJBY3Rpdml0eVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1ZJRVdfVFJBTlNJVElPTl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlZpZXdUcmFuc2l0aW9uXCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0QXJyYXlLaW5kKGFycmF5KSB7XG4gICAgICBmb3IgKHZhciBraW5kID0gMCwgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGggJiYgMTAwID4gaTsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlICYmIG51bGwgIT09IHZhbHVlKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzQXJyYXlJbXBsKHZhbHVlKSAmJlxuICAgICAgICAgICAgMiA9PT0gdmFsdWUubGVuZ3RoICYmXG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWVbMF1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICgwICE9PSBraW5kICYmIDMgIT09IGtpbmQpIHJldHVybiAxO1xuICAgICAgICAgICAga2luZCA9IDM7XG4gICAgICAgICAgfSBlbHNlIHJldHVybiAxO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZSAmJiA1MCA8IHZhbHVlLmxlbmd0aCkgfHxcbiAgICAgICAgICAgICgwICE9PSBraW5kICYmIDIgIT09IGtpbmQpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAga2luZCA9IDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBraW5kO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRPYmplY3RUb1Byb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzLCBpbmRlbnQsIHByZWZpeCkge1xuICAgICAgdmFyIGFkZGVkUHJvcGVydGllcyA9IDAsXG4gICAgICAgIGtleTtcbiAgICAgIGZvciAoa2V5IGluIG9iamVjdClcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmXG4gICAgICAgICAgXCJfXCIgIT09IGtleVswXSAmJlxuICAgICAgICAgIChhZGRlZFByb3BlcnRpZXMrKyxcbiAgICAgICAgICBhZGRWYWx1ZVRvUHJvcGVydGllcyhrZXksIG9iamVjdFtrZXldLCBwcm9wZXJ0aWVzLCBpbmRlbnQsIHByZWZpeCksXG4gICAgICAgICAgMTAwIDw9IGFkZGVkUHJvcGVydGllcylcbiAgICAgICAgKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5wdXNoKFtcbiAgICAgICAgICAgIHByZWZpeCArXG4gICAgICAgICAgICAgIFwiXFx1MDBhMFxcdTAwYTBcIi5yZXBlYXQoaW5kZW50KSArXG4gICAgICAgICAgICAgIFwiT25seSAxMDAgcHJvcGVydGllcyBhcmUgc2hvd24uIFJlYWN0IHdpbGwgbm90IGxvZyBtb3JlIHByb3BlcnRpZXMgb2YgdGhpcyBvYmplY3QuXCIsXG4gICAgICAgICAgICBcIlwiXG4gICAgICAgICAgXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkVmFsdWVUb1Byb3BlcnRpZXMoXG4gICAgICBwcm9wZXJ0eU5hbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIHByb3BlcnRpZXMsXG4gICAgICBpbmRlbnQsXG4gICAgICBwcmVmaXhcbiAgICApIHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICBpZiAobnVsbCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gXCJudWxsXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgdmFyIHR5cGVOYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHZhbHVlLnR5cGUpIHx8IFwiXFx1MjAyNlwiLFxuICAgICAgICAgICAgICAgIGtleSA9IHZhbHVlLmtleTtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5wcm9wcztcbiAgICAgICAgICAgICAgdmFyIHByb3BzS2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKSxcbiAgICAgICAgICAgICAgICBwcm9wc0xlbmd0aCA9IHByb3BzS2V5cy5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmIChudWxsID09IGtleSAmJiAwID09PSBwcm9wc0xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCI8XCIgKyB0eXBlTmFtZSArIFwiIC8+XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIDMgPiBpbmRlbnQgfHxcbiAgICAgICAgICAgICAgICAoMSA9PT0gcHJvcHNMZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIiA9PT0gcHJvcHNLZXlzWzBdICYmXG4gICAgICAgICAgICAgICAgICBudWxsID09IGtleSlcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIjxcIiArIHR5cGVOYW1lICsgXCIgXFx1MjAyNiAvPlwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChbXG4gICAgICAgICAgICAgICAgcHJlZml4ICsgXCJcXHUwMGEwXFx1MDBhMFwiLnJlcGVhdChpbmRlbnQpICsgcHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgICAgIFwiPFwiICsgdHlwZU5hbWVcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIG51bGwgIT09IGtleSAmJlxuICAgICAgICAgICAgICAgIGFkZFZhbHVlVG9Qcm9wZXJ0aWVzKFxuICAgICAgICAgICAgICAgICAgXCJrZXlcIixcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICBpbmRlbnQgKyAxLFxuICAgICAgICAgICAgICAgICAgcHJlZml4XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcHJvcGVydHlOYW1lID0gITE7XG4gICAgICAgICAgICAgIGtleSA9IDA7XG4gICAgICAgICAgICAgIGZvciAodmFyIHByb3BLZXkgaW4gdmFsdWUpXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKGtleSsrLFxuICAgICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiID09PSBwcm9wS2V5XG4gICAgICAgICAgICAgICAgICAgID8gbnVsbCAhPSB2YWx1ZS5jaGlsZHJlbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICghaXNBcnJheUltcGwodmFsdWUuY2hpbGRyZW4pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAwIDwgdmFsdWUuY2hpbGRyZW4ubGVuZ3RoKSAmJlxuICAgICAgICAgICAgICAgICAgICAgIChwcm9wZXJ0eU5hbWUgPSAhMClcbiAgICAgICAgICAgICAgICAgICAgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBwcm9wS2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgIFwiX1wiICE9PSBwcm9wS2V5WzBdICYmXG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmFsdWVUb1Byb3BlcnRpZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbcHJvcEtleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeFxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAxMDAgPD0ga2V5KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goW1xuICAgICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lID8gXCI+XFx1MjAyNjwvXCIgKyB0eXBlTmFtZSArIFwiPlwiIDogXCIvPlwiXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlTmFtZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICBwcm9wS2V5ID0gdHlwZU5hbWUuc2xpY2UoOCwgdHlwZU5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBpZiAoXCJBcnJheVwiID09PSBwcm9wS2V5KVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKCh0eXBlTmFtZSA9IDEwMCA8IHZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKGtleSA9IGdldEFycmF5S2luZCh2YWx1ZSkpLFxuICAgICAgICAgICAgICAgIDIgPT09IGtleSB8fCAwID09PSBrZXkpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICB0eXBlTmFtZSA/IHZhbHVlLnNsaWNlKDAsIDEwMCkuY29uY2F0KFwiXFx1MjAyNlwiKSA6IHZhbHVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgzID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgcHJlZml4ICsgXCJcXHUwMGEwXFx1MDBhMFwiLnJlcGVhdChpbmRlbnQpICsgcHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lIDwgdmFsdWUubGVuZ3RoICYmIDEwMCA+IHByb3BlcnR5TmFtZTtcbiAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZSsrXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKHByb3BLZXkgPSB2YWx1ZVtwcm9wZXJ0eU5hbWVdKSxcbiAgICAgICAgICAgICAgICAgICAgYWRkVmFsdWVUb1Byb3BlcnRpZXMoXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleVswXSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5WzFdLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZW50ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICBwcmVmaXhcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0eXBlTmFtZSAmJlxuICAgICAgICAgICAgICAgICAgYWRkVmFsdWVUb1Byb3BlcnRpZXMoXG4gICAgICAgICAgICAgICAgICAgICgxMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIFwiXFx1MjAyNlwiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKyAxLFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXhcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJQcm9taXNlXCIgPT09IHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgaWYgKFwiZnVsZmlsbGVkXCIgPT09IHZhbHVlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICgodHlwZU5hbWUgPSBwcm9wZXJ0aWVzLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICBhZGRWYWx1ZVRvUHJvcGVydGllcyhcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXhcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmxlbmd0aCA+IHR5cGVOYW1lKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXNbdHlwZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgcHJvcGVydGllc1sxXSA9XG4gICAgICAgICAgICAgICAgICAgIFwiUHJvbWlzZTxcIiArIChwcm9wZXJ0aWVzWzFdIHx8IFwiT2JqZWN0XCIpICsgXCI+XCI7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIFwicmVqZWN0ZWRcIiA9PT0gdmFsdWUuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgKCh0eXBlTmFtZSA9IHByb3BlcnRpZXMubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBhZGRWYWx1ZVRvUHJvcGVydGllcyhcbiAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnJlYXNvbixcbiAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICBpbmRlbnQsXG4gICAgICAgICAgICAgICAgICBwcmVmaXhcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMubGVuZ3RoID4gdHlwZU5hbWUpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzW3R5cGVOYW1lXTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzWzFdID0gXCJSZWplY3RlZCBQcm9taXNlPFwiICsgcHJvcGVydGllc1sxXSArIFwiPlwiO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goW1xuICAgICAgICAgICAgICAgIFwiXFx1MDBhMFxcdTAwYTBcIi5yZXBlYXQoaW5kZW50KSArIHByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgICAgICBcIlByb21pc2VcIlxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXCJPYmplY3RcIiA9PT0gcHJvcEtleSAmJlxuICAgICAgICAgICAgICAodHlwZU5hbWUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpKSAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlTmFtZS5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICAgICAocHJvcEtleSA9IHR5cGVOYW1lLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKFtcbiAgICAgICAgICAgICAgcHJlZml4ICsgXCJcXHUwMGEwXFx1MDBhMFwiLnJlcGVhdChpbmRlbnQpICsgcHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgICBcIk9iamVjdFwiID09PSBwcm9wS2V5ID8gKDMgPiBpbmRlbnQgPyBcIlwiIDogXCJcXHUyMDI2XCIpIDogcHJvcEtleVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAzID4gaW5kZW50ICYmXG4gICAgICAgICAgICAgIGFkZE9iamVjdFRvUHJvcGVydGllcyh2YWx1ZSwgcHJvcGVydGllcywgaW5kZW50ICsgMSwgcHJlZml4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIHZhbHVlID0gXCJcIiA9PT0gdmFsdWUubmFtZSA/IFwiKCkgPT4ge31cIiA6IHZhbHVlLm5hbWUgKyBcIigpIHt9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICB2YWx1ZSA9XG4gICAgICAgICAgICBcIlRoaXMgb2JqZWN0IGhhcyBiZWVuIG9taXR0ZWQgYnkgUmVhY3QgaW4gdGhlIGNvbnNvbGUgbG9nIHRvIGF2b2lkIHNlbmRpbmcgdG9vIG11Y2ggZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuIFRyeSBsb2dnaW5nIHNtYWxsZXIgb3IgbW9yZSBzcGVjaWZpYyBvYmplY3RzLlwiID09PVxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgPyBcIlxcdTIwMjZcIlxuICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgIHZhbHVlID0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgfVxuICAgICAgcHJvcGVydGllcy5wdXNoKFtcbiAgICAgICAgcHJlZml4ICsgXCJcXHUwMGEwXFx1MDBhMFwiLnJlcGVhdChpbmRlbnQpICsgcHJvcGVydHlOYW1lLFxuICAgICAgICB2YWx1ZVxuICAgICAgXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldElPRGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubmFtZSB8fCBcIlwiO1xuICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGlmIChudWxsID09PSB2YWx1ZSkgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIFN0cmluZyh2YWx1ZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWUudXJsKSByZXR1cm4gdmFsdWUudXJsO1xuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZS5ocmVmKSByZXR1cm4gdmFsdWUuaHJlZjtcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWUuc3JjKSByZXR1cm4gdmFsdWUuc3JjO1xuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZS5jdXJyZW50U3JjKSByZXR1cm4gdmFsdWUuY3VycmVudFNyYztcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWUuY29tbWFuZCkgcmV0dXJuIHZhbHVlLmNvbW1hbmQ7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZS5yZXF1ZXN0ICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHZhbHVlLnJlcXVlc3QgJiZcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHZhbHVlLnJlcXVlc3QudXJsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5yZXF1ZXN0LnVybDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlLnJlc3BvbnNlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHZhbHVlLnJlc3BvbnNlICYmXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZS5yZXNwb25zZS51cmxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnJlc3BvbnNlLnVybDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHZhbHVlLmlkIHx8XG4gICAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiB2YWx1ZS5pZCB8fFxuICAgICAgICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgdmFsdWUuaWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZS5pZCk7XG4gICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHZhbHVlLm5hbWUpIHJldHVybiB2YWx1ZS5uYW1lO1xuICAgICAgICAgICAgdmFyIHN0ciA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnN0YXJ0c1dpdGgoXCJbb2JqZWN0IFwiKSB8fFxuICAgICAgICAgICAgICA1ID4gc3RyLmxlbmd0aCB8fFxuICAgICAgICAgICAgICA1MDAgPCBzdHIubGVuZ3RoXG4gICAgICAgICAgICAgID8gXCJcIlxuICAgICAgICAgICAgICA6IHN0cjtcbiAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gNSA+IHZhbHVlLmxlbmd0aCB8fCA1MDAgPCB2YWx1ZS5sZW5ndGggPyBcIlwiIDogdmFsdWU7XG4gICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya0FsbFRyYWNrc0luT3JkZXIoKSB7XG4gICAgICBzdXBwb3J0c1VzZXJUaW1pbmcgJiZcbiAgICAgICAgKGNvbnNvbGUudGltZVN0YW1wKFxuICAgICAgICAgIFwiU2VydmVyIFJlcXVlc3RzIFRyYWNrXCIsXG4gICAgICAgICAgMC4wMDEsXG4gICAgICAgICAgMC4wMDEsXG4gICAgICAgICAgXCJTZXJ2ZXIgUmVxdWVzdHMgXFx1MjY5YlwiLFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICBcInByaW1hcnktbGlnaHRcIlxuICAgICAgICApLFxuICAgICAgICBjb25zb2xlLnRpbWVTdGFtcChcbiAgICAgICAgICBcIlNlcnZlciBDb21wb25lbnRzIFRyYWNrXCIsXG4gICAgICAgICAgMC4wMDEsXG4gICAgICAgICAgMC4wMDEsXG4gICAgICAgICAgXCJQcmltYXJ5XCIsXG4gICAgICAgICAgXCJTZXJ2ZXIgQ29tcG9uZW50cyBcXHUyNjliXCIsXG4gICAgICAgICAgXCJwcmltYXJ5LWxpZ2h0XCJcbiAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldElPQ29sb3IoZnVuY3Rpb25OYW1lKSB7XG4gICAgICBzd2l0Y2ggKGZ1bmN0aW9uTmFtZS5jaGFyQ29kZUF0KDApICUgMykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIFwidGVydGlhcnktbGlnaHRcIjtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBcInRlcnRpYXJ5XCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFwidGVydGlhcnktZGFya1wiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJT0xvbmdOYW1lKGlvSW5mbywgZGVzY3JpcHRpb24sIGVudiwgcm9vdEVudikge1xuICAgICAgaW9JbmZvID0gaW9JbmZvLm5hbWU7XG4gICAgICBkZXNjcmlwdGlvbiA9XG4gICAgICAgIFwiXCIgPT09IGRlc2NyaXB0aW9uID8gaW9JbmZvIDogaW9JbmZvICsgXCIgKFwiICsgZGVzY3JpcHRpb24gKyBcIilcIjtcbiAgICAgIHJldHVybiBlbnYgPT09IHJvb3RFbnYgfHwgdm9pZCAwID09PSBlbnZcbiAgICAgICAgPyBkZXNjcmlwdGlvblxuICAgICAgICA6IGRlc2NyaXB0aW9uICsgXCIgW1wiICsgZW52ICsgXCJdXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldElPU2hvcnROYW1lKGlvSW5mbywgZGVzY3JpcHRpb24sIGVudiwgcm9vdEVudikge1xuICAgICAgaW9JbmZvID0gaW9JbmZvLm5hbWU7XG4gICAgICBlbnYgPSBlbnYgPT09IHJvb3RFbnYgfHwgdm9pZCAwID09PSBlbnYgPyBcIlwiIDogXCIgW1wiICsgZW52ICsgXCJdXCI7XG4gICAgICB2YXIgZGVzYyA9IFwiXCI7XG4gICAgICByb290RW52ID0gMzAgLSBpb0luZm8ubGVuZ3RoIC0gZW52Lmxlbmd0aDtcbiAgICAgIGlmICgxIDwgcm9vdEVudikge1xuICAgICAgICB2YXIgbCA9IGRlc2NyaXB0aW9uLmxlbmd0aDtcbiAgICAgICAgaWYgKDAgPCBsICYmIGwgPD0gcm9vdEVudikgZGVzYyA9IFwiIChcIiArIGRlc2NyaXB0aW9uICsgXCIpXCI7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIGRlc2NyaXB0aW9uLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8XG4gICAgICAgICAgZGVzY3JpcHRpb24uc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpIHx8XG4gICAgICAgICAgZGVzY3JpcHRpb24uc3RhcnRzV2l0aChcIi9cIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIHF1ZXJ5SWR4ID0gZGVzY3JpcHRpb24uaW5kZXhPZihcIj9cIik7XG4gICAgICAgICAgLTEgPT09IHF1ZXJ5SWR4ICYmIChxdWVyeUlkeCA9IGRlc2NyaXB0aW9uLmxlbmd0aCk7XG4gICAgICAgICAgNDcgPT09IGRlc2NyaXB0aW9uLmNoYXJDb2RlQXQocXVlcnlJZHggLSAxKSAmJiBxdWVyeUlkeC0tO1xuICAgICAgICAgIGRlc2MgPSBkZXNjcmlwdGlvbi5sYXN0SW5kZXhPZihcIi9cIiwgcXVlcnlJZHggLSAxKTtcbiAgICAgICAgICBxdWVyeUlkeCAtIGRlc2MgPCByb290RW52XG4gICAgICAgICAgICA/IChkZXNjID0gXCIgKFxcdTIwMjZcIiArIGRlc2NyaXB0aW9uLnNsaWNlKGRlc2MsIHF1ZXJ5SWR4KSArIFwiKVwiKVxuICAgICAgICAgICAgOiAoKGwgPSBkZXNjcmlwdGlvbi5zbGljZShkZXNjLCBkZXNjICsgcm9vdEVudiAvIDIpKSxcbiAgICAgICAgICAgICAgKGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24uc2xpY2UoXG4gICAgICAgICAgICAgICAgcXVlcnlJZHggLSByb290RW52IC8gMixcbiAgICAgICAgICAgICAgICBxdWVyeUlkeFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGRlc2MgPVxuICAgICAgICAgICAgICAgIFwiIChcIiArXG4gICAgICAgICAgICAgICAgKDAgPCBkZXNjID8gXCJcXHUyMDI2XCIgOiBcIlwiKSArXG4gICAgICAgICAgICAgICAgbCArXG4gICAgICAgICAgICAgICAgXCJcXHUyMDI2XCIgK1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uICtcbiAgICAgICAgICAgICAgICBcIilcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW9JbmZvICsgZGVzYyArIGVudjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nQ29tcG9uZW50QXdhaXQoXG4gICAgICBhc3luY0luZm8sXG4gICAgICB0cmFja0lkeCxcbiAgICAgIHN0YXJ0VGltZSxcbiAgICAgIGVuZFRpbWUsXG4gICAgICByb290RW52LFxuICAgICAgdmFsdWVcbiAgICApIHtcbiAgICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmcgJiYgMCA8IGVuZFRpbWUpIHtcbiAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gZ2V0SU9EZXNjcmlwdGlvbih2YWx1ZSksXG4gICAgICAgICAgbmFtZSA9IGdldElPU2hvcnROYW1lKFxuICAgICAgICAgICAgYXN5bmNJbmZvLmF3YWl0ZWQsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGFzeW5jSW5mby5lbnYsXG4gICAgICAgICAgICByb290RW52XG4gICAgICAgICAgKSxcbiAgICAgICAgICBlbnRyeU5hbWUgPSBcImF3YWl0IFwiICsgbmFtZTtcbiAgICAgICAgbmFtZSA9IGdldElPQ29sb3IobmFtZSk7XG4gICAgICAgIHZhciBkZWJ1Z1Rhc2sgPSBhc3luY0luZm8uZGVidWdUYXNrIHx8IGFzeW5jSW5mby5hd2FpdGVkLmRlYnVnVGFzaztcbiAgICAgICAgaWYgKGRlYnVnVGFzaykge1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW107XG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlICYmIG51bGwgIT09IHZhbHVlXG4gICAgICAgICAgICA/IGFkZE9iamVjdFRvUHJvcGVydGllcyh2YWx1ZSwgcHJvcGVydGllcywgMCwgXCJcIilcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSB2YWx1ZSAmJlxuICAgICAgICAgICAgICBhZGRWYWx1ZVRvUHJvcGVydGllcyhcImF3YWl0ZWQgdmFsdWVcIiwgdmFsdWUsIHByb3BlcnRpZXMsIDAsIFwiXCIpO1xuICAgICAgICAgIGFzeW5jSW5mbyA9IGdldElPTG9uZ05hbWUoXG4gICAgICAgICAgICBhc3luY0luZm8uYXdhaXRlZCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgYXN5bmNJbmZvLmVudixcbiAgICAgICAgICAgIHJvb3RFbnZcbiAgICAgICAgICApO1xuICAgICAgICAgIGRlYnVnVGFzay5ydW4oXG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlLmJpbmQocGVyZm9ybWFuY2UsIGVudHJ5TmFtZSwge1xuICAgICAgICAgICAgICBzdGFydDogMCA+IHN0YXJ0VGltZSA/IDAgOiBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIGVuZDogZW5kVGltZSxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgZGV2dG9vbHM6IHtcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgdHJhY2s6IHRyYWNrTmFtZXNbdHJhY2tJZHhdLFxuICAgICAgICAgICAgICAgICAgdHJhY2tHcm91cDogXCJTZXJ2ZXIgQ29tcG9uZW50cyBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgdG9vbHRpcFRleHQ6IGFzeW5jSW5mb1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMoZW50cnlOYW1lKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgY29uc29sZS50aW1lU3RhbXAoXG4gICAgICAgICAgICBlbnRyeU5hbWUsXG4gICAgICAgICAgICAwID4gc3RhcnRUaW1lID8gMCA6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICB0cmFja05hbWVzW3RyYWNrSWR4XSxcbiAgICAgICAgICAgIFwiU2VydmVyIENvbXBvbmVudHMgXFx1MjY5YlwiLFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ0lPSW5mb0Vycm9yZWQoaW9JbmZvLCByb290RW52LCBlcnJvcikge1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IGlvSW5mby5zdGFydCxcbiAgICAgICAgZW5kVGltZSA9IGlvSW5mby5lbmQ7XG4gICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nICYmIDAgPD0gZW5kVGltZSkge1xuICAgICAgICB2YXIgZGVzY3JpcHRpb24gPSBnZXRJT0Rlc2NyaXB0aW9uKGVycm9yKSxcbiAgICAgICAgICBlbnRyeU5hbWUgPSBnZXRJT1Nob3J0TmFtZShpb0luZm8sIGRlc2NyaXB0aW9uLCBpb0luZm8uZW52LCByb290RW52KSxcbiAgICAgICAgICBkZWJ1Z1Rhc2sgPSBpb0luZm8uZGVidWdUYXNrO1xuICAgICAgICBlbnRyeU5hbWUgPSBcIlxcdTIwMGJcIiArIGVudHJ5TmFtZTtcbiAgICAgICAgZGVidWdUYXNrXG4gICAgICAgICAgPyAoKGVycm9yID0gW1xuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJyZWplY3RlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgIDogU3RyaW5nKGVycm9yKVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIChpb0luZm8gPVxuICAgICAgICAgICAgICBnZXRJT0xvbmdOYW1lKGlvSW5mbywgZGVzY3JpcHRpb24sIGlvSW5mby5lbnYsIHJvb3RFbnYpICtcbiAgICAgICAgICAgICAgXCIgUmVqZWN0ZWRcIiksXG4gICAgICAgICAgICBkZWJ1Z1Rhc2sucnVuKFxuICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlLmJpbmQocGVyZm9ybWFuY2UsIGVudHJ5TmFtZSwge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiAwID4gc3RhcnRUaW1lID8gMCA6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICBkZXZ0b29sczoge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICB0cmFjazogXCJTZXJ2ZXIgUmVxdWVzdHMgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcFRleHQ6IGlvSW5mb1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKGVudHJ5TmFtZSkpXG4gICAgICAgICAgOiBjb25zb2xlLnRpbWVTdGFtcChcbiAgICAgICAgICAgICAgZW50cnlOYW1lLFxuICAgICAgICAgICAgICAwID4gc3RhcnRUaW1lID8gMCA6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgZW5kVGltZSxcbiAgICAgICAgICAgICAgXCJTZXJ2ZXIgUmVxdWVzdHMgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIFwiZXJyb3JcIlxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nSU9JbmZvKGlvSW5mbywgcm9vdEVudiwgdmFsdWUpIHtcbiAgICAgIHZhciBzdGFydFRpbWUgPSBpb0luZm8uc3RhcnQsXG4gICAgICAgIGVuZFRpbWUgPSBpb0luZm8uZW5kO1xuICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZyAmJiAwIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gZ2V0SU9EZXNjcmlwdGlvbih2YWx1ZSksXG4gICAgICAgICAgZW50cnlOYW1lID0gZ2V0SU9TaG9ydE5hbWUoaW9JbmZvLCBkZXNjcmlwdGlvbiwgaW9JbmZvLmVudiwgcm9vdEVudiksXG4gICAgICAgICAgY29sb3IgPSBnZXRJT0NvbG9yKGVudHJ5TmFtZSksXG4gICAgICAgICAgZGVidWdUYXNrID0gaW9JbmZvLmRlYnVnVGFzaztcbiAgICAgICAgZW50cnlOYW1lID0gXCJcXHUyMDBiXCIgKyBlbnRyeU5hbWU7XG4gICAgICAgIGlmIChkZWJ1Z1Rhc2spIHtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IFtdO1xuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJiBudWxsICE9PSB2YWx1ZVxuICAgICAgICAgICAgPyBhZGRPYmplY3RUb1Byb3BlcnRpZXModmFsdWUsIHByb3BlcnRpZXMsIDAsIFwiXCIpXG4gICAgICAgICAgICA6IHZvaWQgMCAhPT0gdmFsdWUgJiZcbiAgICAgICAgICAgICAgYWRkVmFsdWVUb1Byb3BlcnRpZXMoXCJSZXNvbHZlZFwiLCB2YWx1ZSwgcHJvcGVydGllcywgMCwgXCJcIik7XG4gICAgICAgICAgaW9JbmZvID0gZ2V0SU9Mb25nTmFtZShpb0luZm8sIGRlc2NyaXB0aW9uLCBpb0luZm8uZW52LCByb290RW52KTtcbiAgICAgICAgICBkZWJ1Z1Rhc2sucnVuKFxuICAgICAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZS5iaW5kKHBlcmZvcm1hbmNlLCBlbnRyeU5hbWUsIHtcbiAgICAgICAgICAgICAgc3RhcnQ6IDAgPiBzdGFydFRpbWUgPyAwIDogc3RhcnRUaW1lLFxuICAgICAgICAgICAgICBlbmQ6IGVuZFRpbWUsXG4gICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGRldnRvb2xzOiB7XG4gICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICB0cmFjazogXCJTZXJ2ZXIgUmVxdWVzdHMgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgIHRvb2x0aXBUZXh0OiBpb0luZm9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKGVudHJ5TmFtZSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGNvbnNvbGUudGltZVN0YW1wKFxuICAgICAgICAgICAgZW50cnlOYW1lLFxuICAgICAgICAgICAgMCA+IHN0YXJ0VGltZSA/IDAgOiBzdGFydFRpbWUsXG4gICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgXCJTZXJ2ZXIgUmVxdWVzdHMgXFx1MjY5YlwiLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgY29sb3JcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFjdFByb21pc2Uoc3RhdHVzLCB2YWx1ZSwgcmVhc29uKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICAgIHRoaXMuX2RlYnVnQ2h1bmsgPSBudWxsO1xuICAgICAgdGhpcy5fZGVidWdJbmZvID0gW107XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVud3JhcFdlYWtSZXNwb25zZSh3ZWFrUmVzcG9uc2UpIHtcbiAgICAgIHdlYWtSZXNwb25zZSA9IHdlYWtSZXNwb25zZS53ZWFrLmRlcmVmKCk7XG4gICAgICBpZiAodm9pZCAwID09PSB3ZWFrUmVzcG9uc2UpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiV2UgZGlkIG5vdCBleHBlY3QgdG8gcmVjZWl2ZSBuZXcgZGF0YSBhZnRlciBHQzppbmcgdGhlIHJlc3BvbnNlLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gd2Vha1Jlc3BvbnNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZURlYnVnQ2hhbm5lbChkZWJ1Z0NoYW5uZWwpIHtcbiAgICAgIGRlYnVnQ2hhbm5lbC5jYWxsYmFjayAmJiBkZWJ1Z0NoYW5uZWwuY2FsbGJhY2soXCJcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDaHVuayhjaHVuaykge1xuICAgICAgc3dpdGNoIChjaHVuay5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcInJlc29sdmVkX21vZGVsXCI6XG4gICAgICAgICAgaW5pdGlhbGl6ZU1vZGVsQ2h1bmsoY2h1bmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVzb2x2ZWRfbW9kdWxlXCI6XG4gICAgICAgICAgaW5pdGlhbGl6ZU1vZHVsZUNodW5rKGNodW5rKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY2h1bmsuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICByZXR1cm4gY2h1bmsudmFsdWU7XG4gICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgIGNhc2UgXCJibG9ja2VkXCI6XG4gICAgICAgIGNhc2UgXCJoYWx0ZWRcIjpcbiAgICAgICAgICB0aHJvdyBjaHVuaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBjaHVuay5yZWFzb247XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFJvb3Qod2Vha1Jlc3BvbnNlKSB7XG4gICAgICB3ZWFrUmVzcG9uc2UgPSB1bndyYXBXZWFrUmVzcG9uc2Uod2Vha1Jlc3BvbnNlKTtcbiAgICAgIHJldHVybiBnZXRDaHVuayh3ZWFrUmVzcG9uc2UsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVQZW5kaW5nQ2h1bmsocmVzcG9uc2UpIHtcbiAgICAgIDAgPT09IHJlc3BvbnNlLl9wZW5kaW5nQ2h1bmtzKysgJiZcbiAgICAgICAgKChyZXNwb25zZS5fd2Vha1Jlc3BvbnNlLnJlc3BvbnNlID0gcmVzcG9uc2UpLFxuICAgICAgICBudWxsICE9PSByZXNwb25zZS5fcGVuZGluZ0luaXRpYWxSZW5kZXIgJiZcbiAgICAgICAgICAoY2xlYXJUaW1lb3V0KHJlc3BvbnNlLl9wZW5kaW5nSW5pdGlhbFJlbmRlciksXG4gICAgICAgICAgKHJlc3BvbnNlLl9wZW5kaW5nSW5pdGlhbFJlbmRlciA9IG51bGwpKSk7XG4gICAgICByZXR1cm4gbmV3IFJlYWN0UHJvbWlzZShcInBlbmRpbmdcIiwgbnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbGVhc2VQZW5kaW5nQ2h1bmsocmVzcG9uc2UsIGNodW5rKSB7XG4gICAgICBcInBlbmRpbmdcIiA9PT0gY2h1bmsuc3RhdHVzICYmXG4gICAgICAgIDAgPT09IC0tcmVzcG9uc2UuX3BlbmRpbmdDaHVua3MgJiZcbiAgICAgICAgKChyZXNwb25zZS5fd2Vha1Jlc3BvbnNlLnJlc3BvbnNlID0gbnVsbCksXG4gICAgICAgIChyZXNwb25zZS5fcGVuZGluZ0luaXRpYWxSZW5kZXIgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgIGZsdXNoSW5pdGlhbFJlbmRlclBlcmZvcm1hbmNlLmJpbmQobnVsbCwgcmVzcG9uc2UpLFxuICAgICAgICAgIDEwMFxuICAgICAgICApKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbHRlckRlYnVnSW5mbyhyZXNwb25zZSwgdmFsdWUpIHtcbiAgICAgIGlmIChudWxsICE9PSByZXNwb25zZS5fZGVidWdFbmRUaW1lKSB7XG4gICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2UuX2RlYnVnRW5kVGltZSAtIHBlcmZvcm1hbmNlLnRpbWVPcmlnaW47XG4gICAgICAgIGZvciAodmFyIGRlYnVnSW5mbyA9IFtdLCBpID0gMDsgaSA8IHZhbHVlLl9kZWJ1Z0luZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaW5mbyA9IHZhbHVlLl9kZWJ1Z0luZm9baV07XG4gICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT09IHR5cGVvZiBpbmZvLnRpbWUgJiYgaW5mby50aW1lID4gcmVzcG9uc2UpIGJyZWFrO1xuICAgICAgICAgIGRlYnVnSW5mby5wdXNoKGluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdmVEZWJ1Z0luZm9Gcm9tQ2h1bmtUb0lubmVyVmFsdWUoY2h1bmssIHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHJlc29sdmVMYXp5KHZhbHVlKTtcbiAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICBudWxsID09PSB2YWx1ZSB8fFxuICAgICAgICAoIWlzQXJyYXlJbXBsKHZhbHVlKSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlW0FTWU5DX0lURVJBVE9SXSAmJlxuICAgICAgICAgIHZhbHVlLiQkdHlwZW9mICE9PSBSRUFDVF9FTEVNRU5UX1RZUEUgJiZcbiAgICAgICAgICB2YWx1ZS4kJHR5cGVvZiAhPT0gUkVBQ1RfTEFaWV9UWVBFKSB8fFxuICAgICAgICAoKGNodW5rID0gY2h1bmsuX2RlYnVnSW5mby5zcGxpY2UoMCkpLFxuICAgICAgICBpc0FycmF5SW1wbCh2YWx1ZS5fZGVidWdJbmZvKVxuICAgICAgICAgID8gdmFsdWUuX2RlYnVnSW5mby51bnNoaWZ0LmFwcGx5KHZhbHVlLl9kZWJ1Z0luZm8sIGNodW5rKVxuICAgICAgICAgIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgICB2YWx1ZTogY2h1bmtcbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FrZUNodW5rKHJlc3BvbnNlLCBsaXN0ZW5lcnMsIHZhbHVlLCBjaHVuaykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsaXN0ZW5lclxuICAgICAgICAgID8gbGlzdGVuZXIodmFsdWUpXG4gICAgICAgICAgOiBmdWxmaWxsUmVmZXJlbmNlKHJlc3BvbnNlLCBsaXN0ZW5lciwgdmFsdWUsIGNodW5rKTtcbiAgICAgIH1cbiAgICAgIGZpbHRlckRlYnVnSW5mbyhyZXNwb25zZSwgY2h1bmspO1xuICAgICAgbW92ZURlYnVnSW5mb0Zyb21DaHVua1RvSW5uZXJWYWx1ZShjaHVuaywgdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWplY3RDaHVuayhyZXNwb25zZSwgbGlzdGVuZXJzLCBlcnJvcikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsaXN0ZW5lclxuICAgICAgICAgID8gbGlzdGVuZXIoZXJyb3IpXG4gICAgICAgICAgOiByZWplY3RSZWZlcmVuY2UocmVzcG9uc2UsIGxpc3RlbmVyLmhhbmRsZXIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUJsb2NrZWRDeWNsZShyZXNvbHZlZENodW5rLCByZWZlcmVuY2UpIHtcbiAgICAgIHZhciByZWZlcmVuY2VkQ2h1bmsgPSByZWZlcmVuY2UuaGFuZGxlci5jaHVuaztcbiAgICAgIGlmIChudWxsID09PSByZWZlcmVuY2VkQ2h1bmspIHJldHVybiBudWxsO1xuICAgICAgaWYgKHJlZmVyZW5jZWRDaHVuayA9PT0gcmVzb2x2ZWRDaHVuaykgcmV0dXJuIHJlZmVyZW5jZS5oYW5kbGVyO1xuICAgICAgcmVmZXJlbmNlID0gcmVmZXJlbmNlZENodW5rLnZhbHVlO1xuICAgICAgaWYgKG51bGwgIT09IHJlZmVyZW5jZSlcbiAgICAgICAgZm9yIChcbiAgICAgICAgICByZWZlcmVuY2VkQ2h1bmsgPSAwO1xuICAgICAgICAgIHJlZmVyZW5jZWRDaHVuayA8IHJlZmVyZW5jZS5sZW5ndGg7XG4gICAgICAgICAgcmVmZXJlbmNlZENodW5rKytcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGxpc3RlbmVyID0gcmVmZXJlbmNlW3JlZmVyZW5jZWRDaHVua107XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgbGlzdGVuZXIgJiZcbiAgICAgICAgICAgICgobGlzdGVuZXIgPSByZXNvbHZlQmxvY2tlZEN5Y2xlKHJlc29sdmVkQ2h1bmssIGxpc3RlbmVyKSksXG4gICAgICAgICAgICBudWxsICE9PSBsaXN0ZW5lcilcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YWtlQ2h1bmtJZkluaXRpYWxpemVkKFxuICAgICAgcmVzcG9uc2UsXG4gICAgICBjaHVuayxcbiAgICAgIHJlc29sdmVMaXN0ZW5lcnMsXG4gICAgICByZWplY3RMaXN0ZW5lcnNcbiAgICApIHtcbiAgICAgIHN3aXRjaCAoY2h1bmsuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICB3YWtlQ2h1bmsocmVzcG9uc2UsIHJlc29sdmVMaXN0ZW5lcnMsIGNodW5rLnZhbHVlLCBjaHVuayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJibG9ja2VkXCI6XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvbHZlTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSByZXNvbHZlTGlzdGVuZXJzW2ldO1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgIHZhciBjeWNsaWNIYW5kbGVyID0gcmVzb2x2ZUJsb2NrZWRDeWNsZShjaHVuaywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gY3ljbGljSGFuZGxlcilcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgICAgICAgICAgKGZ1bGZpbGxSZWZlcmVuY2UoXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgICAgICAgICAgICAgY3ljbGljSGFuZGxlci52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICByZXNvbHZlTGlzdGVuZXJzLnNwbGljZShpLCAxKSxcbiAgICAgICAgICAgICAgICAgIGktLSxcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJlamVjdExpc3RlbmVycyAmJlxuICAgICAgICAgICAgICAgICAgICAoKGxpc3RlbmVyID0gcmVqZWN0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpKSxcbiAgICAgICAgICAgICAgICAgICAgLTEgIT09IGxpc3RlbmVyICYmIHJlamVjdExpc3RlbmVycy5zcGxpY2UobGlzdGVuZXIsIDEpKSxcbiAgICAgICAgICAgICAgICAgIGNodW5rLnN0YXR1cylcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgd2FrZUNodW5rKHJlc3BvbnNlLCByZXNvbHZlTGlzdGVuZXJzLCBjaHVuay52YWx1ZSwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcmVqZWN0TGlzdGVuZXJzICYmXG4gICAgICAgICAgICAgICAgICAgICAgcmVqZWN0Q2h1bmsocmVzcG9uc2UsIHJlamVjdExpc3RlbmVycywgY2h1bmsucmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgaWYgKGNodW5rLnZhbHVlKVxuICAgICAgICAgICAgZm9yIChyZXNwb25zZSA9IDA7IHJlc3BvbnNlIDwgcmVzb2x2ZUxpc3RlbmVycy5sZW5ndGg7IHJlc3BvbnNlKyspXG4gICAgICAgICAgICAgIGNodW5rLnZhbHVlLnB1c2gocmVzb2x2ZUxpc3RlbmVyc1tyZXNwb25zZV0pO1xuICAgICAgICAgIGVsc2UgY2h1bmsudmFsdWUgPSByZXNvbHZlTGlzdGVuZXJzO1xuICAgICAgICAgIGlmIChjaHVuay5yZWFzb24pIHtcbiAgICAgICAgICAgIGlmIChyZWplY3RMaXN0ZW5lcnMpXG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgcmVzb2x2ZUxpc3RlbmVycyA9IDA7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUxpc3RlbmVycyA8IHJlamVjdExpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUxpc3RlbmVycysrXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBjaHVuay5yZWFzb24ucHVzaChyZWplY3RMaXN0ZW5lcnNbcmVzb2x2ZUxpc3RlbmVyc10pO1xuICAgICAgICAgIH0gZWxzZSBjaHVuay5yZWFzb24gPSByZWplY3RMaXN0ZW5lcnM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgIHJlamVjdExpc3RlbmVycyAmJlxuICAgICAgICAgICAgcmVqZWN0Q2h1bmsocmVzcG9uc2UsIHJlamVjdExpc3RlbmVycywgY2h1bmsucmVhc29uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJpZ2dlckVycm9yT25DaHVuayhyZXNwb25zZSwgY2h1bmssIGVycm9yKSB7XG4gICAgICBpZiAoXCJwZW5kaW5nXCIgIT09IGNodW5rLnN0YXR1cyAmJiBcImJsb2NrZWRcIiAhPT0gY2h1bmsuc3RhdHVzKVxuICAgICAgICBjaHVuay5yZWFzb24uZXJyb3IoZXJyb3IpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbGVhc2VQZW5kaW5nQ2h1bmsocmVzcG9uc2UsIGNodW5rKTtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IGNodW5rLnJlYXNvbjtcbiAgICAgICAgaWYgKFwicGVuZGluZ1wiID09PSBjaHVuay5zdGF0dXMgJiYgbnVsbCAhPSBjaHVuay5fZGVidWdDaHVuaykge1xuICAgICAgICAgIHZhciBwcmV2SGFuZGxlciA9IGluaXRpYWxpemluZ0hhbmRsZXIsXG4gICAgICAgICAgICBwcmV2Q2h1bmsgPSBpbml0aWFsaXppbmdDaHVuaztcbiAgICAgICAgICBpbml0aWFsaXppbmdIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICBjaHVuay5zdGF0dXMgPSBcImJsb2NrZWRcIjtcbiAgICAgICAgICBjaHVuay52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgY2h1bmsucmVhc29uID0gbnVsbDtcbiAgICAgICAgICBpbml0aWFsaXppbmdDaHVuayA9IGNodW5rO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbml0aWFsaXplRGVidWdDaHVuayhyZXNwb25zZSwgY2h1bmspO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAoaW5pdGlhbGl6aW5nSGFuZGxlciA9IHByZXZIYW5kbGVyKSxcbiAgICAgICAgICAgICAgKGluaXRpYWxpemluZ0NodW5rID0gcHJldkNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmsuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICBjaHVuay5yZWFzb24gPSBlcnJvcjtcbiAgICAgICAgbnVsbCAhPT0gbGlzdGVuZXJzICYmIHJlamVjdENodW5rKHJlc3BvbnNlLCBsaXN0ZW5lcnMsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzb2x2ZWRNb2RlbENodW5rKHJlc3BvbnNlLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBSZWFjdFByb21pc2UoXCJyZXNvbHZlZF9tb2RlbFwiLCB2YWx1ZSwgcmVzcG9uc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSZXNvbHZlZEl0ZXJhdG9yUmVzdWx0Q2h1bmsocmVzcG9uc2UsIHZhbHVlLCBkb25lKSB7XG4gICAgICByZXR1cm4gbmV3IFJlYWN0UHJvbWlzZShcbiAgICAgICAgXCJyZXNvbHZlZF9tb2RlbFwiLFxuICAgICAgICAoZG9uZSA/ICd7XCJkb25lXCI6dHJ1ZSxcInZhbHVlXCI6JyA6ICd7XCJkb25lXCI6ZmFsc2UsXCJ2YWx1ZVwiOicpICtcbiAgICAgICAgICB2YWx1ZSArXG4gICAgICAgICAgXCJ9XCIsXG4gICAgICAgIHJlc3BvbnNlXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlSXRlcmF0b3JSZXN1bHRDaHVuayhyZXNwb25zZSwgY2h1bmssIHZhbHVlLCBkb25lKSB7XG4gICAgICByZXNvbHZlTW9kZWxDaHVuayhcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIGNodW5rLFxuICAgICAgICAoZG9uZSA/ICd7XCJkb25lXCI6dHJ1ZSxcInZhbHVlXCI6JyA6ICd7XCJkb25lXCI6ZmFsc2UsXCJ2YWx1ZVwiOicpICtcbiAgICAgICAgICB2YWx1ZSArXG4gICAgICAgICAgXCJ9XCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVNb2RlbENodW5rKHJlc3BvbnNlLCBjaHVuaywgdmFsdWUpIHtcbiAgICAgIGlmIChcInBlbmRpbmdcIiAhPT0gY2h1bmsuc3RhdHVzKSBjaHVuay5yZWFzb24uZW5xdWV1ZU1vZGVsKHZhbHVlKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICByZWxlYXNlUGVuZGluZ0NodW5rKHJlc3BvbnNlLCBjaHVuayk7XG4gICAgICAgIHZhciByZXNvbHZlTGlzdGVuZXJzID0gY2h1bmsudmFsdWUsXG4gICAgICAgICAgcmVqZWN0TGlzdGVuZXJzID0gY2h1bmsucmVhc29uO1xuICAgICAgICBjaHVuay5zdGF0dXMgPSBcInJlc29sdmVkX21vZGVsXCI7XG4gICAgICAgIGNodW5rLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGNodW5rLnJlYXNvbiA9IHJlc3BvbnNlO1xuICAgICAgICBudWxsICE9PSByZXNvbHZlTGlzdGVuZXJzICYmXG4gICAgICAgICAgKGluaXRpYWxpemVNb2RlbENodW5rKGNodW5rKSxcbiAgICAgICAgICB3YWtlQ2h1bmtJZkluaXRpYWxpemVkKFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgIHJlc29sdmVMaXN0ZW5lcnMsXG4gICAgICAgICAgICByZWplY3RMaXN0ZW5lcnNcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZU1vZHVsZUNodW5rKHJlc3BvbnNlLCBjaHVuaywgdmFsdWUpIHtcbiAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gY2h1bmsuc3RhdHVzIHx8IFwiYmxvY2tlZFwiID09PSBjaHVuay5zdGF0dXMpIHtcbiAgICAgICAgcmVsZWFzZVBlbmRpbmdDaHVuayhyZXNwb25zZSwgY2h1bmspO1xuICAgICAgICB2YXIgcmVzb2x2ZUxpc3RlbmVycyA9IGNodW5rLnZhbHVlLFxuICAgICAgICAgIHJlamVjdExpc3RlbmVycyA9IGNodW5rLnJlYXNvbjtcbiAgICAgICAgY2h1bmsuc3RhdHVzID0gXCJyZXNvbHZlZF9tb2R1bGVcIjtcbiAgICAgICAgY2h1bmsudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgY2h1bmsucmVhc29uID0gbnVsbDtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVsxXTtcbiAgICAgICAgZm9yICh2YXIgZGVidWdJbmZvID0gW10sIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyApIHtcbiAgICAgICAgICB2YXIgY2h1bmtJZCA9IHZhbHVlW2krK107XG4gICAgICAgICAgdmFsdWVbaSsrXTtcbiAgICAgICAgICB2YXIgaHJlZiA9IHZvaWQgMCxcbiAgICAgICAgICAgIHRhcmdldCA9IGRlYnVnSW5mbyxcbiAgICAgICAgICAgIGlvSW5mbyA9IGNodW5rSU9JbmZvQ2FjaGUuZ2V0KGNodW5rSWQpO1xuICAgICAgICAgIGlmICh2b2lkIDAgPT09IGlvSW5mbykge1xuICAgICAgICAgICAgdmFyIHNjcmlwdEZpbGVuYW1lID0gX193ZWJwYWNrX2dldF9zY3JpcHRfZmlsZW5hbWVfXyhjaHVua0lkKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGhyZWYgPSBuZXcgVVJMKHNjcmlwdEZpbGVuYW1lLCBkb2N1bWVudC5iYXNlVVJJKS5ocmVmO1xuICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgICBocmVmID0gc2NyaXB0RmlsZW5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZW5kID0gKGlvSW5mbyA9IC0xKTtcbiAgICAgICAgICAgIHNjcmlwdEZpbGVuYW1lID0gMDtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlUeXBlKVxuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciByZXNvdXJjZUVudHJpZXMgPSBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlUeXBlKFwicmVzb3VyY2VcIiksXG4gICAgICAgICAgICAgICAgICBpJGpzY29tcCQwID0gMDtcbiAgICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgcmVzb3VyY2VFbnRyaWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc291cmNlRW50cnkgPSByZXNvdXJjZUVudHJpZXNbaSRqc2NvbXAkMF07XG4gICAgICAgICAgICAgICAgcmVzb3VyY2VFbnRyeS5uYW1lID09PSBocmVmICYmXG4gICAgICAgICAgICAgICAgICAoKGlvSW5mbyA9IHJlc291cmNlRW50cnkuc3RhcnRUaW1lKSxcbiAgICAgICAgICAgICAgICAgIChlbmQgPSBpb0luZm8gKyByZXNvdXJjZUVudHJ5LmR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICAgIChzY3JpcHRGaWxlbmFtZSA9IHJlc291cmNlRW50cnkudHJhbnNmZXJTaXplIHx8IDApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb3VyY2VFbnRyaWVzID0gUHJvbWlzZS5yZXNvbHZlKGhyZWYpO1xuICAgICAgICAgICAgcmVzb3VyY2VFbnRyaWVzLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgICByZXNvdXJjZUVudHJpZXMudmFsdWUgPSB7IGNodW5rSWQ6IGNodW5rSWQsIGhyZWY6IGhyZWYgfTtcbiAgICAgICAgICAgIGkkanNjb21wJDAgPSBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKTtcbiAgICAgICAgICAgIGkkanNjb21wJDAuc3RhY2suc3RhcnRzV2l0aChcIkVycm9yOiByZWFjdC1zdGFjay10b3AtZnJhbWVcIilcbiAgICAgICAgICAgICAgPyAoaSRqc2NvbXAkMC5zdGFjayA9XG4gICAgICAgICAgICAgICAgICBcIkVycm9yOiByZWFjdC1zdGFjay10b3AtZnJhbWVcXG4gICAgYXQgQ2xpZW50IENvbXBvbmVudCBCdW5kbGUgKFwiICtcbiAgICAgICAgICAgICAgICAgIGhyZWYgK1xuICAgICAgICAgICAgICAgICAgXCI6MToxKVxcbiAgICBhdCBDbGllbnQgQ29tcG9uZW50IEJ1bmRsZSAoXCIgK1xuICAgICAgICAgICAgICAgICAgaHJlZiArXG4gICAgICAgICAgICAgICAgICBcIjoxOjEpXCIpXG4gICAgICAgICAgICAgIDogKGkkanNjb21wJDAuc3RhY2sgPVxuICAgICAgICAgICAgICAgICAgXCJDbGllbnQgQ29tcG9uZW50IEJ1bmRsZUBcIiArXG4gICAgICAgICAgICAgICAgICBocmVmICtcbiAgICAgICAgICAgICAgICAgIFwiOjE6MVxcbkNsaWVudCBDb21wb25lbnQgQnVuZGxlQFwiICtcbiAgICAgICAgICAgICAgICAgIGhyZWYgK1xuICAgICAgICAgICAgICAgICAgXCI6MToxXCIpO1xuICAgICAgICAgICAgaW9JbmZvID0ge1xuICAgICAgICAgICAgICBuYW1lOiBcInNjcmlwdFwiLFxuICAgICAgICAgICAgICBzdGFydDogaW9JbmZvLFxuICAgICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgICAgdmFsdWU6IHJlc291cmNlRW50cmllcyxcbiAgICAgICAgICAgICAgZGVidWdTdGFjazogaSRqc2NvbXAkMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIDAgPCBzY3JpcHRGaWxlbmFtZSAmJiAoaW9JbmZvLmJ5dGVTaXplID0gc2NyaXB0RmlsZW5hbWUpO1xuICAgICAgICAgICAgY2h1bmtJT0luZm9DYWNoZS5zZXQoY2h1bmtJZCwgaW9JbmZvKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0LnB1c2goeyBhd2FpdGVkOiBpb0luZm8gfSk7XG4gICAgICAgIH1cbiAgICAgICAgbnVsbCAhPT0gZGVidWdJbmZvICYmXG4gICAgICAgICAgY2h1bmsuX2RlYnVnSW5mby5wdXNoLmFwcGx5KGNodW5rLl9kZWJ1Z0luZm8sIGRlYnVnSW5mbyk7XG4gICAgICAgIG51bGwgIT09IHJlc29sdmVMaXN0ZW5lcnMgJiZcbiAgICAgICAgICAoaW5pdGlhbGl6ZU1vZHVsZUNodW5rKGNodW5rKSxcbiAgICAgICAgICB3YWtlQ2h1bmtJZkluaXRpYWxpemVkKFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgIHJlc29sdmVMaXN0ZW5lcnMsXG4gICAgICAgICAgICByZWplY3RMaXN0ZW5lcnNcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZURlYnVnQ2h1bmsocmVzcG9uc2UsIGNodW5rKSB7XG4gICAgICB2YXIgZGVidWdDaHVuayA9IGNodW5rLl9kZWJ1Z0NodW5rO1xuICAgICAgaWYgKG51bGwgIT09IGRlYnVnQ2h1bmspIHtcbiAgICAgICAgdmFyIGRlYnVnSW5mbyA9IGNodW5rLl9kZWJ1Z0luZm87XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKFwicmVzb2x2ZWRfbW9kZWxcIiA9PT0gZGVidWdDaHVuay5zdGF0dXMpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIHZhciBpZHggPSBkZWJ1Z0luZm8ubGVuZ3RoLCBjID0gZGVidWdDaHVuay5fZGVidWdDaHVuaztcbiAgICAgICAgICAgICAgbnVsbCAhPT0gYztcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBcImZ1bGZpbGxlZFwiICE9PSBjLnN0YXR1cyAmJiBpZHgrKywgKGMgPSBjLl9kZWJ1Z0NodW5rKTtcbiAgICAgICAgICAgIGluaXRpYWxpemVNb2RlbENodW5rKGRlYnVnQ2h1bmspO1xuICAgICAgICAgICAgc3dpdGNoIChkZWJ1Z0NodW5rLnN0YXR1cykge1xuICAgICAgICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgICAgICAgZGVidWdJbmZvW2lkeF0gPSBpbml0aWFsaXplRGVidWdJbmZvKFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICBkZWJ1Z0NodW5rLnZhbHVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImJsb2NrZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICAgICAgICB3YWl0Rm9yUmVmZXJlbmNlKFxuICAgICAgICAgICAgICAgICAgZGVidWdDaHVuayxcbiAgICAgICAgICAgICAgICAgIGRlYnVnSW5mbyxcbiAgICAgICAgICAgICAgICAgIFwiXCIgKyBpZHgsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVEZWJ1Z0luZm8sXG4gICAgICAgICAgICAgICAgICBbXCJcIl0sXG4gICAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVidWdDaHVuay5yZWFzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBzd2l0Y2ggKGRlYnVnQ2h1bmsuc3RhdHVzKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImJsb2NrZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICAgICAgICB3YWl0Rm9yUmVmZXJlbmNlKFxuICAgICAgICAgICAgICAgICAgZGVidWdDaHVuayxcbiAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICBpbml0aWFsaXplRGVidWdJbmZvLFxuICAgICAgICAgICAgICAgICAgW1wiXCJdLFxuICAgICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IGRlYnVnQ2h1bmsucmVhc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRyaWdnZXJFcnJvck9uQ2h1bmsocmVzcG9uc2UsIGNodW5rLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZU1vZGVsQ2h1bmsoY2h1bmspIHtcbiAgICAgIHZhciBwcmV2SGFuZGxlciA9IGluaXRpYWxpemluZ0hhbmRsZXIsXG4gICAgICAgIHByZXZDaHVuayA9IGluaXRpYWxpemluZ0NodW5rO1xuICAgICAgaW5pdGlhbGl6aW5nSGFuZGxlciA9IG51bGw7XG4gICAgICB2YXIgcmVzb2x2ZWRNb2RlbCA9IGNodW5rLnZhbHVlLFxuICAgICAgICByZXNwb25zZSA9IGNodW5rLnJlYXNvbjtcbiAgICAgIGNodW5rLnN0YXR1cyA9IFwiYmxvY2tlZFwiO1xuICAgICAgY2h1bmsudmFsdWUgPSBudWxsO1xuICAgICAgY2h1bmsucmVhc29uID0gbnVsbDtcbiAgICAgIGluaXRpYWxpemluZ0NodW5rID0gY2h1bms7XG4gICAgICBpbml0aWFsaXplRGVidWdDaHVuayhyZXNwb25zZSwgY2h1bmspO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHZhbHVlID0gSlNPTi5wYXJzZShyZXNvbHZlZE1vZGVsLCByZXNwb25zZS5fZnJvbUpTT04pLFxuICAgICAgICAgIHJlc29sdmVMaXN0ZW5lcnMgPSBjaHVuay52YWx1ZTtcbiAgICAgICAgaWYgKG51bGwgIT09IHJlc29sdmVMaXN0ZW5lcnMpXG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIGNodW5rLnZhbHVlID0gbnVsbCwgY2h1bmsucmVhc29uID0gbnVsbCwgcmVzb2x2ZWRNb2RlbCA9IDA7XG4gICAgICAgICAgICByZXNvbHZlZE1vZGVsIDwgcmVzb2x2ZUxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgICAgICByZXNvbHZlZE1vZGVsKytcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHJlc29sdmVMaXN0ZW5lcnNbcmVzb2x2ZWRNb2RlbF07XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsaXN0ZW5lclxuICAgICAgICAgICAgICA/IGxpc3RlbmVyKHZhbHVlKVxuICAgICAgICAgICAgICA6IGZ1bGZpbGxSZWZlcmVuY2UocmVzcG9uc2UsIGxpc3RlbmVyLCB2YWx1ZSwgY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgaWYgKG51bGwgIT09IGluaXRpYWxpemluZ0hhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoaW5pdGlhbGl6aW5nSGFuZGxlci5lcnJvcmVkKSB0aHJvdyBpbml0aWFsaXppbmdIYW5kbGVyLnJlYXNvbjtcbiAgICAgICAgICBpZiAoMCA8IGluaXRpYWxpemluZ0hhbmRsZXIuZGVwcykge1xuICAgICAgICAgICAgaW5pdGlhbGl6aW5nSGFuZGxlci52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaW5pdGlhbGl6aW5nSGFuZGxlci5jaHVuayA9IGNodW5rO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaHVuay5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICBjaHVuay52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBmaWx0ZXJEZWJ1Z0luZm8ocmVzcG9uc2UsIGNodW5rKTtcbiAgICAgICAgbW92ZURlYnVnSW5mb0Zyb21DaHVua1RvSW5uZXJWYWx1ZShjaHVuaywgdmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgKGNodW5rLnN0YXR1cyA9IFwicmVqZWN0ZWRcIiksIChjaHVuay5yZWFzb24gPSBlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAoaW5pdGlhbGl6aW5nSGFuZGxlciA9IHByZXZIYW5kbGVyKSwgKGluaXRpYWxpemluZ0NodW5rID0gcHJldkNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZU1vZHVsZUNodW5rKGNodW5rKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdmFsdWUgPSByZXF1aXJlTW9kdWxlKGNodW5rLnZhbHVlKTtcbiAgICAgICAgY2h1bmsuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgY2h1bmsudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIChjaHVuay5zdGF0dXMgPSBcInJlamVjdGVkXCIpLCAoY2h1bmsucmVhc29uID0gZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXBvcnRHbG9iYWxFcnJvcih3ZWFrUmVzcG9uc2UsIGVycm9yKSB7XG4gICAgICBpZiAodm9pZCAwICE9PSB3ZWFrUmVzcG9uc2Uud2Vhay5kZXJlZigpKSB7XG4gICAgICAgIHZhciByZXNwb25zZSA9IHVud3JhcFdlYWtSZXNwb25zZSh3ZWFrUmVzcG9uc2UpO1xuICAgICAgICByZXNwb25zZS5fY2xvc2VkID0gITA7XG4gICAgICAgIHJlc3BvbnNlLl9jbG9zZWRSZWFzb24gPSBlcnJvcjtcbiAgICAgICAgcmVzcG9uc2UuX2NodW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgIFwicGVuZGluZ1wiID09PSBjaHVuay5zdGF0dXNcbiAgICAgICAgICAgID8gdHJpZ2dlckVycm9yT25DaHVuayhyZXNwb25zZSwgY2h1bmssIGVycm9yKVxuICAgICAgICAgICAgOiBcImZ1bGZpbGxlZFwiID09PSBjaHVuay5zdGF0dXMgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY2h1bmsucmVhc29uICYmXG4gICAgICAgICAgICAgIGNodW5rLnJlYXNvbi5lcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICB3ZWFrUmVzcG9uc2UgPSByZXNwb25zZS5fZGVidWdDaGFubmVsO1xuICAgICAgICB2b2lkIDAgIT09IHdlYWtSZXNwb25zZSAmJlxuICAgICAgICAgIChjbG9zZURlYnVnQ2hhbm5lbCh3ZWFrUmVzcG9uc2UpLFxuICAgICAgICAgIChyZXNwb25zZS5fZGVidWdDaGFubmVsID0gdm9pZCAwKSxcbiAgICAgICAgICBudWxsICE9PSBkZWJ1Z0NoYW5uZWxSZWdpc3RyeSAmJlxuICAgICAgICAgICAgZGVidWdDaGFubmVsUmVnaXN0cnkudW5yZWdpc3RlcihyZXNwb25zZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBudWxsUmVmR2V0dGVyKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRhc2tOYW1lKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSByZXR1cm4gXCI8PlwiO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiAnXCJ1c2UgY2xpZW50XCInO1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRVxuICAgICAgKVxuICAgICAgICByZXR1cm4gdHlwZS5faW5pdCA9PT0gcmVhZENodW5rID8gJ1widXNlIGNsaWVudFwiJyA6IFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplRWxlbWVudChyZXNwb25zZSwgZWxlbWVudCwgbGF6eU5vZGUpIHtcbiAgICAgIHZhciBzdGFjayA9IGVsZW1lbnQuX2RlYnVnU3RhY2ssXG4gICAgICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICBudWxsID09PSBvd25lciAmJiAoZWxlbWVudC5fb3duZXIgPSByZXNwb25zZS5fZGVidWdSb290T3duZXIpO1xuICAgICAgdmFyIGVudiA9IHJlc3BvbnNlLl9yb290RW52aXJvbm1lbnROYW1lO1xuICAgICAgbnVsbCAhPT0gb3duZXIgJiYgbnVsbCAhPSBvd25lci5lbnYgJiYgKGVudiA9IG93bmVyLmVudik7XG4gICAgICB2YXIgbm9ybWFsaXplZFN0YWNrVHJhY2UgPSBudWxsO1xuICAgICAgbnVsbCA9PT0gb3duZXIgJiYgbnVsbCAhPSByZXNwb25zZS5fZGVidWdSb290U3RhY2tcbiAgICAgICAgPyAobm9ybWFsaXplZFN0YWNrVHJhY2UgPSByZXNwb25zZS5fZGVidWdSb290U3RhY2spXG4gICAgICAgIDogbnVsbCAhPT0gc3RhY2sgJiZcbiAgICAgICAgICAobm9ybWFsaXplZFN0YWNrVHJhY2UgPSBjcmVhdGVGYWtlSlNYQ2FsbFN0YWNrSW5ERVYoXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgICAgZW52XG4gICAgICAgICAgKSk7XG4gICAgICBlbGVtZW50Ll9kZWJ1Z1N0YWNrID0gbm9ybWFsaXplZFN0YWNrVHJhY2U7XG4gICAgICBub3JtYWxpemVkU3RhY2tUcmFjZSA9IG51bGw7XG4gICAgICBzdXBwb3J0c0NyZWF0ZVRhc2sgJiZcbiAgICAgICAgbnVsbCAhPT0gc3RhY2sgJiZcbiAgICAgICAgKChub3JtYWxpemVkU3RhY2tUcmFjZSA9IGNvbnNvbGUuY3JlYXRlVGFzay5iaW5kKFxuICAgICAgICAgIGNvbnNvbGUsXG4gICAgICAgICAgZ2V0VGFza05hbWUoZWxlbWVudC50eXBlKVxuICAgICAgICApKSxcbiAgICAgICAgKHN0YWNrID0gYnVpbGRGYWtlQ2FsbFN0YWNrKFxuICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgIGVudixcbiAgICAgICAgICAhMSxcbiAgICAgICAgICBub3JtYWxpemVkU3RhY2tUcmFjZVxuICAgICAgICApKSxcbiAgICAgICAgKGVudiA9IG51bGwgPT09IG93bmVyID8gbnVsbCA6IGluaXRpYWxpemVGYWtlVGFzayhyZXNwb25zZSwgb3duZXIpKSxcbiAgICAgICAgbnVsbCA9PT0gZW52XG4gICAgICAgICAgPyAoKGVudiA9IHJlc3BvbnNlLl9kZWJ1Z1Jvb3RUYXNrKSxcbiAgICAgICAgICAgIChub3JtYWxpemVkU3RhY2tUcmFjZSA9IG51bGwgIT0gZW52ID8gZW52LnJ1bihzdGFjaykgOiBzdGFjaygpKSlcbiAgICAgICAgICA6IChub3JtYWxpemVkU3RhY2tUcmFjZSA9IGVudi5ydW4oc3RhY2spKSk7XG4gICAgICBlbGVtZW50Ll9kZWJ1Z1Rhc2sgPSBub3JtYWxpemVkU3RhY2tUcmFjZTtcbiAgICAgIG51bGwgIT09IG93bmVyICYmIGluaXRpYWxpemVGYWtlU3RhY2socmVzcG9uc2UsIG93bmVyKTtcbiAgICAgIG51bGwgIT09IGxhenlOb2RlICYmXG4gICAgICAgIChsYXp5Tm9kZS5fc3RvcmUgJiZcbiAgICAgICAgICBsYXp5Tm9kZS5fc3RvcmUudmFsaWRhdGVkICYmXG4gICAgICAgICAgIWVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCAmJlxuICAgICAgICAgIChlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSBsYXp5Tm9kZS5fc3RvcmUudmFsaWRhdGVkKSxcbiAgICAgICAgXCJmdWxmaWxsZWRcIiA9PT0gbGF6eU5vZGUuX3BheWxvYWQuc3RhdHVzICYmXG4gICAgICAgICAgbGF6eU5vZGUuX2RlYnVnSW5mbyAmJlxuICAgICAgICAgICgocmVzcG9uc2UgPSBsYXp5Tm9kZS5fZGVidWdJbmZvLnNwbGljZSgwKSksXG4gICAgICAgICAgZWxlbWVudC5fZGVidWdJbmZvXG4gICAgICAgICAgICA/IGVsZW1lbnQuX2RlYnVnSW5mby51bnNoaWZ0LmFwcGx5KGVsZW1lbnQuX2RlYnVnSW5mbywgcmVzcG9uc2UpXG4gICAgICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXNwb25zZVxuICAgICAgICAgICAgICB9KSkpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTGF6eUNodW5rV3JhcHBlcihjaHVuaywgdmFsaWRhdGVkKSB7XG4gICAgICB2YXIgbGF6eVR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgICAgIF9wYXlsb2FkOiBjaHVuayxcbiAgICAgICAgX2luaXQ6IHJlYWRDaHVua1xuICAgICAgfTtcbiAgICAgIGxhenlUeXBlLl9kZWJ1Z0luZm8gPSBjaHVuay5fZGVidWdJbmZvO1xuICAgICAgbGF6eVR5cGUuX3N0b3JlID0geyB2YWxpZGF0ZWQ6IHZhbGlkYXRlZCB9O1xuICAgICAgcmV0dXJuIGxhenlUeXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDaHVuayhyZXNwb25zZSwgaWQpIHtcbiAgICAgIHZhciBjaHVua3MgPSByZXNwb25zZS5fY2h1bmtzLFxuICAgICAgICBjaHVuayA9IGNodW5rcy5nZXQoaWQpO1xuICAgICAgY2h1bmsgfHxcbiAgICAgICAgKChjaHVuayA9IHJlc3BvbnNlLl9jbG9zZWRcbiAgICAgICAgICA/IG5ldyBSZWFjdFByb21pc2UoXCJyZWplY3RlZFwiLCBudWxsLCByZXNwb25zZS5fY2xvc2VkUmVhc29uKVxuICAgICAgICAgIDogY3JlYXRlUGVuZGluZ0NodW5rKHJlc3BvbnNlKSksXG4gICAgICAgIGNodW5rcy5zZXQoaWQsIGNodW5rKSk7XG4gICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGxSZWZlcmVuY2UocmVzcG9uc2UsIHJlZmVyZW5jZSwgdmFsdWUsIGZ1bGZpbGxlZENodW5rKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IHJlZmVyZW5jZS5oYW5kbGVyLFxuICAgICAgICBwYXJlbnRPYmplY3QgPSByZWZlcmVuY2UucGFyZW50T2JqZWN0LFxuICAgICAgICBrZXkgPSByZWZlcmVuY2Uua2V5LFxuICAgICAgICBtYXAgPSByZWZlcmVuY2UubWFwLFxuICAgICAgICBwYXRoID0gcmVmZXJlbmNlLnBhdGg7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICBudWxsICE9PSB2YWx1ZSAmJlxuICAgICAgICAgICAgdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRTtcblxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHJlZmVyZW5jZWRDaHVuayA9IHZhbHVlLl9wYXlsb2FkO1xuICAgICAgICAgICAgaWYgKHJlZmVyZW5jZWRDaHVuayA9PT0gaGFuZGxlci5jaHVuaykgdmFsdWUgPSBoYW5kbGVyLnZhbHVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAocmVmZXJlbmNlZENodW5rLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNvbHZlZF9tb2RlbFwiOlxuICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZU1vZGVsQ2h1bmsocmVmZXJlbmNlZENodW5rKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNvbHZlZF9tb2R1bGVcIjpcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVNb2R1bGVDaHVuayhyZWZlcmVuY2VkQ2h1bmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN3aXRjaCAocmVmZXJlbmNlZENodW5rLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVmZXJlbmNlZENodW5rLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJsb2NrZWRcIjpcbiAgICAgICAgICAgICAgICAgIHZhciBjeWNsaWNIYW5kbGVyID0gcmVzb2x2ZUJsb2NrZWRDeWNsZShcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlZENodW5rLFxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gY3ljbGljSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGN5Y2xpY0hhbmRsZXIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICAgICAgICBwYXRoLnNwbGljZSgwLCBpIC0gMSk7XG4gICAgICAgICAgICAgICAgICBudWxsID09PSByZWZlcmVuY2VkQ2h1bmsudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgPyAocmVmZXJlbmNlZENodW5rLnZhbHVlID0gW3JlZmVyZW5jZV0pXG4gICAgICAgICAgICAgICAgICAgIDogcmVmZXJlbmNlZENodW5rLnZhbHVlLnB1c2gocmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IHJlZmVyZW5jZWRDaHVuay5yZWFzb25cbiAgICAgICAgICAgICAgICAgICAgPyAocmVmZXJlbmNlZENodW5rLnJlYXNvbiA9IFtyZWZlcmVuY2VdKVxuICAgICAgICAgICAgICAgICAgICA6IHJlZmVyZW5jZWRDaHVuay5yZWFzb24ucHVzaChyZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJoYWx0ZWRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmVqZWN0UmVmZXJlbmNlKFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlLmhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZWRDaHVuay5yZWFzb25cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5hbWUgPSBwYXRoW2ldO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gdmFsdWUgJiZcbiAgICAgICAgICAgIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIG5hbWUpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtuYW1lXTtcbiAgICAgICAgICBlbHNlIHRocm93IEVycm9yKFwiSW52YWxpZCByZWZlcmVuY2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgO1xuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgIG51bGwgIT09IHZhbHVlICYmXG4gICAgICAgICAgdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRTtcblxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgX3JlZmVyZW5jZWRDaHVuayA9IHZhbHVlLl9wYXlsb2FkO1xuICAgICAgICAgIGlmIChfcmVmZXJlbmNlZENodW5rID09PSBoYW5kbGVyLmNodW5rKSB2YWx1ZSA9IGhhbmRsZXIudmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9yZWZlcmVuY2VkQ2h1bmsuc3RhdHVzKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJyZXNvbHZlZF9tb2RlbFwiOlxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVNb2RlbENodW5rKF9yZWZlcmVuY2VkQ2h1bmspO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwicmVzb2x2ZWRfbW9kdWxlXCI6XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZU1vZHVsZUNodW5rKF9yZWZlcmVuY2VkQ2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChfcmVmZXJlbmNlZENodW5rLnN0YXR1cykge1xuICAgICAgICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfcmVmZXJlbmNlZENodW5rLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBtYXBwZWRWYWx1ZSA9IG1hcChyZXNwb25zZSwgdmFsdWUsIHBhcmVudE9iamVjdCwga2V5KTtcbiAgICAgICAgXCJfX3Byb3RvX19cIiAhPT0ga2V5ICYmIChwYXJlbnRPYmplY3Rba2V5XSA9IG1hcHBlZFZhbHVlKTtcbiAgICAgICAgXCJcIiA9PT0ga2V5ICYmIG51bGwgPT09IGhhbmRsZXIudmFsdWUgJiYgKGhhbmRsZXIudmFsdWUgPSBtYXBwZWRWYWx1ZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwYXJlbnRPYmplY3RbMF0gPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJlxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBoYW5kbGVyLnZhbHVlICYmXG4gICAgICAgICAgbnVsbCAhPT0gaGFuZGxlci52YWx1ZSAmJlxuICAgICAgICAgIGhhbmRsZXIudmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IGhhbmRsZXIudmFsdWU7XG4gICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgICAgICAgIHRyYW5zZmVyUmVmZXJlbmNlZERlYnVnSW5mbyhoYW5kbGVyLmNodW5rLCBmdWxmaWxsZWRDaHVuayk7XG4gICAgICAgICAgICAgIGVsZW1lbnQucHJvcHMgPSBtYXBwZWRWYWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiNFwiOlxuICAgICAgICAgICAgICBlbGVtZW50Ll9vd25lciA9IG1hcHBlZFZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI1XCI6XG4gICAgICAgICAgICAgIGVsZW1lbnQuX2RlYnVnU3RhY2sgPSBtYXBwZWRWYWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0cmFuc2ZlclJlZmVyZW5jZWREZWJ1Z0luZm8oaGFuZGxlci5jaHVuaywgZnVsZmlsbGVkQ2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgcmVmZXJlbmNlLmlzRGVidWcgfHxcbiAgICAgICAgICAgIHRyYW5zZmVyUmVmZXJlbmNlZERlYnVnSW5mbyhoYW5kbGVyLmNodW5rLCBmdWxmaWxsZWRDaHVuayk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3RSZWZlcmVuY2UocmVzcG9uc2UsIHJlZmVyZW5jZS5oYW5kbGVyLCBlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGhhbmRsZXIuZGVwcy0tO1xuICAgICAgMCA9PT0gaGFuZGxlci5kZXBzICYmXG4gICAgICAgICgocmVmZXJlbmNlID0gaGFuZGxlci5jaHVuayksXG4gICAgICAgIG51bGwgIT09IHJlZmVyZW5jZSAmJlxuICAgICAgICAgIFwiYmxvY2tlZFwiID09PSByZWZlcmVuY2Uuc3RhdHVzICYmXG4gICAgICAgICAgKCh2YWx1ZSA9IHJlZmVyZW5jZS52YWx1ZSksXG4gICAgICAgICAgKHJlZmVyZW5jZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiKSxcbiAgICAgICAgICAocmVmZXJlbmNlLnZhbHVlID0gaGFuZGxlci52YWx1ZSksXG4gICAgICAgICAgKHJlZmVyZW5jZS5yZWFzb24gPSBoYW5kbGVyLnJlYXNvbiksXG4gICAgICAgICAgbnVsbCAhPT0gdmFsdWVcbiAgICAgICAgICAgID8gd2FrZUNodW5rKHJlc3BvbnNlLCB2YWx1ZSwgaGFuZGxlci52YWx1ZSwgcmVmZXJlbmNlKVxuICAgICAgICAgICAgOiAoKGhhbmRsZXIgPSBoYW5kbGVyLnZhbHVlKSxcbiAgICAgICAgICAgICAgZmlsdGVyRGVidWdJbmZvKHJlc3BvbnNlLCByZWZlcmVuY2UpLFxuICAgICAgICAgICAgICBtb3ZlRGVidWdJbmZvRnJvbUNodW5rVG9Jbm5lclZhbHVlKHJlZmVyZW5jZSwgaGFuZGxlcikpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlamVjdFJlZmVyZW5jZShyZXNwb25zZSwgaGFuZGxlciwgZXJyb3IpIHtcbiAgICAgIGlmICghaGFuZGxlci5lcnJvcmVkKSB7XG4gICAgICAgIHZhciBibG9ja2VkVmFsdWUgPSBoYW5kbGVyLnZhbHVlO1xuICAgICAgICBoYW5kbGVyLmVycm9yZWQgPSAhMDtcbiAgICAgICAgaGFuZGxlci52YWx1ZSA9IG51bGw7XG4gICAgICAgIGhhbmRsZXIucmVhc29uID0gZXJyb3I7XG4gICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyLmNodW5rO1xuICAgICAgICBpZiAobnVsbCAhPT0gaGFuZGxlciAmJiBcImJsb2NrZWRcIiA9PT0gaGFuZGxlci5zdGF0dXMpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgYmxvY2tlZFZhbHVlICYmXG4gICAgICAgICAgICBudWxsICE9PSBibG9ja2VkVmFsdWUgJiZcbiAgICAgICAgICAgIGJsb2NrZWRWYWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JlZENvbXBvbmVudCA9IHtcbiAgICAgICAgICAgICAgbmFtZTogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGJsb2NrZWRWYWx1ZS50eXBlKSB8fCBcIlwiLFxuICAgICAgICAgICAgICBvd25lcjogYmxvY2tlZFZhbHVlLl9vd25lclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVycm9yZWRDb21wb25lbnQuZGVidWdTdGFjayA9IGJsb2NrZWRWYWx1ZS5fZGVidWdTdGFjaztcbiAgICAgICAgICAgIHN1cHBvcnRzQ3JlYXRlVGFzayAmJlxuICAgICAgICAgICAgICAoZXJyb3JlZENvbXBvbmVudC5kZWJ1Z1Rhc2sgPSBibG9ja2VkVmFsdWUuX2RlYnVnVGFzayk7XG4gICAgICAgICAgICBoYW5kbGVyLl9kZWJ1Z0luZm8ucHVzaChlcnJvcmVkQ29tcG9uZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJpZ2dlckVycm9yT25DaHVuayhyZXNwb25zZSwgaGFuZGxlciwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhaXRGb3JSZWZlcmVuY2UoXG4gICAgICByZWZlcmVuY2VkQ2h1bmssXG4gICAgICBwYXJlbnRPYmplY3QsXG4gICAgICBrZXksXG4gICAgICByZXNwb25zZSxcbiAgICAgIG1hcCxcbiAgICAgIHBhdGgsXG4gICAgICBpc0F3YWl0aW5nRGVidWdJbmZvXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgICEoXG4gICAgICAgICAgKHZvaWQgMCAhPT0gcmVzcG9uc2UuX2RlYnVnQ2hhbm5lbCAmJlxuICAgICAgICAgICAgcmVzcG9uc2UuX2RlYnVnQ2hhbm5lbC5oYXNSZWFkYWJsZSkgfHxcbiAgICAgICAgICBcInBlbmRpbmdcIiAhPT0gcmVmZXJlbmNlZENodW5rLnN0YXR1cyB8fFxuICAgICAgICAgIHBhcmVudE9iamVjdFswXSAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFIHx8XG4gICAgICAgICAgKFwiNFwiICE9PSBrZXkgJiYgXCI1XCIgIT09IGtleSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGluaXRpYWxpemluZ0hhbmRsZXJcbiAgICAgICAgPyAoKHJlc3BvbnNlID0gaW5pdGlhbGl6aW5nSGFuZGxlciksIHJlc3BvbnNlLmRlcHMrKylcbiAgICAgICAgOiAocmVzcG9uc2UgPSBpbml0aWFsaXppbmdIYW5kbGVyID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICBjaHVuazogbnVsbCxcbiAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgIHJlYXNvbjogbnVsbCxcbiAgICAgICAgICAgICAgZGVwczogMSxcbiAgICAgICAgICAgICAgZXJyb3JlZDogITFcbiAgICAgICAgICAgIH0pO1xuICAgICAgcGFyZW50T2JqZWN0ID0ge1xuICAgICAgICBoYW5kbGVyOiByZXNwb25zZSxcbiAgICAgICAgcGFyZW50T2JqZWN0OiBwYXJlbnRPYmplY3QsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBtYXA6IG1hcCxcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfTtcbiAgICAgIHBhcmVudE9iamVjdC5pc0RlYnVnID0gaXNBd2FpdGluZ0RlYnVnSW5mbztcbiAgICAgIG51bGwgPT09IHJlZmVyZW5jZWRDaHVuay52YWx1ZVxuICAgICAgICA/IChyZWZlcmVuY2VkQ2h1bmsudmFsdWUgPSBbcGFyZW50T2JqZWN0XSlcbiAgICAgICAgOiByZWZlcmVuY2VkQ2h1bmsudmFsdWUucHVzaChwYXJlbnRPYmplY3QpO1xuICAgICAgbnVsbCA9PT0gcmVmZXJlbmNlZENodW5rLnJlYXNvblxuICAgICAgICA/IChyZWZlcmVuY2VkQ2h1bmsucmVhc29uID0gW3BhcmVudE9iamVjdF0pXG4gICAgICAgIDogcmVmZXJlbmNlZENodW5rLnJlYXNvbi5wdXNoKHBhcmVudE9iamVjdCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9hZFNlcnZlclJlZmVyZW5jZShyZXNwb25zZSwgbWV0YURhdGEsIHBhcmVudE9iamVjdCwga2V5KSB7XG4gICAgICBpZiAoIXJlc3BvbnNlLl9zZXJ2ZXJSZWZlcmVuY2VDb25maWcpXG4gICAgICAgIHJldHVybiBjcmVhdGVCb3VuZFNlcnZlclJlZmVyZW5jZShcbiAgICAgICAgICBtZXRhRGF0YSxcbiAgICAgICAgICByZXNwb25zZS5fY2FsbFNlcnZlcixcbiAgICAgICAgICByZXNwb25zZS5fZW5jb2RlRm9ybUFjdGlvbixcbiAgICAgICAgICByZXNwb25zZS5fZGVidWdGaW5kU291cmNlTWFwVVJMXG4gICAgICAgICk7XG4gICAgICB2YXIgc2VydmVyUmVmZXJlbmNlID0gcmVzb2x2ZVNlcnZlclJlZmVyZW5jZShcbiAgICAgICAgICByZXNwb25zZS5fc2VydmVyUmVmZXJlbmNlQ29uZmlnLFxuICAgICAgICAgIG1ldGFEYXRhLmlkXG4gICAgICAgICksXG4gICAgICAgIHByb21pc2UgPSBwcmVsb2FkTW9kdWxlKHNlcnZlclJlZmVyZW5jZSk7XG4gICAgICBpZiAocHJvbWlzZSlcbiAgICAgICAgbWV0YURhdGEuYm91bmQgJiYgKHByb21pc2UgPSBQcm9taXNlLmFsbChbcHJvbWlzZSwgbWV0YURhdGEuYm91bmRdKSk7XG4gICAgICBlbHNlIGlmIChtZXRhRGF0YS5ib3VuZCkgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShtZXRhRGF0YS5ib3VuZCk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHByb21pc2UgPSByZXF1aXJlTW9kdWxlKHNlcnZlclJlZmVyZW5jZSkpLFxuICAgICAgICAgIHJlZ2lzdGVyQm91bmRTZXJ2ZXJSZWZlcmVuY2UocHJvbWlzZSwgbWV0YURhdGEuaWQsIG1ldGFEYXRhLmJvdW5kKSxcbiAgICAgICAgICBwcm9taXNlXG4gICAgICAgICk7XG4gICAgICBpZiAoaW5pdGlhbGl6aW5nSGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGluaXRpYWxpemluZ0hhbmRsZXI7XG4gICAgICAgIGhhbmRsZXIuZGVwcysrO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGhhbmRsZXIgPSBpbml0aWFsaXppbmdIYW5kbGVyID0ge1xuICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICBjaHVuazogbnVsbCxcbiAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICByZWFzb246IG51bGwsXG4gICAgICAgICAgZGVwczogMSxcbiAgICAgICAgICBlcnJvcmVkOiAhMVxuICAgICAgICB9O1xuICAgICAgcHJvbWlzZS50aGVuKFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJlc29sdmVkVmFsdWUgPSByZXF1aXJlTW9kdWxlKHNlcnZlclJlZmVyZW5jZSk7XG4gICAgICAgICAgaWYgKG1ldGFEYXRhLmJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgYm91bmRBcmdzID0gbWV0YURhdGEuYm91bmQudmFsdWUuc2xpY2UoMCk7XG4gICAgICAgICAgICBib3VuZEFyZ3MudW5zaGlmdChudWxsKTtcbiAgICAgICAgICAgIHJlc29sdmVkVmFsdWUgPSByZXNvbHZlZFZhbHVlLmJpbmQuYXBwbHkocmVzb2x2ZWRWYWx1ZSwgYm91bmRBcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVnaXN0ZXJCb3VuZFNlcnZlclJlZmVyZW5jZShcbiAgICAgICAgICAgIHJlc29sdmVkVmFsdWUsXG4gICAgICAgICAgICBtZXRhRGF0YS5pZCxcbiAgICAgICAgICAgIG1ldGFEYXRhLmJvdW5kXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcIl9fcHJvdG9fX1wiICE9PSBrZXkgJiYgKHBhcmVudE9iamVjdFtrZXldID0gcmVzb2x2ZWRWYWx1ZSk7XG4gICAgICAgICAgXCJcIiA9PT0ga2V5ICYmXG4gICAgICAgICAgICBudWxsID09PSBoYW5kbGVyLnZhbHVlICYmXG4gICAgICAgICAgICAoaGFuZGxlci52YWx1ZSA9IHJlc29sdmVkVmFsdWUpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHBhcmVudE9iamVjdFswXSA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFICYmXG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgaGFuZGxlci52YWx1ZSAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gaGFuZGxlci52YWx1ZSAmJlxuICAgICAgICAgICAgaGFuZGxlci52YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG4gICAgICAgICAgKVxuICAgICAgICAgICAgc3dpdGNoICgoKGJvdW5kQXJncyA9IGhhbmRsZXIudmFsdWUpLCBrZXkpKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgICAgICAgICAgYm91bmRBcmdzLnByb3BzID0gcmVzb2x2ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgICAgICAgICBib3VuZEFyZ3MuX293bmVyID0gcmVzb2x2ZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBoYW5kbGVyLmRlcHMtLTtcbiAgICAgICAgICAwID09PSBoYW5kbGVyLmRlcHMgJiZcbiAgICAgICAgICAgICgocmVzb2x2ZWRWYWx1ZSA9IGhhbmRsZXIuY2h1bmspLFxuICAgICAgICAgICAgbnVsbCAhPT0gcmVzb2x2ZWRWYWx1ZSAmJlxuICAgICAgICAgICAgICBcImJsb2NrZWRcIiA9PT0gcmVzb2x2ZWRWYWx1ZS5zdGF0dXMgJiZcbiAgICAgICAgICAgICAgKChib3VuZEFyZ3MgPSByZXNvbHZlZFZhbHVlLnZhbHVlKSxcbiAgICAgICAgICAgICAgKHJlc29sdmVkVmFsdWUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIiksXG4gICAgICAgICAgICAgIChyZXNvbHZlZFZhbHVlLnZhbHVlID0gaGFuZGxlci52YWx1ZSksXG4gICAgICAgICAgICAgIChyZXNvbHZlZFZhbHVlLnJlYXNvbiA9IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBib3VuZEFyZ3NcbiAgICAgICAgICAgICAgICA/IHdha2VDaHVuayhyZXNwb25zZSwgYm91bmRBcmdzLCBoYW5kbGVyLnZhbHVlLCByZXNvbHZlZFZhbHVlKVxuICAgICAgICAgICAgICAgIDogKChib3VuZEFyZ3MgPSBoYW5kbGVyLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgIGZpbHRlckRlYnVnSW5mbyhyZXNwb25zZSwgcmVzb2x2ZWRWYWx1ZSksXG4gICAgICAgICAgICAgICAgICBtb3ZlRGVidWdJbmZvRnJvbUNodW5rVG9Jbm5lclZhbHVlKFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBib3VuZEFyZ3NcbiAgICAgICAgICAgICAgICAgICkpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGlmICghaGFuZGxlci5lcnJvcmVkKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tlZFZhbHVlID0gaGFuZGxlci52YWx1ZTtcbiAgICAgICAgICAgIGhhbmRsZXIuZXJyb3JlZCA9ICEwO1xuICAgICAgICAgICAgaGFuZGxlci52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBoYW5kbGVyLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgdmFyIGNodW5rID0gaGFuZGxlci5jaHVuaztcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBjaHVuayAmJiBcImJsb2NrZWRcIiA9PT0gY2h1bmsuc3RhdHVzKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgYmxvY2tlZFZhbHVlICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gYmxvY2tlZFZhbHVlICYmXG4gICAgICAgICAgICAgICAgYmxvY2tlZFZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yZWRDb21wb25lbnQgPSB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoYmxvY2tlZFZhbHVlLnR5cGUpIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICBvd25lcjogYmxvY2tlZFZhbHVlLl9vd25lclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZXJyb3JlZENvbXBvbmVudC5kZWJ1Z1N0YWNrID0gYmxvY2tlZFZhbHVlLl9kZWJ1Z1N0YWNrO1xuICAgICAgICAgICAgICAgIHN1cHBvcnRzQ3JlYXRlVGFzayAmJlxuICAgICAgICAgICAgICAgICAgKGVycm9yZWRDb21wb25lbnQuZGVidWdUYXNrID0gYmxvY2tlZFZhbHVlLl9kZWJ1Z1Rhc2spO1xuICAgICAgICAgICAgICAgIGNodW5rLl9kZWJ1Z0luZm8ucHVzaChlcnJvcmVkQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cmlnZ2VyRXJyb3JPbkNodW5rKHJlc3BvbnNlLCBjaHVuaywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlTGF6eSh2YWx1ZSkge1xuICAgICAgZm9yIChcbiAgICAgICAgO1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgbnVsbCAhPT0gdmFsdWUgJiZcbiAgICAgICAgdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRTtcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBwYXlsb2FkID0gdmFsdWUuX3BheWxvYWQ7XG4gICAgICAgIGlmIChcImZ1bGZpbGxlZFwiID09PSBwYXlsb2FkLnN0YXR1cykgdmFsdWUgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2ZlclJlZmVyZW5jZWREZWJ1Z0luZm8ocGFyZW50Q2h1bmssIHJlZmVyZW5jZWRDaHVuaykge1xuICAgICAgaWYgKG51bGwgIT09IHBhcmVudENodW5rKSB7XG4gICAgICAgIHJlZmVyZW5jZWRDaHVuayA9IHJlZmVyZW5jZWRDaHVuay5fZGVidWdJbmZvO1xuICAgICAgICBwYXJlbnRDaHVuayA9IHBhcmVudENodW5rLl9kZWJ1Z0luZm87XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVmZXJlbmNlZENodW5rLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGRlYnVnSW5mb0VudHJ5ID0gcmVmZXJlbmNlZENodW5rW2ldO1xuICAgICAgICAgIG51bGwgPT0gZGVidWdJbmZvRW50cnkubmFtZSAmJiBwYXJlbnRDaHVuay5wdXNoKGRlYnVnSW5mb0VudHJ5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPdXRsaW5lZE1vZGVsKHJlc3BvbnNlLCByZWZlcmVuY2UsIHBhcmVudE9iamVjdCwga2V5LCBtYXApIHtcbiAgICAgIHZhciBwYXRoID0gcmVmZXJlbmNlLnNwbGl0KFwiOlwiKTtcbiAgICAgIHJlZmVyZW5jZSA9IHBhcnNlSW50KHBhdGhbMF0sIDE2KTtcbiAgICAgIHJlZmVyZW5jZSA9IGdldENodW5rKHJlc3BvbnNlLCByZWZlcmVuY2UpO1xuICAgICAgbnVsbCAhPT0gaW5pdGlhbGl6aW5nQ2h1bmsgJiZcbiAgICAgICAgaXNBcnJheUltcGwoaW5pdGlhbGl6aW5nQ2h1bmsuX2NoaWxkcmVuKSAmJlxuICAgICAgICBpbml0aWFsaXppbmdDaHVuay5fY2hpbGRyZW4ucHVzaChyZWZlcmVuY2UpO1xuICAgICAgc3dpdGNoIChyZWZlcmVuY2Uuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJyZXNvbHZlZF9tb2RlbFwiOlxuICAgICAgICAgIGluaXRpYWxpemVNb2RlbENodW5rKHJlZmVyZW5jZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZXNvbHZlZF9tb2R1bGVcIjpcbiAgICAgICAgICBpbml0aWFsaXplTW9kdWxlQ2h1bmsocmVmZXJlbmNlKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAocmVmZXJlbmNlLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgZm9yICh2YXIgdmFsdWUgPSByZWZlcmVuY2UudmFsdWUsIGkgPSAxOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gdmFsdWUgJiZcbiAgICAgICAgICAgICAgdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRTtcblxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuX3BheWxvYWQ7XG4gICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlc29sdmVkX21vZGVsXCI6XG4gICAgICAgICAgICAgICAgICBpbml0aWFsaXplTW9kZWxDaHVuayh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVzb2x2ZWRfbW9kdWxlXCI6XG4gICAgICAgICAgICAgICAgICBpbml0aWFsaXplTW9kdWxlQ2h1bmsodmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJibG9ja2VkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB3YWl0Rm9yUmVmZXJlbmNlKFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBtYXAsXG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2xpY2UoaSAtIDEpLFxuICAgICAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiaGFsdGVkXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXppbmdIYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgICAgPyAoKHBhcmVudE9iamVjdCA9IGluaXRpYWxpemluZ0hhbmRsZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50T2JqZWN0LmRlcHMrKylcbiAgICAgICAgICAgICAgICAgICAgICA6IChpbml0aWFsaXppbmdIYW5kbGVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBzOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcmVkOiAhMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemluZ0hhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICA/ICgoaW5pdGlhbGl6aW5nSGFuZGxlci5lcnJvcmVkID0gITApLFxuICAgICAgICAgICAgICAgICAgICAgICAgKGluaXRpYWxpemluZ0hhbmRsZXIudmFsdWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpbml0aWFsaXppbmdIYW5kbGVyLnJlYXNvbiA9IHZhbHVlLnJlYXNvbikpXG4gICAgICAgICAgICAgICAgICAgICAgOiAoaW5pdGlhbGl6aW5nSGFuZGxlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogdmFsdWUucmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBzOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcmVkOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbcGF0aFtpXV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHZhbHVlICYmXG4gICAgICAgICAgICB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xuXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwYXRoID0gdmFsdWUuX3BheWxvYWQ7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhdGguc3RhdHVzKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJyZXNvbHZlZF9tb2RlbFwiOlxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVNb2RlbENodW5rKHBhdGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwicmVzb2x2ZWRfbW9kdWxlXCI6XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZU1vZHVsZUNodW5rKHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChwYXRoLnN0YXR1cykge1xuICAgICAgICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXRoLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3BvbnNlID0gbWFwKHJlc3BvbnNlLCB2YWx1ZSwgcGFyZW50T2JqZWN0LCBrZXkpO1xuICAgICAgICAgIChwYXJlbnRPYmplY3RbMF0gIT09IFJFQUNUX0VMRU1FTlRfVFlQRSB8fFxuICAgICAgICAgICAgKFwiNFwiICE9PSBrZXkgJiYgXCI1XCIgIT09IGtleSkpICYmXG4gICAgICAgICAgICB0cmFuc2ZlclJlZmVyZW5jZWREZWJ1Z0luZm8oaW5pdGlhbGl6aW5nQ2h1bmssIHJlZmVyZW5jZSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICBjYXNlIFwiYmxvY2tlZFwiOlxuICAgICAgICAgIHJldHVybiB3YWl0Rm9yUmVmZXJlbmNlKFxuICAgICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgICAgcGFyZW50T2JqZWN0LFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBtYXAsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgITFcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiaGFsdGVkXCI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGluaXRpYWxpemluZ0hhbmRsZXJcbiAgICAgICAgICAgICAgPyAoKHBhcmVudE9iamVjdCA9IGluaXRpYWxpemluZ0hhbmRsZXIpLCBwYXJlbnRPYmplY3QuZGVwcysrKVxuICAgICAgICAgICAgICA6IChpbml0aWFsaXppbmdIYW5kbGVyID0ge1xuICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgY2h1bms6IG51bGwsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHJlYXNvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGRlcHM6IDEsXG4gICAgICAgICAgICAgICAgICBlcnJvcmVkOiAhMVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGluaXRpYWxpemluZ0hhbmRsZXJcbiAgICAgICAgICAgICAgPyAoKGluaXRpYWxpemluZ0hhbmRsZXIuZXJyb3JlZCA9ICEwKSxcbiAgICAgICAgICAgICAgICAoaW5pdGlhbGl6aW5nSGFuZGxlci52YWx1ZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgIChpbml0aWFsaXppbmdIYW5kbGVyLnJlYXNvbiA9IHJlZmVyZW5jZS5yZWFzb24pKVxuICAgICAgICAgICAgICA6IChpbml0aWFsaXppbmdIYW5kbGVyID0ge1xuICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgY2h1bms6IG51bGwsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVmZXJlbmNlLnJlYXNvbixcbiAgICAgICAgICAgICAgICAgIGRlcHM6IDAsXG4gICAgICAgICAgICAgICAgICBlcnJvcmVkOiAhMFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hcChyZXNwb25zZSwgbW9kZWwpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwKG1vZGVsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlU2V0KHJlc3BvbnNlLCBtb2RlbCkge1xuICAgICAgcmV0dXJuIG5ldyBTZXQobW9kZWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVCbG9iKHJlc3BvbnNlLCBtb2RlbCkge1xuICAgICAgcmV0dXJuIG5ldyBCbG9iKG1vZGVsLnNsaWNlKDEpLCB7IHR5cGU6IG1vZGVsWzBdIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGb3JtRGF0YShyZXNwb25zZSwgbW9kZWwpIHtcbiAgICAgIHJlc3BvbnNlID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVsLmxlbmd0aDsgaSsrKVxuICAgICAgICByZXNwb25zZS5hcHBlbmQobW9kZWxbaV1bMF0sIG1vZGVsW2ldWzFdKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwbHlDb25zdHJ1Y3RvcihyZXNwb25zZSwgbW9kZWwsIHBhcmVudE9iamVjdCkge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHBhcmVudE9iamVjdCwgbW9kZWwucHJvdG90eXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmaW5lTGF6eUdldHRlcihyZXNwb25zZSwgY2h1bmssIHBhcmVudE9iamVjdCwga2V5KSB7XG4gICAgICBcIl9fcHJvdG9fX1wiICE9PSBrZXkgJiZcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcmVudE9iamVjdCwga2V5LCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBcInJlc29sdmVkX21vZGVsXCIgPT09IGNodW5rLnN0YXR1cyAmJiBpbml0aWFsaXplTW9kZWxDaHVuayhjaHVuayk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnN0YXR1cykge1xuICAgICAgICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rLnZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICAgICAgICB0aHJvdyBjaHVuay5yZWFzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJUaGlzIG9iamVjdCBoYXMgYmVlbiBvbWl0dGVkIGJ5IFJlYWN0IGluIHRoZSBjb25zb2xlIGxvZyB0byBhdm9pZCBzZW5kaW5nIHRvbyBtdWNoIGRhdGEgZnJvbSB0aGUgc2VydmVyLiBUcnkgbG9nZ2luZyBzbWFsbGVyIG9yIG1vcmUgc3BlY2lmaWMgb2JqZWN0cy5cIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITFcbiAgICAgICAgfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0cmFjdEl0ZXJhdG9yKHJlc3BvbnNlLCBtb2RlbCkge1xuICAgICAgcmV0dXJuIG1vZGVsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTW9kZWwocmVzcG9uc2UsIG1vZGVsKSB7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEluZmVycmVkRnVuY3Rpb25BcHByb3hpbWF0ZShjb2RlKSB7XG4gICAgICBjb2RlID0gY29kZS5zdGFydHNXaXRoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KFwiKVxuICAgICAgICA/IGNvZGUuc2xpY2UoMjIpXG4gICAgICAgIDogY29kZS5zdGFydHNXaXRoKFwiKFwiKVxuICAgICAgICAgID8gY29kZS5zbGljZSgxKVxuICAgICAgICAgIDogY29kZTtcbiAgICAgIGlmIChjb2RlLnN0YXJ0c1dpdGgoXCJhc3luYyBmdW5jdGlvblwiKSkge1xuICAgICAgICB2YXIgaWR4ID0gY29kZS5pbmRleE9mKFwiKFwiLCAxNCk7XG4gICAgICAgIGlmICgtMSAhPT0gaWR4KVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY29kZSA9IGNvZGUuc2xpY2UoMTQsIGlkeCkudHJpbSgpKSxcbiAgICAgICAgICAgICgwLCBldmFsKShcIih7XCIgKyBKU09OLnN0cmluZ2lmeShjb2RlKSArIFwiOmFzeW5jIGZ1bmN0aW9uKCl7fX0pXCIpW1xuICAgICAgICAgICAgICBjb2RlXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZS5zdGFydHNXaXRoKFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgaWYgKCgoaWR4ID0gY29kZS5pbmRleE9mKFwiKFwiLCA4KSksIC0xICE9PSBpZHgpKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY29kZSA9IGNvZGUuc2xpY2UoOCwgaWR4KS50cmltKCkpLFxuICAgICAgICAgICAgKDAsIGV2YWwpKFwiKHtcIiArIEpTT04uc3RyaW5naWZ5KGNvZGUpICsgXCI6ZnVuY3Rpb24oKXt9fSlcIilbY29kZV1cbiAgICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgY29kZS5zdGFydHNXaXRoKFwiY2xhc3NcIikgJiZcbiAgICAgICAgKChpZHggPSBjb2RlLmluZGV4T2YoXCJ7XCIsIDUpKSwgLTEgIT09IGlkeClcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoY29kZSA9IGNvZGUuc2xpY2UoNSwgaWR4KS50cmltKCkpLFxuICAgICAgICAgICgwLCBldmFsKShcIih7XCIgKyBKU09OLnN0cmluZ2lmeShjb2RlKSArIFwiOmNsYXNze319KVwiKVtjb2RlXVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZU1vZGVsU3RyaW5nKHJlc3BvbnNlLCBwYXJlbnRPYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChcIiRcIiA9PT0gdmFsdWVbMF0pIHtcbiAgICAgICAgaWYgKFwiJFwiID09PSB2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbnVsbCAhPT0gaW5pdGlhbGl6aW5nSGFuZGxlciAmJlxuICAgICAgICAgICAgICBcIjBcIiA9PT0ga2V5ICYmXG4gICAgICAgICAgICAgIChpbml0aWFsaXppbmdIYW5kbGVyID0ge1xuICAgICAgICAgICAgICAgIHBhcmVudDogaW5pdGlhbGl6aW5nSGFuZGxlcixcbiAgICAgICAgICAgICAgICBjaHVuazogbnVsbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICByZWFzb246IG51bGwsXG4gICAgICAgICAgICAgICAgZGVwczogMCxcbiAgICAgICAgICAgICAgICBlcnJvcmVkOiAhMVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICk7XG4gICAgICAgIHN3aXRjaCAodmFsdWVbMV0pIHtcbiAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocGFyZW50T2JqZWN0ID0gcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDE2KSksXG4gICAgICAgICAgICAgIChyZXNwb25zZSA9IGdldENodW5rKHJlc3BvbnNlLCBwYXJlbnRPYmplY3QpKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5pdGlhbGl6aW5nQ2h1bmsgJiZcbiAgICAgICAgICAgICAgICBpc0FycmF5SW1wbChpbml0aWFsaXppbmdDaHVuay5fY2hpbGRyZW4pICYmXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6aW5nQ2h1bmsuX2NoaWxkcmVuLnB1c2gocmVzcG9uc2UpLFxuICAgICAgICAgICAgICBjcmVhdGVMYXp5Q2h1bmtXcmFwcGVyKHJlc3BvbnNlLCAwKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFwiQFwiOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHBhcmVudE9iamVjdCA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAxNikpLFxuICAgICAgICAgICAgICAocmVzcG9uc2UgPSBnZXRDaHVuayhyZXNwb25zZSwgcGFyZW50T2JqZWN0KSksXG4gICAgICAgICAgICAgIG51bGwgIT09IGluaXRpYWxpemluZ0NodW5rICYmXG4gICAgICAgICAgICAgICAgaXNBcnJheUltcGwoaW5pdGlhbGl6aW5nQ2h1bmsuX2NoaWxkcmVuKSAmJlxuICAgICAgICAgICAgICAgIGluaXRpYWxpemluZ0NodW5rLl9jaGlsZHJlbi5wdXNoKHJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgIHJldHVybiBTeW1ib2wuZm9yKHZhbHVlLnNsaWNlKDIpKTtcbiAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgdmFyIHJlZiA9IHZhbHVlLnNsaWNlKDIpO1xuICAgICAgICAgICAgcmV0dXJuIGdldE91dGxpbmVkTW9kZWwoXG4gICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAgIHBhcmVudE9iamVjdCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBsb2FkU2VydmVyUmVmZXJlbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgXCJUXCI6XG4gICAgICAgICAgICBwYXJlbnRPYmplY3QgPSBcIiRcIiArIHZhbHVlLnNsaWNlKDIpO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZS5fdGVtcFJlZnM7XG4gICAgICAgICAgICBpZiAobnVsbCA9PSByZXNwb25zZSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJNaXNzaW5nIGEgdGVtcG9yYXJ5IHJlZmVyZW5jZSBzZXQgYnV0IHRoZSBSU0MgcmVzcG9uc2UgcmV0dXJuZWQgYSB0ZW1wb3JhcnkgcmVmZXJlbmNlLiBQYXNzIGEgdGVtcG9yYXJ5UmVmZXJlbmNlIG9wdGlvbiB3aXRoIHRoZSBzZXQgdGhhdCB3YXMgdXNlZCB3aXRoIHRoZSByZXBseS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmdldChwYXJlbnRPYmplY3QpO1xuICAgICAgICAgIGNhc2UgXCJRXCI6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocmVmID0gdmFsdWUuc2xpY2UoMikpLFxuICAgICAgICAgICAgICBnZXRPdXRsaW5lZE1vZGVsKHJlc3BvbnNlLCByZWYsIHBhcmVudE9iamVjdCwga2V5LCBjcmVhdGVNYXApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocmVmID0gdmFsdWUuc2xpY2UoMikpLFxuICAgICAgICAgICAgICBnZXRPdXRsaW5lZE1vZGVsKHJlc3BvbnNlLCByZWYsIHBhcmVudE9iamVjdCwga2V5LCBjcmVhdGVTZXQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgXCJCXCI6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocmVmID0gdmFsdWUuc2xpY2UoMikpLFxuICAgICAgICAgICAgICBnZXRPdXRsaW5lZE1vZGVsKHJlc3BvbnNlLCByZWYsIHBhcmVudE9iamVjdCwga2V5LCBjcmVhdGVCbG9iKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFwiS1wiOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHJlZiA9IHZhbHVlLnNsaWNlKDIpKSxcbiAgICAgICAgICAgICAgZ2V0T3V0bGluZWRNb2RlbChyZXNwb25zZSwgcmVmLCBwYXJlbnRPYmplY3QsIGtleSwgY3JlYXRlRm9ybURhdGEpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgXCJaXCI6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocmVmID0gdmFsdWUuc2xpY2UoMikpLFxuICAgICAgICAgICAgICBnZXRPdXRsaW5lZE1vZGVsKFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgICBwYXJlbnRPYmplY3QsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHJlc29sdmVFcnJvckRldlxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgXCJpXCI6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocmVmID0gdmFsdWUuc2xpY2UoMikpLFxuICAgICAgICAgICAgICBnZXRPdXRsaW5lZE1vZGVsKFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgICBwYXJlbnRPYmplY3QsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGV4dHJhY3RJdGVyYXRvclxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgXCJJXCI6XG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIiQtMFwiID09PSB2YWx1ZSA/IC0wIDogLUluZmluaXR5O1xuICAgICAgICAgIGNhc2UgXCJOXCI6XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLnBhcnNlKHZhbHVlLnNsaWNlKDIpKSk7XG4gICAgICAgICAgY2FzZSBcIm5cIjpcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUuc2xpY2UoMikpO1xuICAgICAgICAgIGNhc2UgXCJQXCI6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocmVmID0gdmFsdWUuc2xpY2UoMikpLFxuICAgICAgICAgICAgICBnZXRPdXRsaW5lZE1vZGVsKFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgICBwYXJlbnRPYmplY3QsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGFwcGx5Q29uc3RydWN0b3JcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICAgICAgcmVzcG9uc2UgPSB2YWx1ZS5zbGljZSgyKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghbWlnaHRIYXZlU3RhdGljQ29uc3RydWN0b3IudGVzdChyZXNwb25zZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBldmFsKShyZXNwb25zZSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICgocmVmID0gZ2V0SW5mZXJyZWRGdW5jdGlvbkFwcHJveGltYXRlKHJlc3BvbnNlKSksXG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3RhcnRzV2l0aChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShcIikpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSByZXNwb25zZS5sYXN0SW5kZXhPZignLFwibmFtZVwiLHt2YWx1ZTpcIicpO1xuICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gaWR4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNsaWNlKGlkeCArIDE2IC0gMSwgcmVzcG9uc2UubGVuZ3RoIC0gMilcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVmLCBcIm5hbWVcIiwgeyB2YWx1ZTogbmFtZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgcmVmID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICAgIGNhc2UgXCJZXCI6XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIDIgPCB2YWx1ZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgKHJlZiA9IHJlc3BvbnNlLl9kZWJ1Z0NoYW5uZWwgJiYgcmVzcG9uc2UuX2RlYnVnQ2hhbm5lbC5jYWxsYmFjaylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoXCJAXCIgPT09IHZhbHVlWzJdKVxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAocGFyZW50T2JqZWN0ID0gdmFsdWUuc2xpY2UoMykpLFxuICAgICAgICAgICAgICAgICAgKGtleSA9IHBhcnNlSW50KHBhcmVudE9iamVjdCwgMTYpKSxcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLl9jaHVua3MuaGFzKGtleSkgfHwgcmVmKFwiUDpcIiArIHBhcmVudE9iamVjdCksXG4gICAgICAgICAgICAgICAgICBnZXRDaHVuayhyZXNwb25zZSwga2V5KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMik7XG4gICAgICAgICAgICAgIGlkeCA9IHBhcnNlSW50KHZhbHVlLCAxNik7XG4gICAgICAgICAgICAgIHJlc3BvbnNlLl9jaHVua3MuaGFzKGlkeCkgfHwgcmVmKFwiUTpcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgcmVmID0gZ2V0Q2h1bmsocmVzcG9uc2UsIGlkeCk7XG4gICAgICAgICAgICAgIHJldHVybiBcImZ1bGZpbGxlZFwiID09PSByZWYuc3RhdHVzXG4gICAgICAgICAgICAgICAgPyByZWYudmFsdWVcbiAgICAgICAgICAgICAgICA6IGRlZmluZUxhenlHZXR0ZXIocmVzcG9uc2UsIHJlZiwgcGFyZW50T2JqZWN0LCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXCJfX3Byb3RvX19cIiAhPT0ga2V5ICYmXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJlbnRPYmplY3QsIGtleSwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVGhpcyBvYmplY3QgaGFzIGJlZW4gb21pdHRlZCBieSBSZWFjdCBpbiB0aGUgY29uc29sZSBsb2cgdG8gYXZvaWQgc2VuZGluZyB0b28gbXVjaCBkYXRhIGZyb20gdGhlIHNlcnZlci4gVHJ5IGxvZ2dpbmcgc21hbGxlciBvciBtb3JlIHNwZWNpZmljIG9iamVjdHMuXCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICExXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChyZWYgPSB2YWx1ZS5zbGljZSgxKSksXG4gICAgICAgICAgICAgIGdldE91dGxpbmVkTW9kZWwocmVzcG9uc2UsIHJlZiwgcGFyZW50T2JqZWN0LCBrZXksIGNyZWF0ZU1vZGVsKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtaXNzaW5nQ2FsbCgpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAnVHJ5aW5nIHRvIGNhbGwgYSBmdW5jdGlvbiBmcm9tIFwidXNlIHNlcnZlclwiIGJ1dCB0aGUgY2FsbFNlcnZlciBvcHRpb24gd2FzIG5vdCBpbXBsZW1lbnRlZCBpbiB5b3VyIHJvdXRlciBydW50aW1lLidcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtJT1N0YXJ0ZWQoKSB7XG4gICAgICB0aGlzLl9kZWJ1Z0lPU3RhcnRlZCA9ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZXNwb25zZUluc3RhbmNlKFxuICAgICAgYnVuZGxlckNvbmZpZyxcbiAgICAgIHNlcnZlclJlZmVyZW5jZUNvbmZpZyxcbiAgICAgIG1vZHVsZUxvYWRpbmcsXG4gICAgICBjYWxsU2VydmVyLFxuICAgICAgZW5jb2RlRm9ybUFjdGlvbixcbiAgICAgIG5vbmNlLFxuICAgICAgdGVtcG9yYXJ5UmVmZXJlbmNlcyxcbiAgICAgIGZpbmRTb3VyY2VNYXBVUkwsXG4gICAgICByZXBsYXlDb25zb2xlLFxuICAgICAgZW52aXJvbm1lbnROYW1lLFxuICAgICAgZGVidWdTdGFydFRpbWUsXG4gICAgICBkZWJ1Z0VuZFRpbWUsXG4gICAgICBkZWJ1Z0NoYW5uZWxcbiAgICApIHtcbiAgICAgIHZhciBjaHVua3MgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLl9idW5kbGVyQ29uZmlnID0gYnVuZGxlckNvbmZpZztcbiAgICAgIHRoaXMuX3NlcnZlclJlZmVyZW5jZUNvbmZpZyA9IHNlcnZlclJlZmVyZW5jZUNvbmZpZztcbiAgICAgIHRoaXMuX21vZHVsZUxvYWRpbmcgPSBtb2R1bGVMb2FkaW5nO1xuICAgICAgdGhpcy5fY2FsbFNlcnZlciA9IHZvaWQgMCAhPT0gY2FsbFNlcnZlciA/IGNhbGxTZXJ2ZXIgOiBtaXNzaW5nQ2FsbDtcbiAgICAgIHRoaXMuX2VuY29kZUZvcm1BY3Rpb24gPSBlbmNvZGVGb3JtQWN0aW9uO1xuICAgICAgdGhpcy5fbm9uY2UgPSBub25jZTtcbiAgICAgIHRoaXMuX2NodW5rcyA9IGNodW5rcztcbiAgICAgIHRoaXMuX3N0cmluZ0RlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgIHRoaXMuX2Zyb21KU09OID0gbnVsbDtcbiAgICAgIHRoaXMuX2Nsb3NlZCA9ICExO1xuICAgICAgdGhpcy5fY2xvc2VkUmVhc29uID0gbnVsbDtcbiAgICAgIHRoaXMuX3RlbXBSZWZzID0gdGVtcG9yYXJ5UmVmZXJlbmNlcztcbiAgICAgIHRoaXMuX3RpbWVPcmlnaW4gPSAwO1xuICAgICAgdGhpcy5fcGVuZGluZ0luaXRpYWxSZW5kZXIgPSBudWxsO1xuICAgICAgdGhpcy5fcGVuZGluZ0NodW5rcyA9IDA7XG4gICAgICB0aGlzLl93ZWFrUmVzcG9uc2UgPSB7IHdlYWs6IG5ldyBXZWFrUmVmKHRoaXMpLCByZXNwb25zZTogdGhpcyB9O1xuICAgICAgdGhpcy5fZGVidWdSb290T3duZXIgPSBidW5kbGVyQ29uZmlnID1cbiAgICAgICAgdm9pZCAwID09PSBSZWFjdFNoYXJlZEludGVyYWxzU2VydmVyIHx8XG4gICAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJhbHNTZXJ2ZXIuQVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogUmVhY3RTaGFyZWRJbnRlcmFsc1NlcnZlci5BLmdldE93bmVyKCk7XG4gICAgICB0aGlzLl9kZWJ1Z1Jvb3RTdGFjayA9XG4gICAgICAgIG51bGwgIT09IGJ1bmRsZXJDb25maWcgPyBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKSA6IG51bGw7XG4gICAgICBlbnZpcm9ubWVudE5hbWUgPSB2b2lkIDAgPT09IGVudmlyb25tZW50TmFtZSA/IFwiU2VydmVyXCIgOiBlbnZpcm9ubWVudE5hbWU7XG4gICAgICBzdXBwb3J0c0NyZWF0ZVRhc2sgJiZcbiAgICAgICAgKHRoaXMuX2RlYnVnUm9vdFRhc2sgPSBjb25zb2xlLmNyZWF0ZVRhc2soXG4gICAgICAgICAgJ1widXNlICcgKyBlbnZpcm9ubWVudE5hbWUudG9Mb3dlckNhc2UoKSArICdcIidcbiAgICAgICAgKSk7XG4gICAgICB0aGlzLl9kZWJ1Z1N0YXJ0VGltZSA9XG4gICAgICAgIG51bGwgPT0gZGVidWdTdGFydFRpbWUgPyBwZXJmb3JtYW5jZS5ub3coKSA6IGRlYnVnU3RhcnRUaW1lO1xuICAgICAgdGhpcy5fZGVidWdJT1N0YXJ0ZWQgPSAhMTtcbiAgICAgIHNldFRpbWVvdXQobWFya0lPU3RhcnRlZC5iaW5kKHRoaXMpLCAwKTtcbiAgICAgIHRoaXMuX2RlYnVnRW5kVGltZSA9IG51bGwgPT0gZGVidWdFbmRUaW1lID8gbnVsbCA6IGRlYnVnRW5kVGltZTtcbiAgICAgIHRoaXMuX2RlYnVnRmluZFNvdXJjZU1hcFVSTCA9IGZpbmRTb3VyY2VNYXBVUkw7XG4gICAgICB0aGlzLl9kZWJ1Z0NoYW5uZWwgPSBkZWJ1Z0NoYW5uZWw7XG4gICAgICB0aGlzLl9ibG9ja2VkQ29uc29sZSA9IG51bGw7XG4gICAgICB0aGlzLl9yZXBsYXlDb25zb2xlID0gcmVwbGF5Q29uc29sZTtcbiAgICAgIHRoaXMuX3Jvb3RFbnZpcm9ubWVudE5hbWUgPSBlbnZpcm9ubWVudE5hbWU7XG4gICAgICBkZWJ1Z0NoYW5uZWwgJiZcbiAgICAgICAgKG51bGwgPT09IGRlYnVnQ2hhbm5lbFJlZ2lzdHJ5XG4gICAgICAgICAgPyAoY2xvc2VEZWJ1Z0NoYW5uZWwoZGVidWdDaGFubmVsKSwgKHRoaXMuX2RlYnVnQ2hhbm5lbCA9IHZvaWQgMCkpXG4gICAgICAgICAgOiBkZWJ1Z0NoYW5uZWxSZWdpc3RyeS5yZWdpc3Rlcih0aGlzLCBkZWJ1Z0NoYW5uZWwsIHRoaXMpKTtcbiAgICAgIHJlcGxheUNvbnNvbGUgJiYgbWFya0FsbFRyYWNrc0luT3JkZXIoKTtcbiAgICAgIHRoaXMuX2Zyb21KU09OID0gY3JlYXRlRnJvbUpTT05DYWxsYmFjayh0aGlzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlU3RyZWFtU3RhdGUod2Vha1Jlc3BvbnNlLCBzdHJlYW1EZWJ1Z1ZhbHVlKSB7XG4gICAgICB2YXIgc3RyZWFtU3RhdGUgPSB7XG4gICAgICAgIF9yb3dTdGF0ZTogMCxcbiAgICAgICAgX3Jvd0lEOiAwLFxuICAgICAgICBfcm93VGFnOiAwLFxuICAgICAgICBfcm93TGVuZ3RoOiAwLFxuICAgICAgICBfYnVmZmVyOiBbXVxuICAgICAgfTtcbiAgICAgIHdlYWtSZXNwb25zZSA9IHVud3JhcFdlYWtSZXNwb25zZSh3ZWFrUmVzcG9uc2UpO1xuICAgICAgdmFyIGRlYnVnVmFsdWVQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHN0cmVhbURlYnVnVmFsdWUpO1xuICAgICAgZGVidWdWYWx1ZVByb21pc2Uuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgIGRlYnVnVmFsdWVQcm9taXNlLnZhbHVlID0gc3RyZWFtRGVidWdWYWx1ZTtcbiAgICAgIHN0cmVhbVN0YXRlLl9kZWJ1Z0luZm8gPSB7XG4gICAgICAgIG5hbWU6IFwicnNjIHN0cmVhbVwiLFxuICAgICAgICBzdGFydDogd2Vha1Jlc3BvbnNlLl9kZWJ1Z1N0YXJ0VGltZSxcbiAgICAgICAgZW5kOiB3ZWFrUmVzcG9uc2UuX2RlYnVnU3RhcnRUaW1lLFxuICAgICAgICBieXRlU2l6ZTogMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnVmFsdWVQcm9taXNlLFxuICAgICAgICBvd25lcjogd2Vha1Jlc3BvbnNlLl9kZWJ1Z1Jvb3RPd25lcixcbiAgICAgICAgZGVidWdTdGFjazogd2Vha1Jlc3BvbnNlLl9kZWJ1Z1Jvb3RTdGFjayxcbiAgICAgICAgZGVidWdUYXNrOiB3ZWFrUmVzcG9uc2UuX2RlYnVnUm9vdFRhc2tcbiAgICAgIH07XG4gICAgICBzdHJlYW1TdGF0ZS5fZGVidWdUYXJnZXRDaHVua1NpemUgPSBNSU5fQ0hVTktfU0laRTtcbiAgICAgIHJldHVybiBzdHJlYW1TdGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5jcmVtZW50Q2h1bmtEZWJ1Z0luZm8oc3RyZWFtU3RhdGUsIGNodW5rTGVuZ3RoKSB7XG4gICAgICB2YXIgZGVidWdJbmZvID0gc3RyZWFtU3RhdGUuX2RlYnVnSW5mbyxcbiAgICAgICAgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICBwcmV2aW91c0VuZFRpbWUgPSBkZWJ1Z0luZm8uZW5kO1xuICAgICAgY2h1bmtMZW5ndGggPSBkZWJ1Z0luZm8uYnl0ZVNpemUgKyBjaHVua0xlbmd0aDtcbiAgICAgIGNodW5rTGVuZ3RoID4gc3RyZWFtU3RhdGUuX2RlYnVnVGFyZ2V0Q2h1bmtTaXplIHx8XG4gICAgICBlbmRUaW1lID4gcHJldmlvdXNFbmRUaW1lICsgMTBcbiAgICAgICAgPyAoKHN0cmVhbVN0YXRlLl9kZWJ1Z0luZm8gPSB7XG4gICAgICAgICAgICBuYW1lOiBkZWJ1Z0luZm8ubmFtZSxcbiAgICAgICAgICAgIHN0YXJ0OiBkZWJ1Z0luZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZFRpbWUsXG4gICAgICAgICAgICBieXRlU2l6ZTogY2h1bmtMZW5ndGgsXG4gICAgICAgICAgICB2YWx1ZTogZGVidWdJbmZvLnZhbHVlLFxuICAgICAgICAgICAgb3duZXI6IGRlYnVnSW5mby5vd25lcixcbiAgICAgICAgICAgIGRlYnVnU3RhY2s6IGRlYnVnSW5mby5kZWJ1Z1N0YWNrLFxuICAgICAgICAgICAgZGVidWdUYXNrOiBkZWJ1Z0luZm8uZGVidWdUYXNrXG4gICAgICAgICAgfSksXG4gICAgICAgICAgKHN0cmVhbVN0YXRlLl9kZWJ1Z1RhcmdldENodW5rU2l6ZSA9IGNodW5rTGVuZ3RoICsgTUlOX0NIVU5LX1NJWkUpKVxuICAgICAgICA6ICgoZGVidWdJbmZvLmVuZCA9IGVuZFRpbWUpLCAoZGVidWdJbmZvLmJ5dGVTaXplID0gY2h1bmtMZW5ndGgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkQXN5bmNJbmZvKGNodW5rLCBhc3luY0luZm8pIHtcbiAgICAgIHZhciB2YWx1ZSA9IHJlc29sdmVMYXp5KGNodW5rLnZhbHVlKTtcbiAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgbnVsbCA9PT0gdmFsdWUgfHxcbiAgICAgICghaXNBcnJheUltcGwodmFsdWUpICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlW0FTWU5DX0lURVJBVE9SXSAmJlxuICAgICAgICB2YWx1ZS4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFICYmXG4gICAgICAgIHZhbHVlLiQkdHlwZW9mICE9PSBSRUFDVF9MQVpZX1RZUEUpXG4gICAgICAgID8gY2h1bmsuX2RlYnVnSW5mby5wdXNoKGFzeW5jSW5mbylcbiAgICAgICAgOiBpc0FycmF5SW1wbCh2YWx1ZS5fZGVidWdJbmZvKVxuICAgICAgICAgID8gdmFsdWUuX2RlYnVnSW5mby5wdXNoKGFzeW5jSW5mbylcbiAgICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgXCJfZGVidWdJbmZvXCIsIHtcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgICAgdmFsdWU6IFthc3luY0luZm9dXG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUNodW5rRGVidWdJbmZvKHJlc3BvbnNlLCBzdHJlYW1TdGF0ZSwgY2h1bmspIHtcbiAgICAgIHJlc3BvbnNlLl9kZWJ1Z0lPU3RhcnRlZCAmJlxuICAgICAgICAoKHJlc3BvbnNlID0geyBhd2FpdGVkOiBzdHJlYW1TdGF0ZS5fZGVidWdJbmZvIH0pLFxuICAgICAgICBcInBlbmRpbmdcIiA9PT0gY2h1bmsuc3RhdHVzIHx8IFwiYmxvY2tlZFwiID09PSBjaHVuay5zdGF0dXNcbiAgICAgICAgICA/ICgocmVzcG9uc2UgPSBhZGRBc3luY0luZm8uYmluZChudWxsLCBjaHVuaywgcmVzcG9uc2UpKSxcbiAgICAgICAgICAgIGNodW5rLnRoZW4ocmVzcG9uc2UsIHJlc3BvbnNlKSlcbiAgICAgICAgICA6IGFkZEFzeW5jSW5mbyhjaHVuaywgcmVzcG9uc2UpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUJ1ZmZlcihyZXNwb25zZSwgaWQsIGJ1ZmZlciwgc3RyZWFtU3RhdGUpIHtcbiAgICAgIHZhciBjaHVua3MgPSByZXNwb25zZS5fY2h1bmtzLFxuICAgICAgICBjaHVuayA9IGNodW5rcy5nZXQoaWQpO1xuICAgICAgY2h1bmsgJiYgXCJwZW5kaW5nXCIgIT09IGNodW5rLnN0YXR1c1xuICAgICAgICA/IGNodW5rLnJlYXNvbi5lbnF1ZXVlVmFsdWUoYnVmZmVyKVxuICAgICAgICA6IChjaHVuayAmJiByZWxlYXNlUGVuZGluZ0NodW5rKHJlc3BvbnNlLCBjaHVuayksXG4gICAgICAgICAgKGJ1ZmZlciA9IG5ldyBSZWFjdFByb21pc2UoXCJmdWxmaWxsZWRcIiwgYnVmZmVyLCBudWxsKSksXG4gICAgICAgICAgcmVzb2x2ZUNodW5rRGVidWdJbmZvKHJlc3BvbnNlLCBzdHJlYW1TdGF0ZSwgYnVmZmVyKSxcbiAgICAgICAgICBjaHVua3Muc2V0KGlkLCBidWZmZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZU1vZHVsZShyZXNwb25zZSwgaWQsIG1vZGVsLCBzdHJlYW1TdGF0ZSkge1xuICAgICAgdmFyIGNodW5rcyA9IHJlc3BvbnNlLl9jaHVua3MsXG4gICAgICAgIGNodW5rID0gY2h1bmtzLmdldChpZCk7XG4gICAgICBtb2RlbCA9IEpTT04ucGFyc2UobW9kZWwsIHJlc3BvbnNlLl9mcm9tSlNPTik7XG4gICAgICB2YXIgY2xpZW50UmVmZXJlbmNlID0gcmVzb2x2ZUNsaWVudFJlZmVyZW5jZShcbiAgICAgICAgcmVzcG9uc2UuX2J1bmRsZXJDb25maWcsXG4gICAgICAgIG1vZGVsXG4gICAgICApO1xuICAgICAgaWYgKChtb2RlbCA9IHByZWxvYWRNb2R1bGUoY2xpZW50UmVmZXJlbmNlKSkpIHtcbiAgICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgICAgcmVsZWFzZVBlbmRpbmdDaHVuayhyZXNwb25zZSwgY2h1bmspO1xuICAgICAgICAgIHZhciBibG9ja2VkQ2h1bmsgPSBjaHVuaztcbiAgICAgICAgICBibG9ja2VkQ2h1bmsuc3RhdHVzID0gXCJibG9ja2VkXCI7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIChibG9ja2VkQ2h1bmsgPSBuZXcgUmVhY3RQcm9taXNlKFwiYmxvY2tlZFwiLCBudWxsLCBudWxsKSksXG4gICAgICAgICAgICBjaHVua3Muc2V0KGlkLCBibG9ja2VkQ2h1bmspO1xuICAgICAgICByZXNvbHZlQ2h1bmtEZWJ1Z0luZm8ocmVzcG9uc2UsIHN0cmVhbVN0YXRlLCBibG9ja2VkQ2h1bmspO1xuICAgICAgICBtb2RlbC50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlTW9kdWxlQ2h1bmsocmVzcG9uc2UsIGJsb2NrZWRDaHVuaywgY2xpZW50UmVmZXJlbmNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXJFcnJvck9uQ2h1bmsocmVzcG9uc2UsIGJsb2NrZWRDaHVuaywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBjaHVua1xuICAgICAgICAgID8gKHJlc29sdmVDaHVua0RlYnVnSW5mbyhyZXNwb25zZSwgc3RyZWFtU3RhdGUsIGNodW5rKSxcbiAgICAgICAgICAgIHJlc29sdmVNb2R1bGVDaHVuayhyZXNwb25zZSwgY2h1bmssIGNsaWVudFJlZmVyZW5jZSkpXG4gICAgICAgICAgOiAoKGNodW5rID0gbmV3IFJlYWN0UHJvbWlzZShcbiAgICAgICAgICAgICAgXCJyZXNvbHZlZF9tb2R1bGVcIixcbiAgICAgICAgICAgICAgY2xpZW50UmVmZXJlbmNlLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIHJlc29sdmVDaHVua0RlYnVnSW5mbyhyZXNwb25zZSwgc3RyZWFtU3RhdGUsIGNodW5rKSxcbiAgICAgICAgICAgIGNodW5rcy5zZXQoaWQsIGNodW5rKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVTdHJlYW0ocmVzcG9uc2UsIGlkLCBzdHJlYW0sIGNvbnRyb2xsZXIsIHN0cmVhbVN0YXRlKSB7XG4gICAgICB2YXIgY2h1bmtzID0gcmVzcG9uc2UuX2NodW5rcyxcbiAgICAgICAgY2h1bmsgPSBjaHVua3MuZ2V0KGlkKTtcbiAgICAgIGlmIChjaHVuaykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKHJlc29sdmVDaHVua0RlYnVnSW5mbyhyZXNwb25zZSwgc3RyZWFtU3RhdGUsIGNodW5rKSxcbiAgICAgICAgICBcInBlbmRpbmdcIiA9PT0gY2h1bmsuc3RhdHVzKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZCA9IGNodW5rLnZhbHVlO1xuICAgICAgICAgIGlmIChudWxsICE9IGNodW5rLl9kZWJ1Z0NodW5rKSB7XG4gICAgICAgICAgICBzdHJlYW1TdGF0ZSA9IGluaXRpYWxpemluZ0hhbmRsZXI7XG4gICAgICAgICAgICBjaHVua3MgPSBpbml0aWFsaXppbmdDaHVuaztcbiAgICAgICAgICAgIGluaXRpYWxpemluZ0hhbmRsZXIgPSBudWxsO1xuICAgICAgICAgICAgY2h1bmsuc3RhdHVzID0gXCJibG9ja2VkXCI7XG4gICAgICAgICAgICBjaHVuay52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBjaHVuay5yZWFzb24gPSBudWxsO1xuICAgICAgICAgICAgaW5pdGlhbGl6aW5nQ2h1bmsgPSBjaHVuaztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoaW5pdGlhbGl6ZURlYnVnQ2h1bmsocmVzcG9uc2UsIGNodW5rKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBpbml0aWFsaXppbmdIYW5kbGVyICYmXG4gICAgICAgICAgICAgICAgICAhaW5pdGlhbGl6aW5nSGFuZGxlci5lcnJvcmVkICYmXG4gICAgICAgICAgICAgICAgICAwIDwgaW5pdGlhbGl6aW5nSGFuZGxlci5kZXBzKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXppbmdIYW5kbGVyLnZhbHVlID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemluZ0hhbmRsZXIucmVhc29uID0gY29udHJvbGxlcjtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXppbmdIYW5kbGVyLmNodW5rID0gY2h1bms7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAoaW5pdGlhbGl6aW5nSGFuZGxlciA9IHN0cmVhbVN0YXRlKSwgKGluaXRpYWxpemluZ0NodW5rID0gY2h1bmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2h1bmsuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICBjaHVuay52YWx1ZSA9IHN0cmVhbTtcbiAgICAgICAgICBjaHVuay5yZWFzb24gPSBjb250cm9sbGVyO1xuICAgICAgICAgIG51bGwgIT09IGlkXG4gICAgICAgICAgICA/IHdha2VDaHVuayhyZXNwb25zZSwgaWQsIGNodW5rLnZhbHVlLCBjaHVuaylcbiAgICAgICAgICAgIDogKGZpbHRlckRlYnVnSW5mbyhyZXNwb25zZSwgY2h1bmspLFxuICAgICAgICAgICAgICBtb3ZlRGVidWdJbmZvRnJvbUNodW5rVG9Jbm5lclZhbHVlKGNodW5rLCBzdHJlYW0pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIDAgPT09IHJlc3BvbnNlLl9wZW5kaW5nQ2h1bmtzKysgJiZcbiAgICAgICAgICAocmVzcG9uc2UuX3dlYWtSZXNwb25zZS5yZXNwb25zZSA9IHJlc3BvbnNlKSxcbiAgICAgICAgICAoc3RyZWFtID0gbmV3IFJlYWN0UHJvbWlzZShcImZ1bGZpbGxlZFwiLCBzdHJlYW0sIGNvbnRyb2xsZXIpKSxcbiAgICAgICAgICByZXNvbHZlQ2h1bmtEZWJ1Z0luZm8ocmVzcG9uc2UsIHN0cmVhbVN0YXRlLCBzdHJlYW0pLFxuICAgICAgICAgIGNodW5rcy5zZXQoaWQsIHN0cmVhbSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0UmVhZGFibGVTdHJlYW0ocmVzcG9uc2UsIGlkLCB0eXBlLCBzdHJlYW1TdGF0ZSkge1xuICAgICAgdmFyIGNvbnRyb2xsZXIgPSBudWxsLFxuICAgICAgICBjbG9zZWQgPSAhMTtcbiAgICAgIHR5cGUgPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBzdGFydDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBjb250cm9sbGVyID0gYztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgcHJldmlvdXNCbG9ja2VkQ2h1bmsgPSBudWxsO1xuICAgICAgcmVzb2x2ZVN0cmVhbShcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIGlkLFxuICAgICAgICB0eXBlLFxuICAgICAgICB7XG4gICAgICAgICAgZW5xdWV1ZVZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzQmxvY2tlZENodW5rXG4gICAgICAgICAgICAgID8gY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKVxuICAgICAgICAgICAgICA6IHByZXZpb3VzQmxvY2tlZENodW5rLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVucXVldWVNb2RlbDogZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBwcmV2aW91c0Jsb2NrZWRDaHVuaykge1xuICAgICAgICAgICAgICB2YXIgY2h1bmsgPSBjcmVhdGVSZXNvbHZlZE1vZGVsQ2h1bmsocmVzcG9uc2UsIGpzb24pO1xuICAgICAgICAgICAgICBpbml0aWFsaXplTW9kZWxDaHVuayhjaHVuayk7XG4gICAgICAgICAgICAgIFwiZnVsZmlsbGVkXCIgPT09IGNodW5rLnN0YXR1c1xuICAgICAgICAgICAgICAgID8gY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLnZhbHVlKVxuICAgICAgICAgICAgICAgIDogKGNodW5rLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZW5xdWV1ZSh2KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIChwcmV2aW91c0Jsb2NrZWRDaHVuayA9IGNodW5rKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjaHVuayA9IHByZXZpb3VzQmxvY2tlZENodW5rO1xuICAgICAgICAgICAgICB2YXIgX2NodW5rMyA9IGNyZWF0ZVBlbmRpbmdDaHVuayhyZXNwb25zZSk7XG4gICAgICAgICAgICAgIF9jaHVuazMudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZW5xdWV1ZSh2KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHByZXZpb3VzQmxvY2tlZENodW5rID0gX2NodW5rMztcbiAgICAgICAgICAgICAgY2h1bmsudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNCbG9ja2VkQ2h1bmsgPT09IF9jaHVuazMgJiZcbiAgICAgICAgICAgICAgICAgIChwcmV2aW91c0Jsb2NrZWRDaHVuayA9IG51bGwpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVNb2RlbENodW5rKHJlc3BvbnNlLCBfY2h1bmszLCBqc29uKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFjbG9zZWQpXG4gICAgICAgICAgICAgIGlmICgoKGNsb3NlZCA9ICEwKSwgbnVsbCA9PT0gcHJldmlvdXNCbG9ja2VkQ2h1bmspKVxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrZWRDaHVuayA9IHByZXZpb3VzQmxvY2tlZENodW5rO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzQmxvY2tlZENodW5rID0gbnVsbDtcbiAgICAgICAgICAgICAgICBibG9ja2VkQ2h1bmsudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIWNsb3NlZClcbiAgICAgICAgICAgICAgaWYgKCgoY2xvc2VkID0gITApLCBudWxsID09PSBwcmV2aW91c0Jsb2NrZWRDaHVuaykpXG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBibG9ja2VkQ2h1bmsgPSBwcmV2aW91c0Jsb2NrZWRDaHVuaztcbiAgICAgICAgICAgICAgICBwcmV2aW91c0Jsb2NrZWRDaHVuayA9IG51bGw7XG4gICAgICAgICAgICAgICAgYmxvY2tlZENodW5rLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJlYW1TdGF0ZVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXN5bmNJdGVyYXRvcigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVJdGVyYXRvcihuZXh0KSB7XG4gICAgICBuZXh0ID0geyBuZXh0OiBuZXh0IH07XG4gICAgICBuZXh0W0FTWU5DX0lURVJBVE9SXSA9IGFzeW5jSXRlcmF0b3I7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRBc3luY0l0ZXJhYmxlKHJlc3BvbnNlLCBpZCwgaXRlcmF0b3IsIHN0cmVhbVN0YXRlKSB7XG4gICAgICB2YXIgYnVmZmVyID0gW10sXG4gICAgICAgIGNsb3NlZCA9ICExLFxuICAgICAgICBuZXh0V3JpdGVJbmRleCA9IDAsXG4gICAgICAgIGl0ZXJhYmxlID0ge307XG4gICAgICBpdGVyYWJsZVtBU1lOQ19JVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0UmVhZEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUl0ZXJhdG9yKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICBpZiAodm9pZCAwICE9PSBhcmcpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJWYWx1ZXMgY2Fubm90IGJlIHBhc3NlZCB0byBuZXh0KCkgb2YgQXN5bmNJdGVyYWJsZXMgcGFzc2VkIHRvIENsaWVudCBDb21wb25lbnRzLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXh0UmVhZEluZGV4ID09PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoY2xvc2VkKVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlYWN0UHJvbWlzZShcbiAgICAgICAgICAgICAgICBcImZ1bGZpbGxlZFwiLFxuICAgICAgICAgICAgICAgIHsgZG9uZTogITAsIHZhbHVlOiB2b2lkIDAgfSxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBidWZmZXJbbmV4dFJlYWRJbmRleF0gPSBjcmVhdGVQZW5kaW5nQ2h1bmsocmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYnVmZmVyW25leHRSZWFkSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJlc29sdmVTdHJlYW0oXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICBpZCxcbiAgICAgICAgaXRlcmF0b3IgPyBpdGVyYWJsZVtBU1lOQ19JVEVSQVRPUl0oKSA6IGl0ZXJhYmxlLFxuICAgICAgICB7XG4gICAgICAgICAgZW5xdWV1ZVZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChuZXh0V3JpdGVJbmRleCA9PT0gYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgICAgYnVmZmVyW25leHRXcml0ZUluZGV4XSA9IG5ldyBSZWFjdFByb21pc2UoXG4gICAgICAgICAgICAgICAgXCJmdWxmaWxsZWRcIixcbiAgICAgICAgICAgICAgICB7IGRvbmU6ICExLCB2YWx1ZTogdmFsdWUgfSxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGNodW5rID0gYnVmZmVyW25leHRXcml0ZUluZGV4XSxcbiAgICAgICAgICAgICAgICByZXNvbHZlTGlzdGVuZXJzID0gY2h1bmsudmFsdWUsXG4gICAgICAgICAgICAgICAgcmVqZWN0TGlzdGVuZXJzID0gY2h1bmsucmVhc29uO1xuICAgICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICAgICAgICBjaHVuay52YWx1ZSA9IHsgZG9uZTogITEsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICAgICAgICBjaHVuay5yZWFzb24gPSBudWxsO1xuICAgICAgICAgICAgICBudWxsICE9PSByZXNvbHZlTGlzdGVuZXJzICYmXG4gICAgICAgICAgICAgICAgd2FrZUNodW5rSWZJbml0aWFsaXplZChcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICAgICAgICByZXNvbHZlTGlzdGVuZXJzLFxuICAgICAgICAgICAgICAgICAgcmVqZWN0TGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRXcml0ZUluZGV4Kys7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnF1ZXVlTW9kZWw6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgbmV4dFdyaXRlSW5kZXggPT09IGJ1ZmZlci5sZW5ndGhcbiAgICAgICAgICAgICAgPyAoYnVmZmVyW25leHRXcml0ZUluZGV4XSA9IGNyZWF0ZVJlc29sdmVkSXRlcmF0b3JSZXN1bHRDaHVuayhcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgIDogcmVzb2x2ZUl0ZXJhdG9yUmVzdWx0Q2h1bmsoXG4gICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlcltuZXh0V3JpdGVJbmRleF0sXG4gICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5leHRXcml0ZUluZGV4Kys7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIWNsb3NlZClcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBjbG9zZWQgPSAhMCxcbiAgICAgICAgICAgICAgICAgIG5leHRXcml0ZUluZGV4ID09PSBidWZmZXIubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gKGJ1ZmZlcltuZXh0V3JpdGVJbmRleF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmVzb2x2ZWRJdGVyYXRvclJlc3VsdENodW5rKHJlc3BvbnNlLCB2YWx1ZSwgITApKVxuICAgICAgICAgICAgICAgICAgICA6IHJlc29sdmVJdGVyYXRvclJlc3VsdENodW5rKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJbbmV4dFdyaXRlSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBuZXh0V3JpdGVJbmRleCsrO1xuICAgICAgICAgICAgICAgIG5leHRXcml0ZUluZGV4IDwgYnVmZmVyLmxlbmd0aDtcblxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgcmVzb2x2ZUl0ZXJhdG9yUmVzdWx0Q2h1bmsoXG4gICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlcltuZXh0V3JpdGVJbmRleCsrXSxcbiAgICAgICAgICAgICAgICAgICdcIiR1bmRlZmluZWRcIicsXG4gICAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIWNsb3NlZClcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBjbG9zZWQgPSAhMCxcbiAgICAgICAgICAgICAgICAgIG5leHRXcml0ZUluZGV4ID09PSBidWZmZXIubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIChidWZmZXJbbmV4dFdyaXRlSW5kZXhdID0gY3JlYXRlUGVuZGluZ0NodW5rKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgbmV4dFdyaXRlSW5kZXggPCBidWZmZXIubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXJyb3JPbkNodW5rKHJlc3BvbnNlLCBidWZmZXJbbmV4dFdyaXRlSW5kZXgrK10sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmVhbVN0YXRlXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlRXJyb3JEZXYocmVzcG9uc2UsIGVycm9ySW5mbykge1xuICAgICAgdmFyIG5hbWUgPSBlcnJvckluZm8ubmFtZSxcbiAgICAgICAgZW52ID0gZXJyb3JJbmZvLmVudjtcbiAgICAgIHZhciBlcnJvciA9IGJ1aWxkRmFrZUNhbGxTdGFjayhcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIGVycm9ySW5mby5zdGFjayxcbiAgICAgICAgZW52LFxuICAgICAgICAhMSxcbiAgICAgICAgRXJyb3IuYmluZChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIGVycm9ySW5mby5tZXNzYWdlIHx8XG4gICAgICAgICAgICBcIkFuIGVycm9yIG9jY3VycmVkIGluIHRoZSBTZXJ2ZXIgQ29tcG9uZW50cyByZW5kZXIgYnV0IG5vIG1lc3NhZ2Ugd2FzIHByb3ZpZGVkXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHZhciBvd25lclRhc2sgPSBudWxsO1xuICAgICAgbnVsbCAhPSBlcnJvckluZm8ub3duZXIgJiZcbiAgICAgICAgKChlcnJvckluZm8gPSBlcnJvckluZm8ub3duZXIuc2xpY2UoMSkpLFxuICAgICAgICAoZXJyb3JJbmZvID0gZ2V0T3V0bGluZWRNb2RlbChcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICBlcnJvckluZm8sXG4gICAgICAgICAge30sXG4gICAgICAgICAgXCJcIixcbiAgICAgICAgICBjcmVhdGVNb2RlbFxuICAgICAgICApKSxcbiAgICAgICAgbnVsbCAhPT0gZXJyb3JJbmZvICYmXG4gICAgICAgICAgKG93bmVyVGFzayA9IGluaXRpYWxpemVGYWtlVGFzayhyZXNwb25zZSwgZXJyb3JJbmZvKSkpO1xuICAgICAgbnVsbCA9PT0gb3duZXJUYXNrXG4gICAgICAgID8gKChyZXNwb25zZSA9IGdldFJvb3RUYXNrKHJlc3BvbnNlLCBlbnYpKSxcbiAgICAgICAgICAoZXJyb3IgPSBudWxsICE9IHJlc3BvbnNlID8gcmVzcG9uc2UucnVuKGVycm9yKSA6IGVycm9yKCkpKVxuICAgICAgICA6IChlcnJvciA9IG93bmVyVGFzay5ydW4oZXJyb3IpKTtcbiAgICAgIGVycm9yLm5hbWUgPSBuYW1lO1xuICAgICAgZXJyb3IuZW52aXJvbm1lbnROYW1lID0gZW52O1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGYWtlRnVuY3Rpb24oXG4gICAgICBuYW1lLFxuICAgICAgZmlsZW5hbWUsXG4gICAgICBzb3VyY2VNYXAsXG4gICAgICBsaW5lLFxuICAgICAgY29sLFxuICAgICAgZW5jbG9zaW5nTGluZSxcbiAgICAgIGVuY2xvc2luZ0NvbCxcbiAgICAgIGVudmlyb25tZW50TmFtZVxuICAgICkge1xuICAgICAgbmFtZSB8fCAobmFtZSA9IFwiPGFub255bW91cz5cIik7XG4gICAgICB2YXIgZW5jb2RlZE5hbWUgPSBKU09OLnN0cmluZ2lmeShuYW1lKTtcbiAgICAgIDEgPiBlbmNsb3NpbmdMaW5lID8gKGVuY2xvc2luZ0xpbmUgPSAwKSA6IGVuY2xvc2luZ0xpbmUtLTtcbiAgICAgIDEgPiBlbmNsb3NpbmdDb2wgPyAoZW5jbG9zaW5nQ29sID0gMCkgOiBlbmNsb3NpbmdDb2wtLTtcbiAgICAgIDEgPiBsaW5lID8gKGxpbmUgPSAwKSA6IGxpbmUtLTtcbiAgICAgIDEgPiBjb2wgPyAoY29sID0gMCkgOiBjb2wtLTtcbiAgICAgIGlmIChcbiAgICAgICAgbGluZSA8IGVuY2xvc2luZ0xpbmUgfHxcbiAgICAgICAgKGxpbmUgPT09IGVuY2xvc2luZ0xpbmUgJiYgY29sIDwgZW5jbG9zaW5nQ29sKVxuICAgICAgKVxuICAgICAgICBlbmNsb3NpbmdDb2wgPSBlbmNsb3NpbmdMaW5lID0gMDtcbiAgICAgIDEgPiBsaW5lXG4gICAgICAgID8gKChsaW5lID0gZW5jb2RlZE5hbWUubGVuZ3RoICsgMyksXG4gICAgICAgICAgKGVuY2xvc2luZ0NvbCAtPSBsaW5lKSxcbiAgICAgICAgICAwID4gZW5jbG9zaW5nQ29sICYmIChlbmNsb3NpbmdDb2wgPSAwKSxcbiAgICAgICAgICAoY29sID0gY29sIC0gZW5jbG9zaW5nQ29sIC0gbGluZSAtIDMpLFxuICAgICAgICAgIDAgPiBjb2wgJiYgKGNvbCA9IDApLFxuICAgICAgICAgIChlbmNvZGVkTmFtZSA9XG4gICAgICAgICAgICBcIih7XCIgK1xuICAgICAgICAgICAgZW5jb2RlZE5hbWUgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgXCIgXCIucmVwZWF0KGVuY2xvc2luZ0NvbCkgK1xuICAgICAgICAgICAgXCJfPT5cIiArXG4gICAgICAgICAgICBcIiBcIi5yZXBlYXQoY29sKSArXG4gICAgICAgICAgICBcIl8oKX0pXCIpKVxuICAgICAgICA6IDEgPiBlbmNsb3NpbmdMaW5lXG4gICAgICAgICAgPyAoKGVuY2xvc2luZ0NvbCAtPSBlbmNvZGVkTmFtZS5sZW5ndGggKyAzKSxcbiAgICAgICAgICAgIDAgPiBlbmNsb3NpbmdDb2wgJiYgKGVuY2xvc2luZ0NvbCA9IDApLFxuICAgICAgICAgICAgKGVuY29kZWROYW1lID1cbiAgICAgICAgICAgICAgXCIoe1wiICtcbiAgICAgICAgICAgICAgZW5jb2RlZE5hbWUgK1xuICAgICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICAgIFwiIFwiLnJlcGVhdChlbmNsb3NpbmdDb2wpICtcbiAgICAgICAgICAgICAgXCJfPT5cIiArXG4gICAgICAgICAgICAgIFwiXFxuXCIucmVwZWF0KGxpbmUgLSBlbmNsb3NpbmdMaW5lKSArXG4gICAgICAgICAgICAgIFwiIFwiLnJlcGVhdChjb2wpICtcbiAgICAgICAgICAgICAgXCJfKCl9KVwiKSlcbiAgICAgICAgICA6IGVuY2xvc2luZ0xpbmUgPT09IGxpbmVcbiAgICAgICAgICAgID8gKChjb2wgPSBjb2wgLSBlbmNsb3NpbmdDb2wgLSAzKSxcbiAgICAgICAgICAgICAgMCA+IGNvbCAmJiAoY29sID0gMCksXG4gICAgICAgICAgICAgIChlbmNvZGVkTmFtZSA9XG4gICAgICAgICAgICAgICAgXCJcXG5cIi5yZXBlYXQoZW5jbG9zaW5nTGluZSAtIDEpICtcbiAgICAgICAgICAgICAgICBcIih7XCIgK1xuICAgICAgICAgICAgICAgIGVuY29kZWROYW1lICtcbiAgICAgICAgICAgICAgICBcIjpcXG5cIiArXG4gICAgICAgICAgICAgICAgXCIgXCIucmVwZWF0KGVuY2xvc2luZ0NvbCkgK1xuICAgICAgICAgICAgICAgIFwiXz0+XCIgK1xuICAgICAgICAgICAgICAgIFwiIFwiLnJlcGVhdChjb2wpICtcbiAgICAgICAgICAgICAgICBcIl8oKX0pXCIpKVxuICAgICAgICAgICAgOiAoZW5jb2RlZE5hbWUgPVxuICAgICAgICAgICAgICAgIFwiXFxuXCIucmVwZWF0KGVuY2xvc2luZ0xpbmUgLSAxKSArXG4gICAgICAgICAgICAgICAgXCIoe1wiICtcbiAgICAgICAgICAgICAgICBlbmNvZGVkTmFtZSArXG4gICAgICAgICAgICAgICAgXCI6XFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiIFwiLnJlcGVhdChlbmNsb3NpbmdDb2wpICtcbiAgICAgICAgICAgICAgICBcIl89PlwiICtcbiAgICAgICAgICAgICAgICBcIlxcblwiLnJlcGVhdChsaW5lIC0gZW5jbG9zaW5nTGluZSkgK1xuICAgICAgICAgICAgICAgIFwiIFwiLnJlcGVhdChjb2wpICtcbiAgICAgICAgICAgICAgICBcIl8oKX0pXCIpO1xuICAgICAgZW5jb2RlZE5hbWUgPVxuICAgICAgICAxID4gZW5jbG9zaW5nTGluZVxuICAgICAgICAgID8gZW5jb2RlZE5hbWUgK1xuICAgICAgICAgICAgXCJcXG4vKiBUaGlzIG1vZHVsZSB3YXMgcmVuZGVyZWQgYnkgYSBTZXJ2ZXIgQ29tcG9uZW50LiBUdXJuIG9uIFNvdXJjZSBNYXBzIHRvIHNlZSB0aGUgc2VydmVyIHNvdXJjZS4gKi9cIlxuICAgICAgICAgIDogXCIvKiBUaGlzIG1vZHVsZSB3YXMgcmVuZGVyZWQgYnkgYSBTZXJ2ZXIgQ29tcG9uZW50LiBUdXJuIG9uIFNvdXJjZSBNYXBzIHRvIHNlZSB0aGUgc2VydmVyIHNvdXJjZS4gKi9cIiArXG4gICAgICAgICAgICBlbmNvZGVkTmFtZTtcbiAgICAgIGZpbGVuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpICYmIChmaWxlbmFtZSA9IFwiZmlsZTovL1wiICsgZmlsZW5hbWUpO1xuICAgICAgc291cmNlTWFwXG4gICAgICAgID8gKChlbmNvZGVkTmFtZSArPVxuICAgICAgICAgICAgXCJcXG4vLyMgc291cmNlVVJMPWFib3V0Oi8vUmVhY3QvXCIgK1xuICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGVudmlyb25tZW50TmFtZSkgK1xuICAgICAgICAgICAgXCIvXCIgK1xuICAgICAgICAgICAgZW5jb2RlVVJJKGZpbGVuYW1lKSArXG4gICAgICAgICAgICBcIj9cIiArXG4gICAgICAgICAgICBmYWtlRnVuY3Rpb25JZHgrKyksXG4gICAgICAgICAgKGVuY29kZWROYW1lICs9IFwiXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9XCIgKyBzb3VyY2VNYXApKVxuICAgICAgICA6IChlbmNvZGVkTmFtZSA9IGZpbGVuYW1lXG4gICAgICAgICAgICA/IGVuY29kZWROYW1lICsgKFwiXFxuLy8jIHNvdXJjZVVSTD1cIiArIGVuY29kZVVSSShmaWxlbmFtZSkpXG4gICAgICAgICAgICA6IGVuY29kZWROYW1lICsgXCJcXG4vLyMgc291cmNlVVJMPTxhbm9ueW1vdXM+XCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGZuID0gKDAsIGV2YWwpKGVuY29kZWROYW1lKVtuYW1lXTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgZm4gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgIHJldHVybiBfKCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1aWxkRmFrZUNhbGxTdGFjayhcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgc3RhY2ssXG4gICAgICBlbnZpcm9ubWVudE5hbWUsXG4gICAgICB1c2VFbmNsb3NpbmdMaW5lLFxuICAgICAgaW5uZXJDYWxsXG4gICAgKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmcmFtZSA9IHN0YWNrW2ldLFxuICAgICAgICAgIGZyYW1lS2V5ID1cbiAgICAgICAgICAgIGZyYW1lLmpvaW4oXCItXCIpICtcbiAgICAgICAgICAgIFwiLVwiICtcbiAgICAgICAgICAgIGVudmlyb25tZW50TmFtZSArXG4gICAgICAgICAgICAodXNlRW5jbG9zaW5nTGluZSA/IFwiLWVcIiA6IFwiLW5cIiksXG4gICAgICAgICAgZm4gPSBmYWtlRnVuY3Rpb25DYWNoZS5nZXQoZnJhbWVLZXkpO1xuICAgICAgICBpZiAodm9pZCAwID09PSBmbikge1xuICAgICAgICAgIGZuID0gZnJhbWVbMF07XG4gICAgICAgICAgdmFyIGZpbGVuYW1lID0gZnJhbWVbMV0sXG4gICAgICAgICAgICBsaW5lID0gZnJhbWVbMl0sXG4gICAgICAgICAgICBjb2wgPSBmcmFtZVszXSxcbiAgICAgICAgICAgIGVuY2xvc2luZ0xpbmUgPSBmcmFtZVs0XTtcbiAgICAgICAgICBmcmFtZSA9IGZyYW1lWzVdO1xuICAgICAgICAgIHZhciBmaW5kU291cmNlTWFwVVJMID0gcmVzcG9uc2UuX2RlYnVnRmluZFNvdXJjZU1hcFVSTDtcbiAgICAgICAgICBmaW5kU291cmNlTWFwVVJMID0gZmluZFNvdXJjZU1hcFVSTFxuICAgICAgICAgICAgPyBmaW5kU291cmNlTWFwVVJMKGZpbGVuYW1lLCBlbnZpcm9ubWVudE5hbWUpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgZm4gPSBjcmVhdGVGYWtlRnVuY3Rpb24oXG4gICAgICAgICAgICBmbixcbiAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgZmluZFNvdXJjZU1hcFVSTCxcbiAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICBjb2wsXG4gICAgICAgICAgICB1c2VFbmNsb3NpbmdMaW5lID8gbGluZSA6IGVuY2xvc2luZ0xpbmUsXG4gICAgICAgICAgICB1c2VFbmNsb3NpbmdMaW5lID8gY29sIDogZnJhbWUsXG4gICAgICAgICAgICBlbnZpcm9ubWVudE5hbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGZha2VGdW5jdGlvbkNhY2hlLnNldChmcmFtZUtleSwgZm4pO1xuICAgICAgICB9XG4gICAgICAgIGlubmVyQ2FsbCA9IGZuLmJpbmQobnVsbCwgaW5uZXJDYWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbm5lckNhbGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFJvb3RUYXNrKHJlc3BvbnNlLCBjaGlsZEVudmlyb25tZW50TmFtZSkge1xuICAgICAgdmFyIHJvb3RUYXNrID0gcmVzcG9uc2UuX2RlYnVnUm9vdFRhc2s7XG4gICAgICByZXR1cm4gcm9vdFRhc2tcbiAgICAgICAgPyByZXNwb25zZS5fcm9vdEVudmlyb25tZW50TmFtZSAhPT0gY2hpbGRFbnZpcm9ubWVudE5hbWVcbiAgICAgICAgICA/ICgocmVzcG9uc2UgPSBjb25zb2xlLmNyZWF0ZVRhc2suYmluZChcbiAgICAgICAgICAgICAgY29uc29sZSxcbiAgICAgICAgICAgICAgJ1widXNlICcgKyBjaGlsZEVudmlyb25tZW50TmFtZS50b0xvd2VyQ2FzZSgpICsgJ1wiJ1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICByb290VGFzay5ydW4ocmVzcG9uc2UpKVxuICAgICAgICAgIDogcm9vdFRhc2tcbiAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplRmFrZVRhc2socmVzcG9uc2UsIGRlYnVnSW5mbykge1xuICAgICAgaWYgKCFzdXBwb3J0c0NyZWF0ZVRhc2sgfHwgbnVsbCA9PSBkZWJ1Z0luZm8uc3RhY2spIHJldHVybiBudWxsO1xuICAgICAgdmFyIGNhY2hlZEVudHJ5ID0gZGVidWdJbmZvLmRlYnVnVGFzaztcbiAgICAgIGlmICh2b2lkIDAgIT09IGNhY2hlZEVudHJ5KSByZXR1cm4gY2FjaGVkRW50cnk7XG4gICAgICB2YXIgdXNlRW5jbG9zaW5nTGluZSA9IHZvaWQgMCA9PT0gZGVidWdJbmZvLmtleSxcbiAgICAgICAgc3RhY2sgPSBkZWJ1Z0luZm8uc3RhY2ssXG4gICAgICAgIGVudiA9XG4gICAgICAgICAgbnVsbCA9PSBkZWJ1Z0luZm8uZW52ID8gcmVzcG9uc2UuX3Jvb3RFbnZpcm9ubWVudE5hbWUgOiBkZWJ1Z0luZm8uZW52O1xuICAgICAgY2FjaGVkRW50cnkgPVxuICAgICAgICBudWxsID09IGRlYnVnSW5mby5vd25lciB8fCBudWxsID09IGRlYnVnSW5mby5vd25lci5lbnZcbiAgICAgICAgICA/IHJlc3BvbnNlLl9yb290RW52aXJvbm1lbnROYW1lXG4gICAgICAgICAgOiBkZWJ1Z0luZm8ub3duZXIuZW52O1xuICAgICAgdmFyIG93bmVyVGFzayA9XG4gICAgICAgIG51bGwgPT0gZGVidWdJbmZvLm93bmVyXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiBpbml0aWFsaXplRmFrZVRhc2socmVzcG9uc2UsIGRlYnVnSW5mby5vd25lcik7XG4gICAgICBlbnYgPVxuICAgICAgICBlbnYgIT09IGNhY2hlZEVudHJ5XG4gICAgICAgICAgPyAnXCJ1c2UgJyArIGVudi50b0xvd2VyQ2FzZSgpICsgJ1wiJ1xuICAgICAgICAgIDogdm9pZCAwICE9PSBkZWJ1Z0luZm8ua2V5XG4gICAgICAgICAgICA/IFwiPFwiICsgKGRlYnVnSW5mby5uYW1lIHx8IFwiLi4uXCIpICsgXCI+XCJcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSBkZWJ1Z0luZm8ubmFtZVxuICAgICAgICAgICAgICA/IGRlYnVnSW5mby5uYW1lIHx8IFwidW5rbm93blwiXG4gICAgICAgICAgICAgIDogXCJhd2FpdCBcIiArIChkZWJ1Z0luZm8uYXdhaXRlZC5uYW1lIHx8IFwidW5rbm93blwiKTtcbiAgICAgIGVudiA9IGNvbnNvbGUuY3JlYXRlVGFzay5iaW5kKGNvbnNvbGUsIGVudik7XG4gICAgICB1c2VFbmNsb3NpbmdMaW5lID0gYnVpbGRGYWtlQ2FsbFN0YWNrKFxuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgc3RhY2ssXG4gICAgICAgIGNhY2hlZEVudHJ5LFxuICAgICAgICB1c2VFbmNsb3NpbmdMaW5lLFxuICAgICAgICBlbnZcbiAgICAgICk7XG4gICAgICBudWxsID09PSBvd25lclRhc2tcbiAgICAgICAgPyAoKHJlc3BvbnNlID0gZ2V0Um9vdFRhc2socmVzcG9uc2UsIGNhY2hlZEVudHJ5KSksXG4gICAgICAgICAgKHJlc3BvbnNlID1cbiAgICAgICAgICAgIG51bGwgIT0gcmVzcG9uc2VcbiAgICAgICAgICAgICAgPyByZXNwb25zZS5ydW4odXNlRW5jbG9zaW5nTGluZSlcbiAgICAgICAgICAgICAgOiB1c2VFbmNsb3NpbmdMaW5lKCkpKVxuICAgICAgICA6IChyZXNwb25zZSA9IG93bmVyVGFzay5ydW4odXNlRW5jbG9zaW5nTGluZSkpO1xuICAgICAgcmV0dXJuIChkZWJ1Z0luZm8uZGVidWdUYXNrID0gcmVzcG9uc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmYWtlSlNYQ2FsbFNpdGUoKSB7XG4gICAgICByZXR1cm4gRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVGYWtlU3RhY2socmVzcG9uc2UsIGRlYnVnSW5mbykge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gZGVidWdJbmZvLmRlYnVnU3RhY2spIHtcbiAgICAgICAgbnVsbCAhPSBkZWJ1Z0luZm8uc3RhY2sgJiZcbiAgICAgICAgICAoZGVidWdJbmZvLmRlYnVnU3RhY2sgPSBjcmVhdGVGYWtlSlNYQ2FsbFN0YWNrSW5ERVYoXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIGRlYnVnSW5mby5zdGFjayxcbiAgICAgICAgICAgIG51bGwgPT0gZGVidWdJbmZvLmVudiA/IFwiXCIgOiBkZWJ1Z0luZm8uZW52XG4gICAgICAgICAgKSk7XG4gICAgICAgIHZhciBvd25lciA9IGRlYnVnSW5mby5vd25lcjtcbiAgICAgICAgbnVsbCAhPSBvd25lciAmJlxuICAgICAgICAgIChpbml0aWFsaXplRmFrZVN0YWNrKHJlc3BvbnNlLCBvd25lciksXG4gICAgICAgICAgdm9pZCAwID09PSBvd25lci5kZWJ1Z0xvY2F0aW9uICYmXG4gICAgICAgICAgICBudWxsICE9IGRlYnVnSW5mby5kZWJ1Z1N0YWNrICYmXG4gICAgICAgICAgICAob3duZXIuZGVidWdMb2NhdGlvbiA9IGRlYnVnSW5mby5kZWJ1Z1N0YWNrKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVEZWJ1Z0luZm8ocmVzcG9uc2UsIGRlYnVnSW5mbykge1xuICAgICAgdm9pZCAwICE9PSBkZWJ1Z0luZm8uc3RhY2sgJiYgaW5pdGlhbGl6ZUZha2VUYXNrKHJlc3BvbnNlLCBkZWJ1Z0luZm8pO1xuICAgICAgaWYgKG51bGwgPT0gZGVidWdJbmZvLm93bmVyICYmIG51bGwgIT0gcmVzcG9uc2UuX2RlYnVnUm9vdE93bmVyKSB7XG4gICAgICAgIHZhciBfY29tcG9uZW50SW5mb09yQXN5bmNJbmZvID0gZGVidWdJbmZvO1xuICAgICAgICBfY29tcG9uZW50SW5mb09yQXN5bmNJbmZvLm93bmVyID0gcmVzcG9uc2UuX2RlYnVnUm9vdE93bmVyO1xuICAgICAgICBfY29tcG9uZW50SW5mb09yQXN5bmNJbmZvLnN0YWNrID0gbnVsbDtcbiAgICAgICAgX2NvbXBvbmVudEluZm9PckFzeW5jSW5mby5kZWJ1Z1N0YWNrID0gcmVzcG9uc2UuX2RlYnVnUm9vdFN0YWNrO1xuICAgICAgICBfY29tcG9uZW50SW5mb09yQXN5bmNJbmZvLmRlYnVnVGFzayA9IHJlc3BvbnNlLl9kZWJ1Z1Jvb3RUYXNrO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHZvaWQgMCAhPT0gZGVidWdJbmZvLnN0YWNrICYmIGluaXRpYWxpemVGYWtlU3RhY2socmVzcG9uc2UsIGRlYnVnSW5mbyk7XG4gICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgZGVidWdJbmZvLnRpbWUgJiZcbiAgICAgICAgKGRlYnVnSW5mbyA9IHsgdGltZTogZGVidWdJbmZvLnRpbWUgKyByZXNwb25zZS5fdGltZU9yaWdpbiB9KTtcbiAgICAgIHJldHVybiBkZWJ1Z0luZm87XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRTdGFja0luREVWKCkge1xuICAgICAgdmFyIG93bmVyID0gY3VycmVudE93bmVySW5ERVY7XG4gICAgICBpZiAobnVsbCA9PT0gb3duZXIpIHJldHVybiBcIlwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGluZm8gPSBcIlwiO1xuICAgICAgICBpZiAob3duZXIub3duZXIgfHwgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG93bmVyLm5hbWUpIHtcbiAgICAgICAgICBmb3IgKDsgb3duZXI7ICkge1xuICAgICAgICAgICAgdmFyIG93bmVyU3RhY2sgPSBvd25lci5kZWJ1Z1N0YWNrO1xuICAgICAgICAgICAgaWYgKG51bGwgIT0gb3duZXJTdGFjaykge1xuICAgICAgICAgICAgICBpZiAoKG93bmVyID0gb3duZXIub3duZXIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IGluZm87XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gb3duZXJTdGFjayxcbiAgICAgICAgICAgICAgICAgIHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgICAgICAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrO1xuICAgICAgICAgICAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldlByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgICAgICAgICAgIHN0YWNrLnN0YXJ0c1dpdGgoXCJFcnJvcjogcmVhY3Qtc3RhY2stdG9wLWZyYW1lXFxuXCIpICYmXG4gICAgICAgICAgICAgICAgICAoc3RhY2sgPSBzdGFjay5zbGljZSgyOSkpO1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBzdGFjay5pbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIC0xICE9PSBpZHggJiYgKHN0YWNrID0gc3RhY2suc2xpY2UoaWR4ICsgMSkpO1xuICAgICAgICAgICAgICAgIGlkeCA9IHN0YWNrLmluZGV4T2YoXCJyZWFjdF9zdGFja19ib3R0b21fZnJhbWVcIik7XG4gICAgICAgICAgICAgICAgLTEgIT09IGlkeCAmJiAoaWR4ID0gc3RhY2subGFzdEluZGV4T2YoXCJcXG5cIiwgaWR4KSk7XG4gICAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAtMSAhPT0gaWR4ID8gKHN0YWNrID0gc3RhY2suc2xpY2UoMCwgaWR4KSkgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGluZm8gPVxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0ICsgKFwiXFxuXCIgKyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBpbmZvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IG93bmVyLm5hbWU7XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gcHJlZml4KVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgKHByZWZpeCA9XG4gICAgICAgICAgICAgICAgKChlcnJvciA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLykpICYmIGVycm9yWzFdKSB8fFxuICAgICAgICAgICAgICAgIFwiXCIpLFxuICAgICAgICAgICAgICAgIChzdWZmaXggPVxuICAgICAgICAgICAgICAgICAgLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJcXG4gICAgYXRcIilcbiAgICAgICAgICAgICAgICAgICAgPyBcIiAoPGFub255bW91cz4pXCJcbiAgICAgICAgICAgICAgICAgICAgOiAtMSA8IHguc3RhY2suaW5kZXhPZihcIkBcIilcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiQHVua25vd246MDowXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgICBcIlxcblwiICsgcHJlZml4ICsgSlNDb21waWxlcl90ZW1wX2NvbnN0ICsgc3VmZml4O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgXCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIiArIHgubWVzc2FnZSArIFwiXFxuXCIgKyB4LnN0YWNrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUNvbnNvbGVFbnRyeShyZXNwb25zZSwganNvbikge1xuICAgICAgaWYgKHJlc3BvbnNlLl9yZXBsYXlDb25zb2xlKSB7XG4gICAgICAgIHZhciBibG9ja2VkQ2h1bmsgPSByZXNwb25zZS5fYmxvY2tlZENvbnNvbGU7XG4gICAgICAgIGlmIChudWxsID09IGJsb2NrZWRDaHVuaylcbiAgICAgICAgICAoYmxvY2tlZENodW5rID0gY3JlYXRlUmVzb2x2ZWRNb2RlbENodW5rKHJlc3BvbnNlLCBqc29uKSksXG4gICAgICAgICAgICBpbml0aWFsaXplTW9kZWxDaHVuayhibG9ja2VkQ2h1bmspLFxuICAgICAgICAgICAgXCJmdWxmaWxsZWRcIiA9PT0gYmxvY2tlZENodW5rLnN0YXR1c1xuICAgICAgICAgICAgICA/IHJlcGxheUNvbnNvbGVXaXRoQ2FsbFN0YWNrSW5ERVYocmVzcG9uc2UsIGJsb2NrZWRDaHVuay52YWx1ZSlcbiAgICAgICAgICAgICAgOiAoYmxvY2tlZENodW5rLnRoZW4oXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGF5Q29uc29sZVdpdGhDYWxsU3RhY2tJbkRFVihyZXNwb25zZSwgdik7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge31cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChyZXNwb25zZS5fYmxvY2tlZENvbnNvbGUgPSBibG9ja2VkQ2h1bmspKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIF9jaHVuazQgPSBjcmVhdGVQZW5kaW5nQ2h1bmsocmVzcG9uc2UpO1xuICAgICAgICAgIF9jaHVuazQudGhlbihcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXBsYXlDb25zb2xlV2l0aENhbGxTdGFja0luREVWKHJlc3BvbnNlLCB2KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7fVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzcG9uc2UuX2Jsb2NrZWRDb25zb2xlID0gX2NodW5rNDtcbiAgICAgICAgICB2YXIgdW5ibG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLl9ibG9ja2VkQ29uc29sZSA9PT0gX2NodW5rNCAmJlxuICAgICAgICAgICAgICAocmVzcG9uc2UuX2Jsb2NrZWRDb25zb2xlID0gbnVsbCk7XG4gICAgICAgICAgICByZXNvbHZlTW9kZWxDaHVuayhyZXNwb25zZSwgX2NodW5rNCwganNvbik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBibG9ja2VkQ2h1bmsudGhlbih1bmJsb2NrLCB1bmJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplSU9JbmZvKHJlc3BvbnNlLCBpb0luZm8pIHtcbiAgICAgIHZvaWQgMCAhPT0gaW9JbmZvLnN0YWNrICYmXG4gICAgICAgIChpbml0aWFsaXplRmFrZVRhc2socmVzcG9uc2UsIGlvSW5mbyksXG4gICAgICAgIGluaXRpYWxpemVGYWtlU3RhY2socmVzcG9uc2UsIGlvSW5mbykpO1xuICAgICAgaW9JbmZvLnN0YXJ0ICs9IHJlc3BvbnNlLl90aW1lT3JpZ2luO1xuICAgICAgaW9JbmZvLmVuZCArPSByZXNwb25zZS5fdGltZU9yaWdpbjtcbiAgICAgIGlmIChyZXNwb25zZS5fcmVwbGF5Q29uc29sZSkge1xuICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlLl9yb290RW52aXJvbm1lbnROYW1lO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IGlvSW5mby52YWx1ZTtcbiAgICAgICAgaWYgKHByb21pc2UpXG4gICAgICAgICAgc3dpdGNoIChwcm9taXNlLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgICAgICBsb2dJT0luZm8oaW9JbmZvLCByZXNwb25zZSwgcHJvbWlzZS52YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgICAgIGxvZ0lPSW5mb0Vycm9yZWQoaW9JbmZvLCByZXNwb25zZSwgcHJvbWlzZS5yZWFzb24pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHByb21pc2UudGhlbihcbiAgICAgICAgICAgICAgICBsb2dJT0luZm8uYmluZChudWxsLCBpb0luZm8sIHJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICBsb2dJT0luZm9FcnJvcmVkLmJpbmQobnVsbCwgaW9JbmZvLCByZXNwb25zZSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgbG9nSU9JbmZvKGlvSW5mbywgcmVzcG9uc2UsIHZvaWQgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVJT0luZm8ocmVzcG9uc2UsIGlkLCBtb2RlbCkge1xuICAgICAgdmFyIGNodW5rcyA9IHJlc3BvbnNlLl9jaHVua3MsXG4gICAgICAgIGNodW5rID0gY2h1bmtzLmdldChpZCk7XG4gICAgICBjaHVua1xuICAgICAgICA/IChyZXNvbHZlTW9kZWxDaHVuayhyZXNwb25zZSwgY2h1bmssIG1vZGVsKSxcbiAgICAgICAgICBcInJlc29sdmVkX21vZGVsXCIgPT09IGNodW5rLnN0YXR1cyAmJiBpbml0aWFsaXplTW9kZWxDaHVuayhjaHVuaykpXG4gICAgICAgIDogKChjaHVuayA9IGNyZWF0ZVJlc29sdmVkTW9kZWxDaHVuayhyZXNwb25zZSwgbW9kZWwpKSxcbiAgICAgICAgICBjaHVua3Muc2V0KGlkLCBjaHVuayksXG4gICAgICAgICAgaW5pdGlhbGl6ZU1vZGVsQ2h1bmsoY2h1bmspKTtcbiAgICAgIFwiZnVsZmlsbGVkXCIgPT09IGNodW5rLnN0YXR1c1xuICAgICAgICA/IGluaXRpYWxpemVJT0luZm8ocmVzcG9uc2UsIGNodW5rLnZhbHVlKVxuICAgICAgICA6IGNodW5rLnRoZW4oXG4gICAgICAgICAgICBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICBpbml0aWFsaXplSU9JbmZvKHJlc3BvbnNlLCB2KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7fVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lcmdlQnVmZmVyKGJ1ZmZlciwgbGFzdENodW5rKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgbCA9IGJ1ZmZlci5sZW5ndGgsIGJ5dGVMZW5ndGggPSBsYXN0Q2h1bmsubGVuZ3RoLCBpID0gMDtcbiAgICAgICAgaSA8IGw7XG4gICAgICAgIGkrK1xuICAgICAgKVxuICAgICAgICBieXRlTGVuZ3RoICs9IGJ1ZmZlcltpXS5ieXRlTGVuZ3RoO1xuICAgICAgYnl0ZUxlbmd0aCA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgICAgZm9yICh2YXIgX2kzID0gKGkgPSAwKTsgX2kzIDwgbDsgX2kzKyspIHtcbiAgICAgICAgdmFyIGNodW5rID0gYnVmZmVyW19pM107XG4gICAgICAgIGJ5dGVMZW5ndGguc2V0KGNodW5rLCBpKTtcbiAgICAgICAgaSArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgYnl0ZUxlbmd0aC5zZXQobGFzdENodW5rLCBpKTtcbiAgICAgIHJldHVybiBieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlVHlwZWRBcnJheShcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgaWQsXG4gICAgICBidWZmZXIsXG4gICAgICBsYXN0Q2h1bmssXG4gICAgICBjb25zdHJ1Y3RvcixcbiAgICAgIGJ5dGVzUGVyRWxlbWVudCxcbiAgICAgIHN0cmVhbVN0YXRlXG4gICAgKSB7XG4gICAgICBidWZmZXIgPVxuICAgICAgICAwID09PSBidWZmZXIubGVuZ3RoICYmIDAgPT09IGxhc3RDaHVuay5ieXRlT2Zmc2V0ICUgYnl0ZXNQZXJFbGVtZW50XG4gICAgICAgICAgPyBsYXN0Q2h1bmtcbiAgICAgICAgICA6IG1lcmdlQnVmZmVyKGJ1ZmZlciwgbGFzdENodW5rKTtcbiAgICAgIGNvbnN0cnVjdG9yID0gbmV3IGNvbnN0cnVjdG9yKFxuICAgICAgICBidWZmZXIuYnVmZmVyLFxuICAgICAgICBidWZmZXIuYnl0ZU9mZnNldCxcbiAgICAgICAgYnVmZmVyLmJ5dGVMZW5ndGggLyBieXRlc1BlckVsZW1lbnRcbiAgICAgICk7XG4gICAgICByZXNvbHZlQnVmZmVyKHJlc3BvbnNlLCBpZCwgY29uc3RydWN0b3IsIHN0cmVhbVN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hDb21wb25lbnRQZXJmb3JtYW5jZShcbiAgICAgIHJlc3BvbnNlJGpzY29tcCQwLFxuICAgICAgcm9vdCxcbiAgICAgIHRyYWNrSWR4JGpzY29tcCQ2LFxuICAgICAgdHJhY2tUaW1lLFxuICAgICAgcGFyZW50RW5kVGltZVxuICAgICkge1xuICAgICAgaWYgKCFpc0FycmF5SW1wbChyb290Ll9jaGlsZHJlbikpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzUmVzdWx0ID0gcm9vdC5fY2hpbGRyZW4sXG4gICAgICAgICAgcHJldmlvdXNFbmRUaW1lID0gcHJldmlvdXNSZXN1bHQuZW5kVGltZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIC1JbmZpbml0eSA8IHBhcmVudEVuZFRpbWUgJiZcbiAgICAgICAgICBwYXJlbnRFbmRUaW1lIDwgcHJldmlvdXNFbmRUaW1lICYmXG4gICAgICAgICAgbnVsbCAhPT0gcHJldmlvdXNSZXN1bHQuY29tcG9uZW50XG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBjb21wb25lbnRJbmZvID0gcHJldmlvdXNSZXN1bHQuY29tcG9uZW50LFxuICAgICAgICAgICAgdHJhY2tJZHggPSB0cmFja0lkeCRqc2NvbXAkNixcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IHBhcmVudEVuZFRpbWU7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZyAmJiAwIDw9IHByZXZpb3VzRW5kVGltZSAmJiAxMCA+IHRyYWNrSWR4KSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudEluZm8uZW52ID09PSByZXNwb25zZSRqc2NvbXAkMC5fcm9vdEVudmlyb25tZW50TmFtZVxuICAgICAgICAgICAgICAgICAgPyBcInByaW1hcnktbGlnaHRcIlxuICAgICAgICAgICAgICAgICAgOiBcInNlY29uZGFyeS1saWdodFwiLFxuICAgICAgICAgICAgICBlbnRyeU5hbWUgPSBjb21wb25lbnRJbmZvLm5hbWUgKyBcIiBbZGVkdXBlZF1cIixcbiAgICAgICAgICAgICAgZGVidWdUYXNrID0gY29tcG9uZW50SW5mby5kZWJ1Z1Rhc2s7XG4gICAgICAgICAgICBkZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgPyBkZWJ1Z1Rhc2sucnVuKFxuICAgICAgICAgICAgICAgICAgY29uc29sZS50aW1lU3RhbXAuYmluZChcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZSxcbiAgICAgICAgICAgICAgICAgICAgZW50cnlOYW1lLFxuICAgICAgICAgICAgICAgICAgICAwID4gc3RhcnRUaW1lID8gMCA6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNFbmRUaW1lLFxuICAgICAgICAgICAgICAgICAgICB0cmFja05hbWVzW3RyYWNrSWR4XSxcbiAgICAgICAgICAgICAgICAgICAgXCJTZXJ2ZXIgQ29tcG9uZW50cyBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IGNvbnNvbGUudGltZVN0YW1wKFxuICAgICAgICAgICAgICAgICAgZW50cnlOYW1lLFxuICAgICAgICAgICAgICAgICAgMCA+IHN0YXJ0VGltZSA/IDAgOiBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICBwcmV2aW91c0VuZFRpbWUsXG4gICAgICAgICAgICAgICAgICB0cmFja05hbWVzW3RyYWNrSWR4XSxcbiAgICAgICAgICAgICAgICAgIFwiU2VydmVyIENvbXBvbmVudHMgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgICAgY29sb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c1Jlc3VsdC50cmFjayA9IHRyYWNrSWR4JGpzY29tcCQ2O1xuICAgICAgICByZXR1cm4gcHJldmlvdXNSZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSByb290Ll9jaGlsZHJlbjtcbiAgICAgIHZhciBkZWJ1Z0luZm8gPSByb290Ll9kZWJ1Z0luZm87XG4gICAgICBpZiAoMCA9PT0gZGVidWdJbmZvLmxlbmd0aCAmJiBcImZ1bGZpbGxlZFwiID09PSByb290LnN0YXR1cykge1xuICAgICAgICB2YXIgcmVzb2x2ZWRWYWx1ZSA9IHJlc29sdmVMYXp5KHJvb3QudmFsdWUpO1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmVzb2x2ZWRWYWx1ZSAmJlxuICAgICAgICAgIG51bGwgIT09IHJlc29sdmVkVmFsdWUgJiZcbiAgICAgICAgICAoaXNBcnJheUltcGwocmVzb2x2ZWRWYWx1ZSkgfHxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlc29sdmVkVmFsdWVbQVNZTkNfSVRFUkFUT1JdIHx8XG4gICAgICAgICAgICByZXNvbHZlZFZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUgfHxcbiAgICAgICAgICAgIHJlc29sdmVkVmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSkgJiZcbiAgICAgICAgICBpc0FycmF5SW1wbChyZXNvbHZlZFZhbHVlLl9kZWJ1Z0luZm8pICYmXG4gICAgICAgICAgKGRlYnVnSW5mbyA9IHJlc29sdmVkVmFsdWUuX2RlYnVnSW5mbyk7XG4gICAgICB9XG4gICAgICBpZiAoZGVidWdJbmZvKSB7XG4gICAgICAgIGZvciAodmFyIHN0YXJ0VGltZSRqc2NvbXAkMCA9IDAsIGkgPSAwOyBpIDwgZGVidWdJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGluZm8gPSBkZWJ1Z0luZm9baV07XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGluZm8udGltZSAmJiAoc3RhcnRUaW1lJGpzY29tcCQwID0gaW5mby50aW1lKTtcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGluZm8ubmFtZSkge1xuICAgICAgICAgICAgc3RhcnRUaW1lJGpzY29tcCQwIDwgdHJhY2tUaW1lICYmIHRyYWNrSWR4JGpzY29tcCQ2Kys7XG4gICAgICAgICAgICB0cmFja1RpbWUgPSBzdGFydFRpbWUkanNjb21wJDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2k0ID0gZGVidWdJbmZvLmxlbmd0aCAtIDE7IDAgPD0gX2k0OyBfaTQtLSkge1xuICAgICAgICAgIHZhciBfaW5mbyA9IGRlYnVnSW5mb1tfaTRdO1xuICAgICAgICAgIGlmIChcIm51bWJlclwiID09PSB0eXBlb2YgX2luZm8udGltZSAmJiBfaW5mby50aW1lID4gcGFyZW50RW5kVGltZSkge1xuICAgICAgICAgICAgcGFyZW50RW5kVGltZSA9IF9pbmZvLnRpbWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHRyYWNrOiB0cmFja0lkeCRqc2NvbXAkNixcbiAgICAgICAgZW5kVGltZTogLUluZmluaXR5LFxuICAgICAgICBjb21wb25lbnQ6IG51bGxcbiAgICAgIH07XG4gICAgICByb290Ll9jaGlsZHJlbiA9IHJlc3VsdDtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBjaGlsZHJlbkVuZFRpbWUgPSAtSW5maW5pdHksXG4gICAgICAgICAgY2hpbGRUcmFja0lkeCA9IHRyYWNrSWR4JGpzY29tcCQ2LFxuICAgICAgICAgIGNoaWxkVHJhY2tUaW1lID0gdHJhY2tUaW1lLFxuICAgICAgICAgIF9pNSA9IDA7XG4gICAgICAgIF9pNSA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgX2k1KytcbiAgICAgICkge1xuICAgICAgICB2YXIgY2hpbGRSZXN1bHQgPSBmbHVzaENvbXBvbmVudFBlcmZvcm1hbmNlKFxuICAgICAgICAgIHJlc3BvbnNlJGpzY29tcCQwLFxuICAgICAgICAgIGNoaWxkcmVuW19pNV0sXG4gICAgICAgICAgY2hpbGRUcmFja0lkeCxcbiAgICAgICAgICBjaGlsZFRyYWNrVGltZSxcbiAgICAgICAgICBwYXJlbnRFbmRUaW1lXG4gICAgICAgICk7XG4gICAgICAgIG51bGwgIT09IGNoaWxkUmVzdWx0LmNvbXBvbmVudCAmJlxuICAgICAgICAgIChyZXN1bHQuY29tcG9uZW50ID0gY2hpbGRSZXN1bHQuY29tcG9uZW50KTtcbiAgICAgICAgY2hpbGRUcmFja0lkeCA9IGNoaWxkUmVzdWx0LnRyYWNrO1xuICAgICAgICB2YXIgY2hpbGRFbmRUaW1lID0gY2hpbGRSZXN1bHQuZW5kVGltZTtcbiAgICAgICAgY2hpbGRFbmRUaW1lID4gY2hpbGRUcmFja1RpbWUgJiYgKGNoaWxkVHJhY2tUaW1lID0gY2hpbGRFbmRUaW1lKTtcbiAgICAgICAgY2hpbGRFbmRUaW1lID4gY2hpbGRyZW5FbmRUaW1lICYmIChjaGlsZHJlbkVuZFRpbWUgPSBjaGlsZEVuZFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGRlYnVnSW5mbylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgY29tcG9uZW50RW5kVGltZSA9IDAsXG4gICAgICAgICAgICBpc0xhc3RDb21wb25lbnQgPSAhMCxcbiAgICAgICAgICAgIGVuZFRpbWUgPSAtMSxcbiAgICAgICAgICAgIGVuZFRpbWVJZHggPSAtMSxcbiAgICAgICAgICAgIF9pNiA9IGRlYnVnSW5mby5sZW5ndGggLSAxO1xuICAgICAgICAgIDAgPD0gX2k2O1xuICAgICAgICAgIF9pNi0tXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBfaW5mbzIgPSBkZWJ1Z0luZm9bX2k2XTtcbiAgICAgICAgICBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIF9pbmZvMi50aW1lKSB7XG4gICAgICAgICAgICAwID09PSBjb21wb25lbnRFbmRUaW1lICYmIChjb21wb25lbnRFbmRUaW1lID0gX2luZm8yLnRpbWUpO1xuICAgICAgICAgICAgdmFyIHRpbWUgPSBfaW5mbzIudGltZTtcbiAgICAgICAgICAgIGlmICgtMSA8IGVuZFRpbWVJZHgpXG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSBlbmRUaW1lSWR4IC0gMTsgaiA+IF9pNjsgai0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZUluZm8gPSBkZWJ1Z0luZm9bal07XG4gICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjYW5kaWRhdGVJbmZvLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEVuZFRpbWUgPiBjaGlsZHJlbkVuZFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgKGNoaWxkcmVuRW5kVGltZSA9IGNvbXBvbmVudEVuZFRpbWUpO1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudEluZm8kanNjb21wJDAgPSBjYW5kaWRhdGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRJbmZvJGpzY29tcCQxID0gY29tcG9uZW50SW5mbyRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tJZHgkanNjb21wJDAgPSB0cmFja0lkeCRqc2NvbXAkNixcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lJGpzY29tcCQxID0gdGltZSxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RW5kVGltZSRqc2NvbXAkMCA9IGNvbXBvbmVudEVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuRW5kVGltZSRqc2NvbXAkMCA9IGNoaWxkcmVuRW5kVGltZTtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaXNMYXN0Q29tcG9uZW50ICYmXG4gICAgICAgICAgICAgICAgICAgIFwicmVqZWN0ZWRcIiA9PT0gcm9vdC5zdGF0dXMgJiZcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5yZWFzb24gIT09IHJlc3BvbnNlLl9jbG9zZWRSZWFzb25cbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50SW5mbyRqc2NvbXAkMiA9IGNvbXBvbmVudEluZm8kanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgdHJhY2tJZHgkanNjb21wJDEgPSB0cmFja0lkeCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUkanNjb21wJDIgPSBzdGFydFRpbWUkanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5FbmRUaW1lJGpzY29tcCQxID0gY2hpbGRyZW5FbmRUaW1lJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gcm9vdC5yZWFzb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZW52ID0gY29tcG9uZW50SW5mbyRqc2NvbXAkMi5lbnYsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gY29tcG9uZW50SW5mbyRqc2NvbXAkMi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnlOYW1lJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW52ID09PSByZXNwb25zZS5fcm9vdEVudmlyb25tZW50TmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGVudlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmFtZSArIFwiIFtcIiArIGVudiArIFwiXVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVhc3VyZU5hbWUgPSBcIlxcdTIwMGJcIiArIGVudHJ5TmFtZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogU3RyaW5nKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT0gY29tcG9uZW50SW5mbyRqc2NvbXAkMi5rZXkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFZhbHVlVG9Qcm9wZXJ0aWVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImtleVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRJbmZvJGpzY29tcCQyLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICBudWxsICE9IGNvbXBvbmVudEluZm8kanNjb21wJDIucHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9iamVjdFRvUHJvcGVydGllcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50SW5mbyRqc2NvbXAkMi5wcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKG1lYXN1cmVOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogMCA+IHN0YXJ0VGltZSRqc2NvbXAkMiA/IDAgOiBzdGFydFRpbWUkanNjb21wJDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGNoaWxkcmVuRW5kVGltZSRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZ0b29sczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2s6IHRyYWNrTmFtZXNbdHJhY2tJZHgkanNjb21wJDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrR3JvdXA6IFwiU2VydmVyIENvbXBvbmVudHMgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBUZXh0OiBlbnRyeU5hbWUkanNjb21wJDAgKyBcIiBFcnJvcmVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhtZWFzdXJlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRJbmZvJGpzY29tcCQzID0gY29tcG9uZW50SW5mbyRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICAgICAgICB0cmFja0lkeCRqc2NvbXAkMiA9IHRyYWNrSWR4JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZSRqc2NvbXAkMyA9IHN0YXJ0VGltZSRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkVuZFRpbWUkanNjb21wJDIgPSBjaGlsZHJlbkVuZFRpbWUkanNjb21wJDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0c1VzZXJUaW1pbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAwIDw9IGNoaWxkcmVuRW5kVGltZSRqc2NvbXAkMiAmJlxuICAgICAgICAgICAgICAgICAgICAgIDEwID4gdHJhY2tJZHgkanNjb21wJDJcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGVudiRqc2NvbXAkMCA9IGNvbXBvbmVudEluZm8kanNjb21wJDMuZW52LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSRqc2NvbXAkMCA9IGNvbXBvbmVudEluZm8kanNjb21wJDMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJpbWFyeUVudiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVudiRqc2NvbXAkMCA9PT0gcmVzcG9uc2UuX3Jvb3RFbnZpcm9ubWVudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmVGltZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEVuZFRpbWUkanNjb21wJDAgLSBzdGFydFRpbWUkanNjb21wJDMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDAuNSA+IHNlbGZUaW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBpc1ByaW1hcnlFbnZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJwcmltYXJ5LWxpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJzZWNvbmRhcnktbGlnaHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogNTAgPiBzZWxmVGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBpc1ByaW1hcnlFbnZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcInByaW1hcnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogNTAwID4gc2VsZlRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBpc1ByaW1hcnlFbnZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwicHJpbWFyeS1kYXJrXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwic2Vjb25kYXJ5LWRhcmtcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnVGFzayRqc2NvbXAkMCA9IGNvbXBvbmVudEluZm8kanNjb21wJDMuZGVidWdUYXNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVhc3VyZU5hbWUkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdTIwMGJcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChpc1ByaW1hcnlFbnYgfHwgdm9pZCAwID09PSBlbnYkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5hbWUkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5hbWUkanNjb21wJDAgKyBcIiBbXCIgKyBlbnYkanNjb21wJDAgKyBcIl1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGRlYnVnVGFzayRqc2NvbXAkMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMkanNjb21wJDAgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT0gY29tcG9uZW50SW5mbyRqc2NvbXAkMy5rZXkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmFsdWVUb1Byb3BlcnRpZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJrZXlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRJbmZvJGpzY29tcCQzLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPSBjb21wb25lbnRJbmZvJGpzY29tcCQzLnByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9iamVjdFRvUHJvcGVydGllcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRJbmZvJGpzY29tcCQzLnByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z1Rhc2skanNjb21wJDAucnVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlLmJpbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVhc3VyZU5hbWUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgPiBzdGFydFRpbWUkanNjb21wJDMgPyAwIDogc3RhcnRUaW1lJGpzY29tcCQzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBjaGlsZHJlbkVuZFRpbWUkanNjb21wJDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2s6IHRyYWNrTmFtZXNbdHJhY2tJZHgkanNjb21wJDJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrR3JvdXA6IFwiU2VydmVyIENvbXBvbmVudHMgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMobWVhc3VyZU5hbWUkanNjb21wJDApO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS50aW1lU3RhbXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1lYXN1cmVOYW1lJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAwID4gc3RhcnRUaW1lJGpzY29tcCQzID8gMCA6IHN0YXJ0VGltZSRqc2NvbXAkMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5FbmRUaW1lJGpzY29tcCQyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja05hbWVzW3RyYWNrSWR4JGpzY29tcCQyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTZXJ2ZXIgQ29tcG9uZW50cyBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRFbmRUaW1lID0gdGltZTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb21wb25lbnQgPSBjb21wb25lbnRJbmZvJGpzY29tcCQwO1xuICAgICAgICAgICAgICAgICAgaXNMYXN0Q29tcG9uZW50ID0gITE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZUluZm8uYXdhaXRlZCAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPSBjYW5kaWRhdGVJbmZvLmF3YWl0ZWQuZW52XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBlbmRUaW1lID4gY2hpbGRyZW5FbmRUaW1lICYmIChjaGlsZHJlbkVuZFRpbWUgPSBlbmRUaW1lKTtcbiAgICAgICAgICAgICAgICAgIHZhciBhc3luY0luZm8gPSBjYW5kaWRhdGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICBlbnYkanNjb21wJDEgPSByZXNwb25zZSRqc2NvbXAkMC5fcm9vdEVudmlyb25tZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IGFzeW5jSW5mby5hd2FpdGVkLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZW5hYmxlID0gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dDb21wb25lbnRBd2FpdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmNJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja0lkeCRqc2NvbXAkNixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kVGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW52JGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuYWJsZS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFzeW5jSW5mbyRqc2NvbXAkMCA9IGFzeW5jSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tJZHgkanNjb21wJDMgPSB0cmFja0lkeCRqc2NvbXAkNixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lJGpzY29tcCQ0ID0gdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kVGltZSRqc2NvbXAkMCA9IGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbnYgPSBlbnYkanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yJGpzY29tcCQwID0gdGhlbmFibGUucmVhc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZyAmJiAwIDwgZW5kVGltZSRqc2NvbXAkMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRpb24gPSBnZXRJT0Rlc2NyaXB0aW9uKGVycm9yJGpzY29tcCQwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeU5hbWUkanNjb21wJDEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhd2FpdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRJT1Nob3J0TmFtZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmNJbmZvJGpzY29tcCQwLmF3YWl0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luY0luZm8kanNjb21wJDAuZW52LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290RW52XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnVGFzayRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luY0luZm8kanNjb21wJDAuZGVidWdUYXNrIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luY0luZm8kanNjb21wJDAuYXdhaXRlZC5kZWJ1Z1Rhc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWJ1Z1Rhc2skanNjb21wJDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydGllcyRqc2NvbXAkMSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVqZWN0ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZXJyb3IkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBlcnJvciRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvciRqc2NvbXAkMC5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFN0cmluZyhlcnJvciRqc2NvbXAkMC5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBTdHJpbmcoZXJyb3IkanNjb21wJDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwVGV4dCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldElPTG9uZ05hbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmNJbmZvJGpzY29tcCQwLmF3YWl0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmNJbmZvJGpzY29tcCQwLmVudixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290RW52XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgKyBcIiBSZWplY3RlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnVGFzayRqc2NvbXAkMS5ydW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlLmJpbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeU5hbWUkanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgPiBzdGFydFRpbWUkanNjb21wJDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc3RhcnRUaW1lJGpzY29tcCQ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZW5kVGltZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldnRvb2xzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrOiB0cmFja05hbWVzW3RyYWNrSWR4JGpzY29tcCQzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tHcm91cDogXCJTZXJ2ZXIgQ29tcG9uZW50cyBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMkanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBUZXh0OiB0b29sdGlwVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhlbnRyeU5hbWUkanNjb21wJDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLnRpbWVTdGFtcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5TmFtZSRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgPiBzdGFydFRpbWUkanNjb21wJDQgPyAwIDogc3RhcnRUaW1lJGpzY29tcCQ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kVGltZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrTmFtZXNbdHJhY2tJZHgkanNjb21wJDNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTZXJ2ZXIgQ29tcG9uZW50cyBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVycm9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0NvbXBvbmVudEF3YWl0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luY0luZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrSWR4JGpzY29tcCQ2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbnYkanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGxvZ0NvbXBvbmVudEF3YWl0KFxuICAgICAgICAgICAgICAgICAgICAgIGFzeW5jSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICB0cmFja0lkeCRqc2NvbXAkNixcbiAgICAgICAgICAgICAgICAgICAgICB0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgZW52JGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGVuZFRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaiA9IGRlYnVnSW5mby5sZW5ndGggLSAxOyBfaiA+IF9pNjsgX2otLSkge1xuICAgICAgICAgICAgICAgIHZhciBfY2FuZGlkYXRlSW5mbyA9IGRlYnVnSW5mb1tfal07XG4gICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBfY2FuZGlkYXRlSW5mby5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRFbmRUaW1lID4gY2hpbGRyZW5FbmRUaW1lICYmXG4gICAgICAgICAgICAgICAgICAgIChjaGlsZHJlbkVuZFRpbWUgPSBjb21wb25lbnRFbmRUaW1lKTtcbiAgICAgICAgICAgICAgICAgIHZhciBfY29tcG9uZW50SW5mbyA9IF9jYW5kaWRhdGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICBfZW52ID0gcmVzcG9uc2UkanNjb21wJDAuX3Jvb3RFbnZpcm9ubWVudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEluZm8kanNjb21wJDQgPSBfY29tcG9uZW50SW5mbyxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tJZHgkanNjb21wJDQgPSB0cmFja0lkeCRqc2NvbXAkNixcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lJGpzY29tcCQ1ID0gdGltZSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5FbmRUaW1lJGpzY29tcCQzID0gY2hpbGRyZW5FbmRUaW1lO1xuICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW52JGpzY29tcCQyID0gY29tcG9uZW50SW5mbyRqc2NvbXAkNC5lbnYsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZSRqc2NvbXAkMSA9IGNvbXBvbmVudEluZm8kanNjb21wJDQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBlbnRyeU5hbWUkanNjb21wJDIgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZW52JGpzY29tcCQyID09PSBfZW52IHx8IHZvaWQgMCA9PT0gZW52JGpzY29tcCQyXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gbmFtZSRqc2NvbXAkMVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5hbWUkanNjb21wJDEgKyBcIiBbXCIgKyBlbnYkanNjb21wJDIgKyBcIl1cIixcbiAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlTmFtZSRqc2NvbXAkMSA9IFwiXFx1MjAwYlwiICsgZW50cnlOYW1lJGpzY29tcCQyLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMkanNjb21wJDIgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiQWJvcnRlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRoZSBzdHJlYW0gd2FzIGFib3J0ZWQgYmVmb3JlIHRoaXMgQ29tcG9uZW50IGZpbmlzaGVkIHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT0gY29tcG9uZW50SW5mbyRqc2NvbXAkNC5rZXkgJiZcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWYWx1ZVRvUHJvcGVydGllcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFwia2V5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRJbmZvJGpzY29tcCQ0LmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMkanNjb21wJDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT0gY29tcG9uZW50SW5mbyRqc2NvbXAkNC5wcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIGFkZE9iamVjdFRvUHJvcGVydGllcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEluZm8kanNjb21wJDQucHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzJGpzY29tcCQyLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKG1lYXN1cmVOYW1lJGpzY29tcCQxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IDAgPiBzdGFydFRpbWUkanNjb21wJDUgPyAwIDogc3RhcnRUaW1lJGpzY29tcCQ1LFxuICAgICAgICAgICAgICAgICAgICAgIGVuZDogY2hpbGRyZW5FbmRUaW1lJGpzY29tcCQzLFxuICAgICAgICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwid2FybmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjazogdHJhY2tOYW1lc1t0cmFja0lkeCRqc2NvbXAkNF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrR3JvdXA6IFwiU2VydmVyIENvbXBvbmVudHMgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwVGV4dDogZW50cnlOYW1lJGpzY29tcCQyICsgXCIgQWJvcnRlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzJGpzY29tcCQyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhtZWFzdXJlTmFtZSRqc2NvbXAkMSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRFbmRUaW1lID0gdGltZTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb21wb25lbnQgPSBfY29tcG9uZW50SW5mbztcbiAgICAgICAgICAgICAgICAgIGlzTGFzdENvbXBvbmVudCA9ICExO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICBfY2FuZGlkYXRlSW5mby5hd2FpdGVkICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9IF9jYW5kaWRhdGVJbmZvLmF3YWl0ZWQuZW52XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2FzeW5jSW5mbyA9IF9jYW5kaWRhdGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICBfZW52MiA9IHJlc3BvbnNlJGpzY29tcCQwLl9yb290RW52aXJvbm1lbnROYW1lO1xuICAgICAgICAgICAgICAgICAgX2FzeW5jSW5mby5hd2FpdGVkLmVuZCA+IGVuZFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgKGVuZFRpbWUgPSBfYXN5bmNJbmZvLmF3YWl0ZWQuZW5kKTtcbiAgICAgICAgICAgICAgICAgIGVuZFRpbWUgPiBjaGlsZHJlbkVuZFRpbWUgJiYgKGNoaWxkcmVuRW5kVGltZSA9IGVuZFRpbWUpO1xuICAgICAgICAgICAgICAgICAgdmFyIGFzeW5jSW5mbyRqc2NvbXAkMSA9IF9hc3luY0luZm8sXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrSWR4JGpzY29tcCQ1ID0gdHJhY2tJZHgkanNjb21wJDYsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZSRqc2NvbXAkNiA9IHRpbWUsXG4gICAgICAgICAgICAgICAgICAgIGVuZFRpbWUkanNjb21wJDEgPSBlbmRUaW1lLFxuICAgICAgICAgICAgICAgICAgICByb290RW52JGpzY29tcCQwID0gX2VudjI7XG4gICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nICYmIDAgPCBlbmRUaW1lJGpzY29tcCQxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeU5hbWUkanNjb21wJDMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhd2FpdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRJT1Nob3J0TmFtZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmNJbmZvJGpzY29tcCQxLmF3YWl0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jSW5mbyRqc2NvbXAkMS5lbnYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbnYkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgZGVidWdUYXNrJGpzY29tcCQyID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jSW5mbyRqc2NvbXAkMS5kZWJ1Z1Rhc2sgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jSW5mbyRqc2NvbXAkMS5hd2FpdGVkLmRlYnVnVGFzaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlYnVnVGFzayRqc2NvbXAkMikge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB0b29sdGlwVGV4dCRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRJT0xvbmdOYW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luY0luZm8kanNjb21wJDEuYXdhaXRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmNJbmZvJGpzY29tcCQxLmVudixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEVudiRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICAgICAgKSArIFwiIEFib3J0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z1Rhc2skanNjb21wJDIucnVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZS5iaW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnlOYW1lJGpzY29tcCQzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwID4gc3RhcnRUaW1lJGpzY29tcCQ2ID8gMCA6IHN0YXJ0VGltZSRqc2NvbXAkNixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZFRpbWUkanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZ0b29sczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCJ3YXJuaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrOiB0cmFja05hbWVzW3RyYWNrSWR4JGpzY29tcCQ1XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tHcm91cDogXCJTZXJ2ZXIgQ29tcG9uZW50cyBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkFib3J0ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGhlIHN0cmVhbSB3YXMgYWJvcnRlZCBiZWZvcmUgdGhpcyBQcm9taXNlIHJlc29sdmVkLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwVGV4dDogdG9vbHRpcFRleHQkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMoZW50cnlOYW1lJGpzY29tcCQzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS50aW1lU3RhbXAoXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeU5hbWUkanNjb21wJDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAwID4gc3RhcnRUaW1lJGpzY29tcCQ2ID8gMCA6IHN0YXJ0VGltZSRqc2NvbXAkNixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFRpbWUkanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja05hbWVzW3RyYWNrSWR4JGpzY29tcCQ1XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiU2VydmVyIENvbXBvbmVudHMgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3YXJuaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kVGltZSA9IHRpbWU7XG4gICAgICAgICAgICBlbmRUaW1lSWR4ID0gX2k2O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmVzdWx0LmVuZFRpbWUgPSBjaGlsZHJlbkVuZFRpbWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaEluaXRpYWxSZW5kZXJQZXJmb3JtYW5jZShyZXNwb25zZSkge1xuICAgICAgaWYgKHJlc3BvbnNlLl9yZXBsYXlDb25zb2xlKSB7XG4gICAgICAgIHZhciByb290Q2h1bmsgPSBnZXRDaHVuayhyZXNwb25zZSwgMCk7XG4gICAgICAgIGlzQXJyYXlJbXBsKHJvb3RDaHVuay5fY2hpbGRyZW4pICYmXG4gICAgICAgICAgKG1hcmtBbGxUcmFja3NJbk9yZGVyKCksXG4gICAgICAgICAgZmx1c2hDb21wb25lbnRQZXJmb3JtYW5jZShcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgcm9vdENodW5rLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIC1JbmZpbml0eSxcbiAgICAgICAgICAgIC1JbmZpbml0eVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzRnVsbEJpbmFyeVJvdyhcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgc3RyZWFtU3RhdGUsXG4gICAgICBpZCxcbiAgICAgIHRhZyxcbiAgICAgIGJ1ZmZlcixcbiAgICAgIGNodW5rXG4gICAgKSB7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDY1OlxuICAgICAgICAgIHJlc29sdmVCdWZmZXIoXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbWVyZ2VCdWZmZXIoYnVmZmVyLCBjaHVuaykuYnVmZmVyLFxuICAgICAgICAgICAgc3RyZWFtU3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSA3OTpcbiAgICAgICAgICByZXNvbHZlVHlwZWRBcnJheShcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgIEludDhBcnJheSxcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBzdHJlYW1TdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIDExMTpcbiAgICAgICAgICByZXNvbHZlQnVmZmVyKFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIDAgPT09IGJ1ZmZlci5sZW5ndGggPyBjaHVuayA6IG1lcmdlQnVmZmVyKGJ1ZmZlciwgY2h1bmspLFxuICAgICAgICAgICAgc3RyZWFtU3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSA4NTpcbiAgICAgICAgICByZXNvbHZlVHlwZWRBcnJheShcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgIFVpbnQ4Q2xhbXBlZEFycmF5LFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIHN0cmVhbVN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgODM6XG4gICAgICAgICAgcmVzb2x2ZVR5cGVkQXJyYXkoXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICBJbnQxNkFycmF5LFxuICAgICAgICAgICAgMixcbiAgICAgICAgICAgIHN0cmVhbVN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgIHJlc29sdmVUeXBlZEFycmF5KFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgVWludDE2QXJyYXksXG4gICAgICAgICAgICAyLFxuICAgICAgICAgICAgc3RyZWFtU3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSA3NjpcbiAgICAgICAgICByZXNvbHZlVHlwZWRBcnJheShcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgIEludDMyQXJyYXksXG4gICAgICAgICAgICA0LFxuICAgICAgICAgICAgc3RyZWFtU3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAxMDg6XG4gICAgICAgICAgcmVzb2x2ZVR5cGVkQXJyYXkoXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICBVaW50MzJBcnJheSxcbiAgICAgICAgICAgIDQsXG4gICAgICAgICAgICBzdHJlYW1TdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIDcxOlxuICAgICAgICAgIHJlc29sdmVUeXBlZEFycmF5KFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgRmxvYXQzMkFycmF5LFxuICAgICAgICAgICAgNCxcbiAgICAgICAgICAgIHN0cmVhbVN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgMTAzOlxuICAgICAgICAgIHJlc29sdmVUeXBlZEFycmF5KFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgRmxvYXQ2NEFycmF5LFxuICAgICAgICAgICAgOCxcbiAgICAgICAgICAgIHN0cmVhbVN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgNzc6XG4gICAgICAgICAgcmVzb2x2ZVR5cGVkQXJyYXkoXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICBCaWdJbnQ2NEFycmF5LFxuICAgICAgICAgICAgOCxcbiAgICAgICAgICAgIHN0cmVhbVN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgMTA5OlxuICAgICAgICAgIHJlc29sdmVUeXBlZEFycmF5KFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgQmlnVWludDY0QXJyYXksXG4gICAgICAgICAgICA4LFxuICAgICAgICAgICAgc3RyZWFtU3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSA4NjpcbiAgICAgICAgICByZXNvbHZlVHlwZWRBcnJheShcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgIERhdGFWaWV3LFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIHN0cmVhbVN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgc3RyaW5nRGVjb2RlciA9IHJlc3BvbnNlLl9zdHJpbmdEZWNvZGVyLCByb3cgPSBcIlwiLCBpID0gMDtcbiAgICAgICAgaSA8IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIGkrK1xuICAgICAgKVxuICAgICAgICByb3cgKz0gc3RyaW5nRGVjb2Rlci5kZWNvZGUoYnVmZmVyW2ldLCBkZWNvZGVyT3B0aW9ucyk7XG4gICAgICByb3cgKz0gc3RyaW5nRGVjb2Rlci5kZWNvZGUoY2h1bmspO1xuICAgICAgcHJvY2Vzc0Z1bGxTdHJpbmdSb3cocmVzcG9uc2UsIHN0cmVhbVN0YXRlLCBpZCwgdGFnLCByb3cpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzRnVsbFN0cmluZ1JvdyhyZXNwb25zZSwgc3RyZWFtU3RhdGUsIGlkLCB0YWcsIHJvdykge1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSA3MzpcbiAgICAgICAgICByZXNvbHZlTW9kdWxlKHJlc3BvbnNlLCBpZCwgcm93LCBzdHJlYW1TdGF0ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNzI6XG4gICAgICAgICAgaWQgPSByb3dbMF07XG4gICAgICAgICAgc3RyZWFtU3RhdGUgPSByb3cuc2xpY2UoMSk7XG4gICAgICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHN0cmVhbVN0YXRlLCByZXNwb25zZS5fZnJvbUpTT04pO1xuICAgICAgICAgIHN0cmVhbVN0YXRlID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuZDtcbiAgICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgICAgICBzdHJlYW1TdGF0ZS5EKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQ1wiOlxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICA/IHN0cmVhbVN0YXRlLkMocmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgOiBzdHJlYW1TdGF0ZS5DKHJlc3BvbnNlWzBdLCByZXNwb25zZVsxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgICAgaWQgPSByZXNwb25zZVswXTtcbiAgICAgICAgICAgICAgcm93ID0gcmVzcG9uc2VbMV07XG4gICAgICAgICAgICAgIDMgPT09IHJlc3BvbnNlLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gc3RyZWFtU3RhdGUuTChpZCwgcm93LCByZXNwb25zZVsyXSlcbiAgICAgICAgICAgICAgICA6IHN0cmVhbVN0YXRlLkwoaWQsIHJvdyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgPyBzdHJlYW1TdGF0ZS5tKHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgIDogc3RyZWFtU3RhdGUubShyZXNwb25zZVswXSwgcmVzcG9uc2VbMV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJYXCI6XG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiByZXNwb25zZVxuICAgICAgICAgICAgICAgID8gc3RyZWFtU3RhdGUuWChyZXNwb25zZSlcbiAgICAgICAgICAgICAgICA6IHN0cmVhbVN0YXRlLlgocmVzcG9uc2VbMF0sIHJlc3BvbnNlWzFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICA/IHN0cmVhbVN0YXRlLlMocmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgOiBzdHJlYW1TdGF0ZS5TKFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVswXSxcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gcmVzcG9uc2VbMV0gPyB2b2lkIDAgOiByZXNwb25zZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgMyA9PT0gcmVzcG9uc2UubGVuZ3RoID8gcmVzcG9uc2VbMl0gOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgPyBzdHJlYW1TdGF0ZS5NKHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgIDogc3RyZWFtU3RhdGUuTShyZXNwb25zZVswXSwgcmVzcG9uc2VbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OTpcbiAgICAgICAgICB0YWcgPSByZXNwb25zZS5fY2h1bmtzO1xuICAgICAgICAgIHZhciBjaHVuayA9IHRhZy5nZXQoaWQpO1xuICAgICAgICAgIHJvdyA9IEpTT04ucGFyc2Uocm93KTtcbiAgICAgICAgICB2YXIgZXJyb3IgPSByZXNvbHZlRXJyb3JEZXYocmVzcG9uc2UsIHJvdyk7XG4gICAgICAgICAgZXJyb3IuZGlnZXN0ID0gcm93LmRpZ2VzdDtcbiAgICAgICAgICBjaHVua1xuICAgICAgICAgICAgPyAocmVzb2x2ZUNodW5rRGVidWdJbmZvKHJlc3BvbnNlLCBzdHJlYW1TdGF0ZSwgY2h1bmspLFxuICAgICAgICAgICAgICB0cmlnZ2VyRXJyb3JPbkNodW5rKHJlc3BvbnNlLCBjaHVuaywgZXJyb3IpKVxuICAgICAgICAgICAgOiAoKHJvdyA9IG5ldyBSZWFjdFByb21pc2UoXCJyZWplY3RlZFwiLCBudWxsLCBlcnJvcikpLFxuICAgICAgICAgICAgICByZXNvbHZlQ2h1bmtEZWJ1Z0luZm8ocmVzcG9uc2UsIHN0cmVhbVN0YXRlLCByb3cpLFxuICAgICAgICAgICAgICB0YWcuc2V0KGlkLCByb3cpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA4NDpcbiAgICAgICAgICB0YWcgPSByZXNwb25zZS5fY2h1bmtzO1xuICAgICAgICAgIChjaHVuayA9IHRhZy5nZXQoaWQpKSAmJiBcInBlbmRpbmdcIiAhPT0gY2h1bmsuc3RhdHVzXG4gICAgICAgICAgICA/IGNodW5rLnJlYXNvbi5lbnF1ZXVlVmFsdWUocm93KVxuICAgICAgICAgICAgOiAoY2h1bmsgJiYgcmVsZWFzZVBlbmRpbmdDaHVuayhyZXNwb25zZSwgY2h1bmspLFxuICAgICAgICAgICAgICAocm93ID0gbmV3IFJlYWN0UHJvbWlzZShcImZ1bGZpbGxlZFwiLCByb3csIG51bGwpKSxcbiAgICAgICAgICAgICAgcmVzb2x2ZUNodW5rRGVidWdJbmZvKHJlc3BvbnNlLCBzdHJlYW1TdGF0ZSwgcm93KSxcbiAgICAgICAgICAgICAgdGFnLnNldChpZCwgcm93KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNzg6XG4gICAgICAgICAgcmVzcG9uc2UuX3RpbWVPcmlnaW4gPSArcm93IC0gcGVyZm9ybWFuY2UudGltZU9yaWdpbjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2ODpcbiAgICAgICAgICBpZCA9IGdldENodW5rKHJlc3BvbnNlLCBpZCk7XG4gICAgICAgICAgXCJmdWxmaWxsZWRcIiAhPT0gaWQuc3RhdHVzICYmXG4gICAgICAgICAgICBcInJlamVjdGVkXCIgIT09IGlkLnN0YXR1cyAmJlxuICAgICAgICAgICAgXCJoYWx0ZWRcIiAhPT0gaWQuc3RhdHVzICYmXG4gICAgICAgICAgICBcImJsb2NrZWRcIiAhPT0gaWQuc3RhdHVzICYmXG4gICAgICAgICAgICBcInJlc29sdmVkX21vZHVsZVwiICE9PSBpZC5zdGF0dXMgJiZcbiAgICAgICAgICAgICgoc3RyZWFtU3RhdGUgPSBpZC5fZGVidWdDaHVuayksXG4gICAgICAgICAgICAodGFnID0gY3JlYXRlUmVzb2x2ZWRNb2RlbENodW5rKHJlc3BvbnNlLCByb3cpKSxcbiAgICAgICAgICAgICh0YWcuX2RlYnVnQ2h1bmsgPSBzdHJlYW1TdGF0ZSksXG4gICAgICAgICAgICAoaWQuX2RlYnVnQ2h1bmsgPSB0YWcpLFxuICAgICAgICAgICAgaW5pdGlhbGl6ZURlYnVnQ2h1bmsocmVzcG9uc2UsIGlkKSxcbiAgICAgICAgICAgIFwiYmxvY2tlZFwiICE9PSB0YWcuc3RhdHVzIHx8XG4gICAgICAgICAgICAgICh2b2lkIDAgIT09IHJlc3BvbnNlLl9kZWJ1Z0NoYW5uZWwgJiZcbiAgICAgICAgICAgICAgICByZXNwb25zZS5fZGVidWdDaGFubmVsLmhhc1JlYWRhYmxlKSB8fFxuICAgICAgICAgICAgICAnXCInICE9PSByb3dbMF0gfHxcbiAgICAgICAgICAgICAgXCIkXCIgIT09IHJvd1sxXSB8fFxuICAgICAgICAgICAgICAoKHN0cmVhbVN0YXRlID0gcm93LnNsaWNlKDIsIHJvdy5sZW5ndGggLSAxKS5zcGxpdChcIjpcIikpLFxuICAgICAgICAgICAgICAoc3RyZWFtU3RhdGUgPSBwYXJzZUludChzdHJlYW1TdGF0ZVswXSwgMTYpKSxcbiAgICAgICAgICAgICAgXCJwZW5kaW5nXCIgPT09IGdldENodW5rKHJlc3BvbnNlLCBzdHJlYW1TdGF0ZSkuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgKGlkLl9kZWJ1Z0NodW5rID0gbnVsbCkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA3NDpcbiAgICAgICAgICByZXNvbHZlSU9JbmZvKHJlc3BvbnNlLCBpZCwgcm93KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA4NzpcbiAgICAgICAgICByZXNvbHZlQ29uc29sZUVudHJ5KHJlc3BvbnNlLCByb3cpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDgyOlxuICAgICAgICAgIHN0YXJ0UmVhZGFibGVTdHJlYW0ocmVzcG9uc2UsIGlkLCB2b2lkIDAsIHN0cmVhbVN0YXRlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTQ6XG4gICAgICAgICAgc3RhcnRSZWFkYWJsZVN0cmVhbShyZXNwb25zZSwgaWQsIFwiYnl0ZXNcIiwgc3RyZWFtU3RhdGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDg4OlxuICAgICAgICAgIHN0YXJ0QXN5bmNJdGVyYWJsZShyZXNwb25zZSwgaWQsICExLCBzdHJlYW1TdGF0ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTIwOlxuICAgICAgICAgIHN0YXJ0QXN5bmNJdGVyYWJsZShyZXNwb25zZSwgaWQsICEwLCBzdHJlYW1TdGF0ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjc6XG4gICAgICAgICAgKGlkID0gcmVzcG9uc2UuX2NodW5rcy5nZXQoaWQpKSAmJlxuICAgICAgICAgICAgXCJmdWxmaWxsZWRcIiA9PT0gaWQuc3RhdHVzICYmXG4gICAgICAgICAgICAoMCA9PT0gLS1yZXNwb25zZS5fcGVuZGluZ0NodW5rcyAmJlxuICAgICAgICAgICAgICAocmVzcG9uc2UuX3dlYWtSZXNwb25zZS5yZXNwb25zZSA9IG51bGwpLFxuICAgICAgICAgICAgaWQucmVhc29uLmNsb3NlKFwiXCIgPT09IHJvdyA/ICdcIiR1bmRlZmluZWRcIicgOiByb3cpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoXCJcIiA9PT0gcm93KSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgoc3RyZWFtU3RhdGUgPSByZXNwb25zZS5fY2h1bmtzKSxcbiAgICAgICAgICAgICAgKHJvdyA9IHN0cmVhbVN0YXRlLmdldChpZCkpIHx8XG4gICAgICAgICAgICAgICAgc3RyZWFtU3RhdGUuc2V0KGlkLCAocm93ID0gY3JlYXRlUGVuZGluZ0NodW5rKHJlc3BvbnNlKSkpLFxuICAgICAgICAgICAgICBcInBlbmRpbmdcIiA9PT0gcm93LnN0YXR1cyB8fCBcImJsb2NrZWRcIiA9PT0gcm93LnN0YXR1cylcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmVsZWFzZVBlbmRpbmdDaHVuayhyZXNwb25zZSwgcm93KSxcbiAgICAgICAgICAgICAgICAocmVzcG9uc2UgPSByb3cpLFxuICAgICAgICAgICAgICAgIChyZXNwb25zZS5zdGF0dXMgPSBcImhhbHRlZFwiKSxcbiAgICAgICAgICAgICAgICAocmVzcG9uc2UudmFsdWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAocmVzcG9uc2UucmVhc29uID0gbnVsbCk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAodGFnID0gcmVzcG9uc2UuX2NodW5rcyksXG4gICAgICAgICAgICAgIChjaHVuayA9IHRhZy5nZXQoaWQpKVxuICAgICAgICAgICAgICAgID8gKHJlc29sdmVDaHVua0RlYnVnSW5mbyhyZXNwb25zZSwgc3RyZWFtU3RhdGUsIGNodW5rKSxcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVNb2RlbENodW5rKHJlc3BvbnNlLCBjaHVuaywgcm93KSlcbiAgICAgICAgICAgICAgICA6ICgocm93ID0gY3JlYXRlUmVzb2x2ZWRNb2RlbENodW5rKHJlc3BvbnNlLCByb3cpKSxcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVDaHVua0RlYnVnSW5mbyhyZXNwb25zZSwgc3RyZWFtU3RhdGUsIHJvdyksXG4gICAgICAgICAgICAgICAgICB0YWcuc2V0KGlkLCByb3cpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc0JpbmFyeUNodW5rKHdlYWtSZXNwb25zZSwgc3RyZWFtU3RhdGUsIGNodW5rKSB7XG4gICAgICBpZiAodm9pZCAwICE9PSB3ZWFrUmVzcG9uc2Uud2Vhay5kZXJlZigpKSB7XG4gICAgICAgIHdlYWtSZXNwb25zZSA9IHVud3JhcFdlYWtSZXNwb25zZSh3ZWFrUmVzcG9uc2UpO1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgcm93U3RhdGUgPSBzdHJlYW1TdGF0ZS5fcm93U3RhdGUsXG4gICAgICAgICAgcm93SUQgPSBzdHJlYW1TdGF0ZS5fcm93SUQsXG4gICAgICAgICAgcm93VGFnID0gc3RyZWFtU3RhdGUuX3Jvd1RhZyxcbiAgICAgICAgICByb3dMZW5ndGggPSBzdHJlYW1TdGF0ZS5fcm93TGVuZ3RoLFxuICAgICAgICAgIGJ1ZmZlciA9IHN0cmVhbVN0YXRlLl9idWZmZXIsXG4gICAgICAgICAgY2h1bmtMZW5ndGggPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgaW5jcmVtZW50Q2h1bmtEZWJ1Z0luZm8oc3RyZWFtU3RhdGUsIGNodW5rTGVuZ3RoKTtcbiAgICAgICAgICBpIDwgY2h1bmtMZW5ndGg7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGxhc3RJZHggPSAtMTtcbiAgICAgICAgICBzd2l0Y2ggKHJvd1N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGxhc3RJZHggPSBjaHVua1tpKytdO1xuICAgICAgICAgICAgICA1OCA9PT0gbGFzdElkeFxuICAgICAgICAgICAgICAgID8gKHJvd1N0YXRlID0gMSlcbiAgICAgICAgICAgICAgICA6IChyb3dJRCA9XG4gICAgICAgICAgICAgICAgICAgIChyb3dJRCA8PCA0KSB8XG4gICAgICAgICAgICAgICAgICAgICg5NiA8IGxhc3RJZHggPyBsYXN0SWR4IC0gODcgOiBsYXN0SWR4IC0gNDgpKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHJvd1N0YXRlID0gY2h1bmtbaV07XG4gICAgICAgICAgICAgIDg0ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICA2NSA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgNzkgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgIDExMSA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgOTggPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgIDg1ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICA4MyA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgMTE1ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICA3NiA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgMTA4ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICA3MSA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgMTAzID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICA3NyA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgMTA5ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICA4NiA9PT0gcm93U3RhdGVcbiAgICAgICAgICAgICAgICA/ICgocm93VGFnID0gcm93U3RhdGUpLCAocm93U3RhdGUgPSAyKSwgaSsrKVxuICAgICAgICAgICAgICAgIDogKDY0IDwgcm93U3RhdGUgJiYgOTEgPiByb3dTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgMzUgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIDExNCA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgMTIwID09PSByb3dTdGF0ZVxuICAgICAgICAgICAgICAgICAgPyAoKHJvd1RhZyA9IHJvd1N0YXRlKSwgKHJvd1N0YXRlID0gMyksIGkrKylcbiAgICAgICAgICAgICAgICAgIDogKChyb3dUYWcgPSAwKSwgKHJvd1N0YXRlID0gMykpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgbGFzdElkeCA9IGNodW5rW2krK107XG4gICAgICAgICAgICAgIDQ0ID09PSBsYXN0SWR4XG4gICAgICAgICAgICAgICAgPyAocm93U3RhdGUgPSA0KVxuICAgICAgICAgICAgICAgIDogKHJvd0xlbmd0aCA9XG4gICAgICAgICAgICAgICAgICAgIChyb3dMZW5ndGggPDwgNCkgfFxuICAgICAgICAgICAgICAgICAgICAoOTYgPCBsYXN0SWR4ID8gbGFzdElkeCAtIDg3IDogbGFzdElkeCAtIDQ4KSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBsYXN0SWR4ID0gY2h1bmsuaW5kZXhPZigxMCwgaSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAobGFzdElkeCA9IGkgKyByb3dMZW5ndGgpLFxuICAgICAgICAgICAgICAgIGxhc3RJZHggPiBjaHVuay5sZW5ndGggJiYgKGxhc3RJZHggPSAtMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvZmZzZXQgPSBjaHVuay5ieXRlT2Zmc2V0ICsgaTtcbiAgICAgICAgICBpZiAoLTEgPCBsYXN0SWR4KVxuICAgICAgICAgICAgKHJvd0xlbmd0aCA9IG5ldyBVaW50OEFycmF5KGNodW5rLmJ1ZmZlciwgb2Zmc2V0LCBsYXN0SWR4IC0gaSkpLFxuICAgICAgICAgICAgICA5OCA9PT0gcm93VGFnXG4gICAgICAgICAgICAgICAgPyByZXNvbHZlQnVmZmVyKFxuICAgICAgICAgICAgICAgICAgICB3ZWFrUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHJvd0lELFxuICAgICAgICAgICAgICAgICAgICBsYXN0SWR4ID09PSBjaHVua0xlbmd0aCA/IHJvd0xlbmd0aCA6IHJvd0xlbmd0aC5zbGljZSgpLFxuICAgICAgICAgICAgICAgICAgICBzdHJlYW1TdGF0ZVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogcHJvY2Vzc0Z1bGxCaW5hcnlSb3coXG4gICAgICAgICAgICAgICAgICAgIHdlYWtSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHJvd0lELFxuICAgICAgICAgICAgICAgICAgICByb3dUYWcsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgcm93TGVuZ3RoXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoaSA9IGxhc3RJZHgpLFxuICAgICAgICAgICAgICAzID09PSByb3dTdGF0ZSAmJiBpKyssXG4gICAgICAgICAgICAgIChyb3dMZW5ndGggPSByb3dJRCA9IHJvd1RhZyA9IHJvd1N0YXRlID0gMCksXG4gICAgICAgICAgICAgIChidWZmZXIubGVuZ3RoID0gMCk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaHVuayA9IG5ldyBVaW50OEFycmF5KGNodW5rLmJ1ZmZlciwgb2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoIC0gaSk7XG4gICAgICAgICAgICA5OCA9PT0gcm93VGFnXG4gICAgICAgICAgICAgID8gKChyb3dMZW5ndGggLT0gY2h1bmsuYnl0ZUxlbmd0aCksXG4gICAgICAgICAgICAgICAgcmVzb2x2ZUJ1ZmZlcih3ZWFrUmVzcG9uc2UsIHJvd0lELCBjaHVuaywgc3RyZWFtU3RhdGUpKVxuICAgICAgICAgICAgICA6IChidWZmZXIucHVzaChjaHVuayksIChyb3dMZW5ndGggLT0gY2h1bmsuYnl0ZUxlbmd0aCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0cmVhbVN0YXRlLl9yb3dTdGF0ZSA9IHJvd1N0YXRlO1xuICAgICAgICBzdHJlYW1TdGF0ZS5fcm93SUQgPSByb3dJRDtcbiAgICAgICAgc3RyZWFtU3RhdGUuX3Jvd1RhZyA9IHJvd1RhZztcbiAgICAgICAgc3RyZWFtU3RhdGUuX3Jvd0xlbmd0aCA9IHJvd0xlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUpTT05DYWxsYmFjayhyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChcIl9fcHJvdG9fX1wiICE9PSBrZXkpIHtcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTW9kZWxTdHJpbmcocmVzcG9uc2UsIHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUgJiYgbnVsbCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZVswXSA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKVxuICAgICAgICAgICAgICBiOiB7XG4gICAgICAgICAgICAgICAgdmFyIG93bmVyID0gdmFsdWVbNF0sXG4gICAgICAgICAgICAgICAgICBzdGFjayA9IHZhbHVlWzVdO1xuICAgICAgICAgICAgICAgIGtleSA9IHZhbHVlWzZdO1xuICAgICAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IHZhbHVlWzFdLFxuICAgICAgICAgICAgICAgICAga2V5OiB2YWx1ZVsyXSxcbiAgICAgICAgICAgICAgICAgIHByb3BzOiB2YWx1ZVszXSxcbiAgICAgICAgICAgICAgICAgIF9vd25lcjogdm9pZCAwID09PSBvd25lciA/IG51bGwgOiBvd25lclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICAgIGdldDogbnVsbFJlZkdldHRlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhbHVlLl9zdG9yZSA9IHt9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgXCJfZGVidWdTdGFja1wiLCB7XG4gICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdm9pZCAwID09PSBzdGFjayA/IG51bGwgOiBzdGFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgXCJfZGVidWdUYXNrXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IGluaXRpYWxpemluZ0hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgIG93bmVyID0gaW5pdGlhbGl6aW5nSGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxpemluZ0hhbmRsZXIgPSBvd25lci5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICBpZiAob3duZXIuZXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjayA9IG5ldyBSZWFjdFByb21pc2UoXCJyZWplY3RlZFwiLCBudWxsLCBvd25lci5yZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplRWxlbWVudChyZXNwb25zZSwgdmFsdWUsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBvd25lciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodmFsdWUudHlwZSkgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICBvd25lcjogdmFsdWUuX293bmVyXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG93bmVyLmRlYnVnU3RhY2sgPSB2YWx1ZS5fZGVidWdTdGFjaztcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydHNDcmVhdGVUYXNrICYmIChvd25lci5kZWJ1Z1Rhc2sgPSB2YWx1ZS5fZGVidWdUYXNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2suX2RlYnVnSW5mbyA9IFtvd25lcl07XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGNyZWF0ZUxhenlDaHVua1dyYXBwZXIoc3RhY2ssIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoMCA8IG93bmVyLmRlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSBuZXcgUmVhY3RQcm9taXNlKFwiYmxvY2tlZFwiLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgb3duZXIudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgb3duZXIuY2h1bmsgPSBzdGFjaztcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gY3JlYXRlTGF6eUNodW5rV3JhcHBlcihzdGFjaywga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpbml0aWFsaXplRWxlbWVudC5iaW5kKG51bGwsIHJlc3BvbnNlLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sudGhlbih2YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbml0aWFsaXplRWxlbWVudChyZXNwb25zZSwgdmFsdWUsIG51bGwpO1xuICAgICAgICAgICAgICAgIGtleSA9IHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGtleSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZSh3ZWFrUmVzcG9uc2UpIHtcbiAgICAgIHJlcG9ydEdsb2JhbEVycm9yKHdlYWtSZXNwb25zZSwgRXJyb3IoXCJDb25uZWN0aW9uIGNsb3NlZC5cIikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVEZWJ1Z0NhbGxiYWNrRnJvbVdyaXRhYmxlU3RyZWFtKGRlYnVnV3JpdGFibGUpIHtcbiAgICAgIHZhciB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpLFxuICAgICAgICB3cml0ZXIgPSBkZWJ1Z1dyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIFwiXCIgPT09IG1lc3NhZ2VcbiAgICAgICAgICA/IHdyaXRlci5jbG9zZSgpXG4gICAgICAgICAgOiB3cml0ZXJcbiAgICAgICAgICAgICAgLndyaXRlKHRleHRFbmNvZGVyLmVuY29kZShtZXNzYWdlICsgXCJcXG5cIikpXG4gICAgICAgICAgICAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlRnJvbU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIGRlYnVnQ2hhbm5lbCA9XG4gICAgICAgIG9wdGlvbnMgJiYgdm9pZCAwICE9PSBvcHRpb25zLmRlYnVnQ2hhbm5lbFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBoYXNSZWFkYWJsZTogdm9pZCAwICE9PSBvcHRpb25zLmRlYnVnQ2hhbm5lbC5yZWFkYWJsZSxcbiAgICAgICAgICAgICAgY2FsbGJhY2s6XG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBvcHRpb25zLmRlYnVnQ2hhbm5lbC53cml0YWJsZVxuICAgICAgICAgICAgICAgICAgPyBjcmVhdGVEZWJ1Z0NhbGxiYWNrRnJvbVdyaXRhYmxlU3RyZWFtKFxuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVidWdDaGFubmVsLndyaXRhYmxlXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZUluc3RhbmNlKFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuY2FsbFNlcnZlciA/IG9wdGlvbnMuY2FsbFNlcnZlciA6IHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy50ZW1wb3JhcnlSZWZlcmVuY2VzXG4gICAgICAgICAgPyBvcHRpb25zLnRlbXBvcmFyeVJlZmVyZW5jZXNcbiAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmZpbmRTb3VyY2VNYXBVUkwgPyBvcHRpb25zLmZpbmRTb3VyY2VNYXBVUkwgOiB2b2lkIDAsXG4gICAgICAgIG9wdGlvbnMgPyAhMSAhPT0gb3B0aW9ucy5yZXBsYXlDb25zb2xlTG9ncyA6ICEwLFxuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuZW52aXJvbm1lbnROYW1lID8gb3B0aW9ucy5lbnZpcm9ubWVudE5hbWUgOiB2b2lkIDAsXG4gICAgICAgIG9wdGlvbnMgJiYgbnVsbCAhPSBvcHRpb25zLnN0YXJ0VGltZSA/IG9wdGlvbnMuc3RhcnRUaW1lIDogdm9pZCAwLFxuICAgICAgICBvcHRpb25zICYmIG51bGwgIT0gb3B0aW9ucy5lbmRUaW1lID8gb3B0aW9ucy5lbmRUaW1lIDogdm9pZCAwLFxuICAgICAgICBkZWJ1Z0NoYW5uZWxcbiAgICAgICkuX3dlYWtSZXNwb25zZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRSZWFkaW5nRnJvbVVuaXZlcnNhbFN0cmVhbShcbiAgICAgIHJlc3BvbnNlJGpzY29tcCQwLFxuICAgICAgc3RyZWFtLFxuICAgICAgb25Eb25lXG4gICAgKSB7XG4gICAgICBmdW5jdGlvbiBwcm9ncmVzcyhfcmVmKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gICAgICAgIGlmIChfcmVmLmRvbmUpIHJldHVybiBvbkRvbmUoKTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgICAgcHJvY2Vzc0JpbmFyeUNodW5rKFxuICAgICAgICAgICAgcmVzcG9uc2UkanNjb21wJDAsXG4gICAgICAgICAgICBzdHJlYW1TdGF0ZSxcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHZhbHVlKVxuICAgICAgICAgICk7XG4gICAgICAgIGVsc2UgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICgoX3JlZiA9IHN0cmVhbVN0YXRlKSwgdm9pZCAwICE9PSByZXNwb25zZSRqc2NvbXAkMC53ZWFrLmRlcmVmKCkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB1bndyYXBXZWFrUmVzcG9uc2UocmVzcG9uc2UkanNjb21wJDApLFxuICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgcm93U3RhdGUgPSBfcmVmLl9yb3dTdGF0ZSxcbiAgICAgICAgICAgICAgcm93SUQgPSBfcmVmLl9yb3dJRCxcbiAgICAgICAgICAgICAgcm93VGFnID0gX3JlZi5fcm93VGFnLFxuICAgICAgICAgICAgICByb3dMZW5ndGggPSBfcmVmLl9yb3dMZW5ndGgsXG4gICAgICAgICAgICAgIGJ1ZmZlciA9IF9yZWYuX2J1ZmZlcixcbiAgICAgICAgICAgICAgY2h1bmtMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpbmNyZW1lbnRDaHVua0RlYnVnSW5mbyhfcmVmLCBjaHVua0xlbmd0aCk7XG4gICAgICAgICAgICAgIGkgPCBjaHVua0xlbmd0aDtcblxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBsYXN0SWR4ID0gLTE7XG4gICAgICAgICAgICAgIHN3aXRjaCAocm93U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBsYXN0SWR4ID0gdmFsdWUuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgICAgNTggPT09IGxhc3RJZHhcbiAgICAgICAgICAgICAgICAgICAgPyAocm93U3RhdGUgPSAxKVxuICAgICAgICAgICAgICAgICAgICA6IChyb3dJRCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAocm93SUQgPDwgNCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKDk2IDwgbGFzdElkeCA/IGxhc3RJZHggLSA4NyA6IGxhc3RJZHggLSA0OCkpO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgcm93U3RhdGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgICAgODQgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICA2NSA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgIDc5ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgMTExID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgODUgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICA4MyA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgIDExNSA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgIDc2ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgMTA4ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgNzEgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAxMDMgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICA3NyA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgIDEwOSA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgIDg2ID09PSByb3dTdGF0ZVxuICAgICAgICAgICAgICAgICAgICA/ICgocm93VGFnID0gcm93U3RhdGUpLCAocm93U3RhdGUgPSAyKSwgaSsrKVxuICAgICAgICAgICAgICAgICAgICA6ICg2NCA8IHJvd1N0YXRlICYmIDkxID4gcm93U3RhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAxMTQgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAxMjAgPT09IHJvd1N0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgPyAoKHJvd1RhZyA9IHJvd1N0YXRlKSwgKHJvd1N0YXRlID0gMyksIGkrKylcbiAgICAgICAgICAgICAgICAgICAgICA6ICgocm93VGFnID0gMCksIChyb3dTdGF0ZSA9IDMpKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgIGxhc3RJZHggPSB2YWx1ZS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICAgICAgICA0NCA9PT0gbGFzdElkeFxuICAgICAgICAgICAgICAgICAgICA/IChyb3dTdGF0ZSA9IDQpXG4gICAgICAgICAgICAgICAgICAgIDogKHJvd0xlbmd0aCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAocm93TGVuZ3RoIDw8IDQpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICg5NiA8IGxhc3RJZHggPyBsYXN0SWR4IC0gODcgOiBsYXN0SWR4IC0gNDgpKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgIGxhc3RJZHggPSB2YWx1ZS5pbmRleE9mKFwiXFxuXCIsIGkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgaWYgKDg0ICE9PSByb3dUYWcpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiQmluYXJ5IFJTQyBjaHVua3MgY2Fubm90IGJlIGVuY29kZWQgYXMgc3RyaW5ncy4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGUgd2lyaW5nIG9mIHRoZSBSZWFjdCBzdHJlYW1zLlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAocm93TGVuZ3RoIDwgdmFsdWUubGVuZ3RoIHx8IHZhbHVlLmxlbmd0aCA+IDMgKiByb3dMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiU3RyaW5nIGNodW5rcyBuZWVkIHRvIGJlIHBhc3NlZCBpbiB0aGVpciBvcmlnaW5hbCBzaGFwZS4gTm90IHNwbGl0IGludG8gc21hbGxlciBzdHJpbmcgY2h1bmtzLiBUaGlzIGlzIGEgYnVnIGluIHRoZSB3aXJpbmcgb2YgdGhlIFJlYWN0IHN0cmVhbXMuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGxhc3RJZHggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKC0xIDwgbGFzdElkeCkge1xuICAgICAgICAgICAgICAgIGlmICgwIDwgYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlN0cmluZyBjaHVua3MgbmVlZCB0byBiZSBwYXNzZWQgaW4gdGhlaXIgb3JpZ2luYWwgc2hhcGUuIE5vdCBzcGxpdCBpbnRvIHNtYWxsZXIgc3RyaW5nIGNodW5rcy4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGUgd2lyaW5nIG9mIHRoZSBSZWFjdCBzdHJlYW1zLlwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGkgPSB2YWx1ZS5zbGljZShpLCBsYXN0SWR4KTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzRnVsbFN0cmluZ1JvdyhyZXNwb25zZSwgX3JlZiwgcm93SUQsIHJvd1RhZywgaSk7XG4gICAgICAgICAgICAgICAgaSA9IGxhc3RJZHg7XG4gICAgICAgICAgICAgICAgMyA9PT0gcm93U3RhdGUgJiYgaSsrO1xuICAgICAgICAgICAgICAgIHJvd0xlbmd0aCA9IHJvd0lEID0gcm93VGFnID0gcm93U3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCAhPT0gaSlcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiU3RyaW5nIGNodW5rcyBuZWVkIHRvIGJlIHBhc3NlZCBpbiB0aGVpciBvcmlnaW5hbCBzaGFwZS4gTm90IHNwbGl0IGludG8gc21hbGxlciBzdHJpbmcgY2h1bmtzLiBUaGlzIGlzIGEgYnVnIGluIHRoZSB3aXJpbmcgb2YgdGhlIFJlYWN0IHN0cmVhbXMuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3JlZi5fcm93U3RhdGUgPSByb3dTdGF0ZTtcbiAgICAgICAgICAgIF9yZWYuX3Jvd0lEID0gcm93SUQ7XG4gICAgICAgICAgICBfcmVmLl9yb3dUYWcgPSByb3dUYWc7XG4gICAgICAgICAgICBfcmVmLl9yb3dMZW5ndGggPSByb3dMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJvY2Vzc0JpbmFyeUNodW5rKHJlc3BvbnNlJGpzY29tcCQwLCBzdHJlYW1TdGF0ZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQoKS50aGVuKHByb2dyZXNzKS5jYXRjaChlcnJvcik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBlcnJvcihlKSB7XG4gICAgICAgIHJlcG9ydEdsb2JhbEVycm9yKHJlc3BvbnNlJGpzY29tcCQwLCBlKTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHJlYW1TdGF0ZSA9IGNyZWF0ZVN0cmVhbVN0YXRlKHJlc3BvbnNlJGpzY29tcCQwLCBzdHJlYW0pLFxuICAgICAgICByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICByZWFkZXIucmVhZCgpLnRoZW4ocHJvZ3Jlc3MpLmNhdGNoKGVycm9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRSZWFkaW5nRnJvbVN0cmVhbShyZXNwb25zZSwgc3RyZWFtLCBvbkRvbmUsIGRlYnVnVmFsdWUpIHtcbiAgICAgIGZ1bmN0aW9uIHByb2dyZXNzKF9yZWYyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlO1xuICAgICAgICBpZiAoX3JlZjIuZG9uZSkgcmV0dXJuIG9uRG9uZSgpO1xuICAgICAgICBwcm9jZXNzQmluYXJ5Q2h1bmsocmVzcG9uc2UsIHN0cmVhbVN0YXRlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZCgpLnRoZW4ocHJvZ3Jlc3MpLmNhdGNoKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVycm9yKGUpIHtcbiAgICAgICAgcmVwb3J0R2xvYmFsRXJyb3IocmVzcG9uc2UsIGUpO1xuICAgICAgfVxuICAgICAgdmFyIHN0cmVhbVN0YXRlID0gY3JlYXRlU3RyZWFtU3RhdGUocmVzcG9uc2UsIGRlYnVnVmFsdWUpLFxuICAgICAgICByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICByZWFkZXIucmVhZCgpLnRoZW4ocHJvZ3Jlc3MpLmNhdGNoKGVycm9yKTtcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgUmVhY3RET00gPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpLFxuICAgICAgZGVjb2Rlck9wdGlvbnMgPSB7IHN0cmVhbTogITAgfSxcbiAgICAgIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGNodW5rQ2FjaGUgPSBuZXcgTWFwKCksXG4gICAgICBjaHVua01hcCA9IG5ldyBNYXAoKSxcbiAgICAgIHdlYnBhY2tHZXRDaHVua0ZpbGVuYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXy51O1xuICAgIF9fd2VicGFja19yZXF1aXJlX18udSA9IGZ1bmN0aW9uIChjaHVua0lkKSB7XG4gICAgICB2YXIgZmxpZ2h0Q2h1bmsgPSBjaHVua01hcC5nZXQoY2h1bmtJZCk7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBmbGlnaHRDaHVua1xuICAgICAgICA/IGZsaWdodENodW5rXG4gICAgICAgIDogd2VicGFja0dldENodW5rRmlsZW5hbWUoY2h1bmtJZCk7XG4gICAgfTtcbiAgICB2YXIgY2h1bmtJT0luZm9DYWNoZSA9IG5ldyBNYXAoKSxcbiAgICAgIFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3RET00uX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLFxuICAgICAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9BQ1RJVklUWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmFjdGl2aXR5XCIpLFxuICAgICAgUkVBQ1RfVklFV19UUkFOU0lUSU9OX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qudmlld190cmFuc2l0aW9uXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgQVNZTkNfSVRFUkFUT1IgPSBTeW1ib2wuYXN5bmNJdGVyYXRvcixcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgICAganN4UHJvcHNQYXJlbnRzID0gbmV3IFdlYWtNYXAoKSxcbiAgICAgIGpzeENoaWxkcmVuUGFyZW50cyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICBDTElFTlRfUkVGRVJFTkNFX1RBRyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgIGtub3duU2VydmVyUmVmZXJlbmNlcyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICBmYWtlU2VydmVyRnVuY3Rpb25JZHggPSAwLFxuICAgICAgdjhGcmFtZVJlZ0V4cCA9XG4gICAgICAgIC9eIHszfSBhdCAoPzooLispIFxcKCguKyk6KFxcZCspOihcXGQrKVxcKXwoPzphc3luYyApPyguKyk6KFxcZCspOihcXGQrKSkkLyxcbiAgICAgIGpzY1NwaWRlck1vbmtleUZyYW1lUmVnRXhwID0gLyg/OiguKilAKT8oLiopOihcXGQrKTooXFxkKykvLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgc3VwcG9ydHNVc2VyVGltaW5nID1cbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGNvbnNvbGUgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29uc29sZS50aW1lU3RhbXAgJiZcbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHBlcmZvcm1hbmNlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUsXG4gICAgICB0cmFja05hbWVzID1cbiAgICAgICAgXCJQcmltYXJ5IFBhcmFsbGVsIFBhcmFsbGVsXFx1MjAwYiBQYXJhbGxlbFxcdTIwMGJcXHUyMDBiIFBhcmFsbGVsXFx1MjAwYlxcdTIwMGJcXHUyMDBiIFBhcmFsbGVsXFx1MjAwYlxcdTIwMGJcXHUyMDBiXFx1MjAwYiBQYXJhbGxlbFxcdTIwMGJcXHUyMDBiXFx1MjAwYlxcdTIwMGJcXHUyMDBiIFBhcmFsbGVsXFx1MjAwYlxcdTIwMGJcXHUyMDBiXFx1MjAwYlxcdTIwMGJcXHUyMDBiIFBhcmFsbGVsXFx1MjAwYlxcdTIwMGJcXHUyMDBiXFx1MjAwYlxcdTIwMGJcXHUyMDBiXFx1MjAwYiBQYXJhbGxlbFxcdTIwMGJcXHUyMDBiXFx1MjAwYlxcdTIwMGJcXHUyMDBiXFx1MjAwYlxcdTIwMGJcXHUyMDBiXCIuc3BsaXQoXG4gICAgICAgICAgXCIgXCJcbiAgICAgICAgKSxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeDtcbiAgICBuZXcgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtNYXAgPyBXZWFrTWFwIDogTWFwKSgpO1xuICAgIHZhciBSZWFjdFNoYXJlZEludGVyYWxzU2VydmVyID1cbiAgICAgICAgUmVhY3QuX19TRVJWRVJfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUgfHxcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcmFsc1NlcnZlcjtcbiAgICBSZWFjdFByb21pc2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG4gICAgUmVhY3RQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcInJlc29sdmVkX21vZGVsXCI6XG4gICAgICAgICAgaW5pdGlhbGl6ZU1vZGVsQ2h1bmsodGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZXNvbHZlZF9tb2R1bGVcIjpcbiAgICAgICAgICBpbml0aWFsaXplTW9kdWxlQ2h1bmsodGhpcyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzb2x2ZUNhbGxiYWNrID0gcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0Q2FsbGJhY2sgPSByZWplY3QsXG4gICAgICAgIHdyYXBwZXJQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgICAgICAgcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgd3JhcHBlclByb21pc2UuX2RlYnVnSW5mbyA9IF90aGlzLl9kZWJ1Z0luZm87XG4gICAgICAgICAgICByZXModmFsdWUpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgd3JhcHBlclByb21pc2UuX2RlYnVnSW5mbyA9IF90aGlzLl9kZWJ1Z0luZm87XG4gICAgICAgICAgICByZWoocmVhc29uKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIHdyYXBwZXJQcm9taXNlLnRoZW4ocmVzb2x2ZUNhbGxiYWNrLCByZWplY3RDYWxsYmFjayk7XG4gICAgICBzd2l0Y2ggKHRoaXMuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXNvbHZlICYmIHJlc29sdmUodGhpcy52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgIGNhc2UgXCJibG9ja2VkXCI6XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVzb2x2ZSAmJlxuICAgICAgICAgICAgKG51bGwgPT09IHRoaXMudmFsdWUgJiYgKHRoaXMudmFsdWUgPSBbXSksXG4gICAgICAgICAgICB0aGlzLnZhbHVlLnB1c2gocmVzb2x2ZSkpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlamVjdCAmJlxuICAgICAgICAgICAgKG51bGwgPT09IHRoaXMucmVhc29uICYmICh0aGlzLnJlYXNvbiA9IFtdKSxcbiAgICAgICAgICAgIHRoaXMucmVhc29uLnB1c2gocmVqZWN0KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJoYWx0ZWRcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWplY3QgJiYgcmVqZWN0KHRoaXMucmVhc29uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBkZWJ1Z0NoYW5uZWxSZWdpc3RyeSA9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5XG4gICAgICAgICAgPyBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoY2xvc2VEZWJ1Z0NoYW5uZWwpXG4gICAgICAgICAgOiBudWxsLFxuICAgICAgaW5pdGlhbGl6aW5nSGFuZGxlciA9IG51bGwsXG4gICAgICBpbml0aWFsaXppbmdDaHVuayA9IG51bGwsXG4gICAgICBtaWdodEhhdmVTdGF0aWNDb25zdHJ1Y3RvciA9IC9cXGJjbGFzc1xcYi4qXFxic3RhdGljXFxiLyxcbiAgICAgIE1JTl9DSFVOS19TSVpFID0gNjU1MzYsXG4gICAgICBzdXBwb3J0c0NyZWF0ZVRhc2sgPSAhIWNvbnNvbGUuY3JlYXRlVGFzayxcbiAgICAgIGZha2VGdW5jdGlvbkNhY2hlID0gbmV3IE1hcCgpLFxuICAgICAgZmFrZUZ1bmN0aW9uSWR4ID0gMCxcbiAgICAgIGNyZWF0ZUZha2VKU1hDYWxsU3RhY2sgPSB7XG4gICAgICAgIHJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZTogZnVuY3Rpb24gKHJlc3BvbnNlLCBzdGFjaywgZW52aXJvbm1lbnROYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGJ1aWxkRmFrZUNhbGxTdGFjayhcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgc3RhY2ssXG4gICAgICAgICAgICBlbnZpcm9ubWVudE5hbWUsXG4gICAgICAgICAgICAhMSxcbiAgICAgICAgICAgIGZha2VKU1hDYWxsU2l0ZVxuICAgICAgICAgICkoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNyZWF0ZUZha2VKU1hDYWxsU3RhY2tJbkRFViA9XG4gICAgICAgIGNyZWF0ZUZha2VKU1hDYWxsU3RhY2sucmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lLmJpbmQoXG4gICAgICAgICAgY3JlYXRlRmFrZUpTWENhbGxTdGFja1xuICAgICAgICApLFxuICAgICAgY3VycmVudE93bmVySW5ERVYgPSBudWxsLFxuICAgICAgcmVwbGF5Q29uc29sZVdpdGhDYWxsU3RhY2sgPSB7XG4gICAgICAgIHJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZTogZnVuY3Rpb24gKHJlc3BvbnNlLCBwYXlsb2FkKSB7XG4gICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBwYXlsb2FkWzBdLFxuICAgICAgICAgICAgc3RhY2tUcmFjZSA9IHBheWxvYWRbMV0sXG4gICAgICAgICAgICBvd25lciA9IHBheWxvYWRbMl0sXG4gICAgICAgICAgICBlbnYgPSBwYXlsb2FkWzNdO1xuICAgICAgICAgIHBheWxvYWQgPSBwYXlsb2FkLnNsaWNlKDQpO1xuICAgICAgICAgIHZhciBwcmV2U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudFN0YWNrSW5ERVY7XG4gICAgICAgICAgY3VycmVudE93bmVySW5ERVYgPSBudWxsID09PSBvd25lciA/IHJlc3BvbnNlLl9kZWJ1Z1Jvb3RPd25lciA6IG93bmVyO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGlyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImRpcnhtbFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJncm91cEVuZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0YWJsZVwiOlxuICAgICAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGJpbmQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGVbbWV0aG9kTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgIFtjb25zb2xlXS5jb25jYXQocGF5bG9hZClcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhc3NlcnRcIjpcbiAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIG5ld0FyZ3MgPSBwYXlsb2FkLnNsaWNlKDApO1xuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3QXJnc1tvZmZzZXRdXG4gICAgICAgICAgICAgICAgPyBuZXdBcmdzLnNwbGljZShcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICBcIiVjJXMlYyBcIiArIG5ld0FyZ3Nbb2Zmc2V0XSxcbiAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kOiAjZTZlNmU2O2JhY2tncm91bmQ6IGxpZ2h0LWRhcmsocmdiYSgwLDAsMCwwLjEpLCByZ2JhKDI1NSwyNTUsMjU1LDAuMjUpKTtjb2xvcjogIzAwMDAwMDtjb2xvcjogbGlnaHQtZGFyaygjMDAwMDAwLCAjZmZmZmZmKTtib3JkZXItcmFkaXVzOiAycHhcIixcbiAgICAgICAgICAgICAgICAgICAgXCIgXCIgKyBlbnYgKyBcIiBcIixcbiAgICAgICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogbmV3QXJncy5zcGxpY2UoXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgXCIlYyVzJWNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kOiAjZTZlNmU2O2JhY2tncm91bmQ6IGxpZ2h0LWRhcmsocmdiYSgwLDAsMCwwLjEpLCByZ2JhKDI1NSwyNTUsMjU1LDAuMjUpKTtjb2xvcjogIzAwMDAwMDtjb2xvcjogbGlnaHQtZGFyaygjMDAwMDAwLCAjZmZmZmZmKTtib3JkZXItcmFkaXVzOiAycHhcIixcbiAgICAgICAgICAgICAgICAgICAgXCIgXCIgKyBlbnYgKyBcIiBcIixcbiAgICAgICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgbmV3QXJncy51bnNoaWZ0KGNvbnNvbGUpO1xuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBiaW5kLmFwcGx5KFxuICAgICAgICAgICAgICAgIGNvbnNvbGVbbWV0aG9kTmFtZV0sXG4gICAgICAgICAgICAgICAgbmV3QXJnc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNhbGxTdGFjayA9IGJ1aWxkRmFrZUNhbGxTdGFjayhcbiAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgIHN0YWNrVHJhY2UsXG4gICAgICAgICAgICAgIGVudixcbiAgICAgICAgICAgICAgITEsXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChudWxsICE9IG93bmVyKSB7XG4gICAgICAgICAgICAgIHZhciB0YXNrID0gaW5pdGlhbGl6ZUZha2VUYXNrKHJlc3BvbnNlLCBvd25lcik7XG4gICAgICAgICAgICAgIGluaXRpYWxpemVGYWtlU3RhY2socmVzcG9uc2UsIG93bmVyKTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHRhc2spIHtcbiAgICAgICAgICAgICAgICB0YXNrLnJ1bihjYWxsU3RhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJvb3RUYXNrID0gZ2V0Um9vdFRhc2socmVzcG9uc2UsIGVudik7XG4gICAgICAgICAgICBudWxsICE9IHJvb3RUYXNrID8gcm9vdFRhc2sucnVuKGNhbGxTdGFjaykgOiBjYWxsU3RhY2soKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgKGN1cnJlbnRPd25lckluREVWID0gbnVsbCksXG4gICAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBwcmV2U3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlcGxheUNvbnNvbGVXaXRoQ2FsbFN0YWNrSW5ERVYgPVxuICAgICAgICByZXBsYXlDb25zb2xlV2l0aENhbGxTdGFjay5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChcbiAgICAgICAgICByZXBsYXlDb25zb2xlV2l0aENhbGxTdGFja1xuICAgICAgICApO1xuICAgIChmdW5jdGlvbiAoaW50ZXJuYWxzKSB7XG4gICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXykgcmV0dXJuICExO1xuICAgICAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gICAgICBpZiAoaG9vay5pc0Rpc2FibGVkIHx8ICFob29rLnN1cHBvcnRzRmxpZ2h0KSByZXR1cm4gITA7XG4gICAgICB0cnkge1xuICAgICAgICBob29rLmluamVjdChpbnRlcm5hbHMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVvLlwiLCBlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhvb2suY2hlY2tEQ0UgPyAhMCA6ICExO1xuICAgIH0pKHtcbiAgICAgIGJ1bmRsZVR5cGU6IDEsXG4gICAgICB2ZXJzaW9uOiBcIjE5LjMuMC1jYW5hcnktY2JlYzUwZmQtMjAyNjAxMjJcIixcbiAgICAgIHJlbmRlcmVyUGFja2FnZU5hbWU6IFwicmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrXCIsXG4gICAgICBjdXJyZW50RGlzcGF0Y2hlclJlZjogUmVhY3RTaGFyZWRJbnRlcm5hbHMsXG4gICAgICByZWNvbmNpbGVyVmVyc2lvbjogXCIxOS4zLjAtY2FuYXJ5LWNiZWM1MGZkLTIwMjYwMTIyXCIsXG4gICAgICBnZXRDdXJyZW50Q29tcG9uZW50SW5mbzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3VycmVudE93bmVySW5ERVY7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZXhwb3J0cy5jcmVhdGVGcm9tRmV0Y2ggPSBmdW5jdGlvbiAocHJvbWlzZUZvclJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVzcG9uc2UgPSBjcmVhdGVSZXNwb25zZUZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgcHJvbWlzZUZvclJlc3BvbnNlLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgb3B0aW9ucyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5kZWJ1Z0NoYW5uZWwgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuZGVidWdDaGFubmVsLnJlYWRhYmxlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgc3RyZWFtRG9uZUNvdW50ID0gMCxcbiAgICAgICAgICAgICAgaGFuZGxlRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAyID09PSArK3N0cmVhbURvbmVDb3VudCAmJiBjbG9zZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdGFydFJlYWRpbmdGcm9tVW5pdmVyc2FsU3RyZWFtKFxuICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgb3B0aW9ucy5kZWJ1Z0NoYW5uZWwucmVhZGFibGUsXG4gICAgICAgICAgICAgIGhhbmRsZURvbmVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzdGFydFJlYWRpbmdGcm9tU3RyZWFtKHJlc3BvbnNlLCByLmJvZHksIGhhbmRsZURvbmUsIHIpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgc3RhcnRSZWFkaW5nRnJvbVN0cmVhbShcbiAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgIHIuYm9keSxcbiAgICAgICAgICAgICAgY2xvc2UuYmluZChudWxsLCByZXNwb25zZSksXG4gICAgICAgICAgICAgIHJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmVwb3J0R2xvYmFsRXJyb3IocmVzcG9uc2UsIGUpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIGdldFJvb3QocmVzcG9uc2UpO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVzcG9uc2UgPSBjcmVhdGVSZXNwb25zZUZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1Z0NoYW5uZWwgJiYgb3B0aW9ucy5kZWJ1Z0NoYW5uZWwucmVhZGFibGUpIHtcbiAgICAgICAgdmFyIHN0cmVhbURvbmVDb3VudCA9IDAsXG4gICAgICAgICAgaGFuZGxlRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIDIgPT09ICsrc3RyZWFtRG9uZUNvdW50ICYmIGNsb3NlKHJlc3BvbnNlKTtcbiAgICAgICAgICB9O1xuICAgICAgICBzdGFydFJlYWRpbmdGcm9tVW5pdmVyc2FsU3RyZWFtKFxuICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgIG9wdGlvbnMuZGVidWdDaGFubmVsLnJlYWRhYmxlLFxuICAgICAgICAgIGhhbmRsZURvbmVcbiAgICAgICAgKTtcbiAgICAgICAgc3RhcnRSZWFkaW5nRnJvbVN0cmVhbShyZXNwb25zZSwgc3RyZWFtLCBoYW5kbGVEb25lLCBzdHJlYW0pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHN0YXJ0UmVhZGluZ0Zyb21TdHJlYW0oXG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgIGNsb3NlLmJpbmQobnVsbCwgcmVzcG9uc2UpLFxuICAgICAgICAgIHN0cmVhbVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGdldFJvb3QocmVzcG9uc2UpO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVTZXJ2ZXJSZWZlcmVuY2UgPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGNhbGxTZXJ2ZXIsXG4gICAgICBlbmNvZGVGb3JtQWN0aW9uLFxuICAgICAgZmluZFNvdXJjZU1hcFVSTCxcbiAgICAgIGZ1bmN0aW9uTmFtZVxuICAgICkge1xuICAgICAgZnVuY3Rpb24gYWN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBjYWxsU2VydmVyKGlkLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHZhciBsb2NhdGlvbiA9IHBhcnNlU3RhY2tMb2NhdGlvbihFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKSk7XG4gICAgICBpZiAobnVsbCAhPT0gbG9jYXRpb24pIHtcbiAgICAgICAgZW5jb2RlRm9ybUFjdGlvbiA9IGxvY2F0aW9uWzFdO1xuICAgICAgICB2YXIgbGluZSA9IGxvY2F0aW9uWzJdO1xuICAgICAgICBsb2NhdGlvbiA9IGxvY2F0aW9uWzNdO1xuICAgICAgICBmaW5kU291cmNlTWFwVVJMID1cbiAgICAgICAgICBudWxsID09IGZpbmRTb3VyY2VNYXBVUkxcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiBmaW5kU291cmNlTWFwVVJMKGVuY29kZUZvcm1BY3Rpb24sIFwiQ2xpZW50XCIpO1xuICAgICAgICBhY3Rpb24gPSBjcmVhdGVGYWtlU2VydmVyRnVuY3Rpb24oXG4gICAgICAgICAgZnVuY3Rpb25OYW1lIHx8IFwiXCIsXG4gICAgICAgICAgZW5jb2RlRm9ybUFjdGlvbixcbiAgICAgICAgICBmaW5kU291cmNlTWFwVVJMLFxuICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgXCJDbGllbnRcIixcbiAgICAgICAgICBhY3Rpb25cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdGVyQm91bmRTZXJ2ZXJSZWZlcmVuY2UoYWN0aW9uLCBpZCwgbnVsbCk7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVUZW1wb3JhcnlSZWZlcmVuY2VTZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgIH07XG4gICAgZXhwb3J0cy5lbmNvZGVSZXBseSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGFib3J0ID0gcHJvY2Vzc1JlcGx5KFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLnRlbXBvcmFyeVJlZmVyZW5jZXNcbiAgICAgICAgICAgID8gb3B0aW9ucy50ZW1wb3JhcnlSZWZlcmVuY2VzXG4gICAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgIHJlamVjdFxuICAgICAgICApO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgIHZhciBzaWduYWwgPSBvcHRpb25zLnNpZ25hbDtcbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIGFib3J0KHNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBhYm9ydChzaWduYWwucmVhc29uKTtcbiAgICAgICAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGV4cG9ydHMucmVnaXN0ZXJTZXJ2ZXJSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVmZXJlbmNlLCBpZCkge1xuICAgICAgcmVnaXN0ZXJCb3VuZFNlcnZlclJlZmVyZW5jZShyZWZlcmVuY2UsIGlkLCBudWxsKTtcbiAgICAgIHJldHVybiByZWZlcmVuY2U7XG4gICAgfTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    AppRouterContext: function() {\n        return AppRouterContext;\n    },\n    GlobalLayoutRouterContext: function() {\n        return GlobalLayoutRouterContext;\n    },\n    LayoutRouterContext: function() {\n        return LayoutRouterContext;\n    },\n    MissingSlotContext: function() {\n        return MissingSlotContext;\n    },\n    TemplateContext: function() {\n        return TemplateContext;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst AppRouterContext = _react.default.createContext(null);\nconst LayoutRouterContext = _react.default.createContext(null);\nconst GlobalLayoutRouterContext = _react.default.createContext(null);\nconst TemplateContext = _react.default.createContext(null);\nif (true) {\n    AppRouterContext.displayName = 'AppRouterContext';\n    LayoutRouterContext.displayName = 'LayoutRouterContext';\n    GlobalLayoutRouterContext.displayName = 'GlobalLayoutRouterContext';\n    TemplateContext.displayName = 'TemplateContext';\n}\nconst MissingSlotContext = _react.default.createContext(new Set()); //# sourceMappingURL=app-router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBeURhQSxnQkFBZ0I7ZUFBaEJBOztJQWFBQyx5QkFBeUI7ZUFBekJBOztJQVZBQyxtQkFBbUI7ZUFBbkJBOztJQTBCQUMsa0JBQWtCO2VBQWxCQTs7SUFUQUMsZUFBZTtlQUFmQTs7Ozs0RUFqRUs7QUE2Q1gsTUFBTUosbUJBQW1CSyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FDakQ7QUFFSyxNQUFNSixzQkFBc0JHLE9BQUFBLE9BQUssQ0FBQ0MsYUFBYSxDQVE1QztBQUVILE1BQU1MLDRCQUE0QkksT0FBQUEsT0FBSyxDQUFDQyxhQUFhLENBS3pEO0FBRUksTUFBTUYsa0JBQWtCQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBa0I7QUFFcEUsSUFBSUMsSUFBb0IsRUFBbUI7SUFDekNQLGlCQUFpQlUsV0FBVyxHQUFHO0lBQy9CUixvQkFBb0JRLFdBQVcsR0FBRztJQUNsQ1QsMEJBQTBCUyxXQUFXLEdBQUc7SUFDeENOLGdCQUFnQk0sV0FBVyxHQUFHO0FBQ2hDO0FBRU8sTUFBTVAscUJBQXFCRSxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBYyxJQUFJSyIsInNvdXJjZXMiOlsiL1VzZXJzL3J5YW5yb3N6dG9jenkvRGV2ZWxvcG1lbnQvc3JjL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgdHlwZSB7XG4gIEZvY3VzQW5kU2Nyb2xsUmVmLFxuICBQcmVmZXRjaEtpbmQsXG59IGZyb20gJy4uLy4uL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHR5cGUgeyBQYXJhbXMgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnXG5pbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBGbGlnaHRTZWdtZW50UGF0aCxcbiAgQ2FjaGVOb2RlLFxufSBmcm9tICcuL2FwcC1yb3V0ZXItdHlwZXMnXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVPcHRpb25zIHtcbiAgc2Nyb2xsPzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByZWZldGNoT3B0aW9ucyB7XG4gIGtpbmQ6IFByZWZldGNoS2luZFxuICBvbkludmFsaWRhdGU/OiAoKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXBwUm91dGVySW5zdGFuY2Uge1xuICAvKipcbiAgICogTmF2aWdhdGUgdG8gdGhlIHByZXZpb3VzIGhpc3RvcnkgZW50cnkuXG4gICAqL1xuICBiYWNrKCk6IHZvaWRcbiAgLyoqXG4gICAqIE5hdmlnYXRlIHRvIHRoZSBuZXh0IGhpc3RvcnkgZW50cnkuXG4gICAqL1xuICBmb3J3YXJkKCk6IHZvaWRcbiAgLyoqXG4gICAqIFJlZnJlc2ggdGhlIGN1cnJlbnQgcGFnZS5cbiAgICovXG4gIHJlZnJlc2goKTogdm9pZFxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgY3VycmVudCBwYWdlLiBVc2UgaW4gZGV2ZWxvcG1lbnQgb25seS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBobXJSZWZyZXNoKCk6IHZvaWRcbiAgLyoqXG4gICAqIE5hdmlnYXRlIHRvIHRoZSBwcm92aWRlZCBocmVmLlxuICAgKiBQdXNoZXMgYSBuZXcgaGlzdG9yeSBlbnRyeS5cbiAgICovXG4gIHB1c2goaHJlZjogc3RyaW5nLCBvcHRpb25zPzogTmF2aWdhdGVPcHRpb25zKTogdm9pZFxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gdGhlIHByb3ZpZGVkIGhyZWYuXG4gICAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IGhpc3RvcnkgZW50cnkuXG4gICAqL1xuICByZXBsYWNlKGhyZWY6IHN0cmluZywgb3B0aW9ucz86IE5hdmlnYXRlT3B0aW9ucyk6IHZvaWRcbiAgLyoqXG4gICAqIFByZWZldGNoIHRoZSBwcm92aWRlZCBocmVmLlxuICAgKi9cbiAgcHJlZmV0Y2goaHJlZjogc3RyaW5nLCBvcHRpb25zPzogUHJlZmV0Y2hPcHRpb25zKTogdm9pZFxufVxuXG5leHBvcnQgY29uc3QgQXBwUm91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8QXBwUm91dGVySW5zdGFuY2UgfCBudWxsPihcbiAgbnVsbFxuKVxuZXhwb3J0IGNvbnN0IExheW91dFJvdXRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PHtcbiAgcGFyZW50VHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgcGFyZW50Q2FjaGVOb2RlOiBDYWNoZU5vZGVcbiAgcGFyZW50U2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoIHwgbnVsbFxuICBwYXJlbnRQYXJhbXM6IFBhcmFtc1xuICBkZWJ1Z05hbWVDb250ZXh0OiBzdHJpbmdcbiAgdXJsOiBzdHJpbmdcbiAgaXNBY3RpdmU6IGJvb2xlYW5cbn0gfCBudWxsPihudWxsKVxuXG5leHBvcnQgY29uc3QgR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8e1xuICB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuICBmb2N1c0FuZFNjcm9sbFJlZjogRm9jdXNBbmRTY3JvbGxSZWZcbiAgbmV4dFVybDogc3RyaW5nIHwgbnVsbFxuICBwcmV2aW91c05leHRVcmw6IHN0cmluZyB8IG51bGxcbn0+KG51bGwgYXMgYW55KVxuXG5leHBvcnQgY29uc3QgVGVtcGxhdGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxSZWFjdC5SZWFjdE5vZGU+KG51bGwgYXMgYW55KVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBBcHBSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0FwcFJvdXRlckNvbnRleHQnXG4gIExheW91dFJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnTGF5b3V0Um91dGVyQ29udGV4dCdcbiAgR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0J1xuICBUZW1wbGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSAnVGVtcGxhdGVDb250ZXh0J1xufVxuXG5leHBvcnQgY29uc3QgTWlzc2luZ1Nsb3RDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxTZXQ8c3RyaW5nPj4obmV3IFNldCgpKVxuIl0sIm5hbWVzIjpbIkFwcFJvdXRlckNvbnRleHQiLCJHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiTGF5b3V0Um91dGVyQ29udGV4dCIsIk1pc3NpbmdTbG90Q29udGV4dCIsIlRlbXBsYXRlQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRpc3BsYXlOYW1lIiwiU2V0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    NavigationPromisesContext: function() {\n        return NavigationPromisesContext;\n    },\n    PathParamsContext: function() {\n        return PathParamsContext;\n    },\n    PathnameContext: function() {\n        return PathnameContext;\n    },\n    ReadonlyURLSearchParams: function() {\n        return _readonlyurlsearchparams.ReadonlyURLSearchParams;\n    },\n    SearchParamsContext: function() {\n        return SearchParamsContext;\n    },\n    createDevToolsInstrumentedPromise: function() {\n        return createDevToolsInstrumentedPromise;\n    }\n});\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _readonlyurlsearchparams = __webpack_require__(/*! ../../client/components/readonly-url-search-params */ \"(app-pages-browser)/./node_modules/next/dist/client/components/readonly-url-search-params.js\");\nconst SearchParamsContext = (0, _react.createContext)(null);\nconst PathnameContext = (0, _react.createContext)(null);\nconst PathParamsContext = (0, _react.createContext)(null);\nconst NavigationPromisesContext = (0, _react.createContext)(null);\nfunction createDevToolsInstrumentedPromise(displayName, value) {\n    const promise = Promise.resolve(value);\n    promise.status = 'fulfilled';\n    promise.value = value;\n    promise.displayName = `${displayName} (SSR)`;\n    return promise;\n}\nif (true) {\n    SearchParamsContext.displayName = 'SearchParamsContext';\n    PathnameContext.displayName = 'PathnameContext';\n    PathParamsContext.displayName = 'PathParamsContext';\n    NavigationPromisesContext.displayName = 'NavigationPromisesContext';\n} //# sourceMappingURL=hooks-client-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9ob29rcy1jbGllbnQtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUE4QmFBLHlCQUF5QjtlQUF6QkE7O0lBdEJBQyxpQkFBaUI7ZUFBakJBOztJQURBQyxlQUFlO2VBQWZBOztJQXdDSkMsdUJBQXVCO2VBQXZCQSx5QkFBQUEsdUJBQXVCOztJQXpDbkJDLG1CQUFtQjtlQUFuQkE7O0lBOEJHQyxpQ0FBaUM7ZUFBakNBOzs7bUNBbENjO3FEQUVVO0FBRWpDLE1BQU1ELHNCQUFzQkUsQ0FBQUEsR0FBQUEsT0FBQUEsYUFBQUEsRUFBc0M7QUFDbEUsTUFBTUosa0JBQWtCSSxDQUFBQSxHQUFBQSxPQUFBQSxhQUFBQSxFQUE2QjtBQUNyRCxNQUFNTCxvQkFBb0JLLENBQUFBLEdBQUFBLE9BQUFBLGFBQUFBLEVBQTZCO0FBc0J2RCxNQUFNTiw0QkFDWE0sQ0FBQUEsR0FBQUEsT0FBQUEsYUFBYSxFQUE0QjtBQUtwQyxTQUFTRCxrQ0FDZEUsV0FBbUIsRUFDbkJDLEtBQVE7SUFFUixNQUFNQyxVQUFVQyxRQUFRQyxPQUFPLENBQUNIO0lBQ2hDQyxRQUFRRyxNQUFNLEdBQUc7SUFDakJILFFBQVFELEtBQUssR0FBR0E7SUFDaEJDLFFBQVFGLFdBQVcsR0FBRyxHQUFHQSxZQUFZLE1BQU0sQ0FBQztJQUM1QyxPQUFPRTtBQUNUO0FBSUEsSUFBSUksSUFBb0IsRUFBbUI7SUFDekNULG9CQUFvQkcsV0FBVyxHQUFHO0lBQ2xDTCxnQkFBZ0JLLFdBQVcsR0FBRztJQUM5Qk4sa0JBQWtCTSxXQUFXLEdBQUc7SUFDaENQLDBCQUEwQk8sV0FBVyxHQUFHO0FBQzFDIiwic291cmNlcyI6WyIvVXNlcnMvcnlhbnJvc3p0b2N6eS9EZXZlbG9wbWVudC9zcmMvc2hhcmVkL2xpYi9ob29rcy1jbGllbnQtY29udGV4dC5zaGFyZWQtcnVudGltZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBQYXJhbXMgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnXG5pbXBvcnQgeyBSZWFkb25seVVSTFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uLy4uL2NsaWVudC9jb21wb25lbnRzL3JlYWRvbmx5LXVybC1zZWFyY2gtcGFyYW1zJ1xuXG5leHBvcnQgY29uc3QgU2VhcmNoUGFyYW1zQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VVJMU2VhcmNoUGFyYW1zIHwgbnVsbD4obnVsbClcbmV4cG9ydCBjb25zdCBQYXRobmFtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PHN0cmluZyB8IG51bGw+KG51bGwpXG5leHBvcnQgY29uc3QgUGF0aFBhcmFtc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFBhcmFtcyB8IG51bGw+KG51bGwpXG5cbi8vIERldi1vbmx5IGNvbnRleHQgZm9yIFN1c3BlbnNlIERldlRvb2xzIGluc3RydW1lbnRhdGlvblxuLy8gVGhlc2UgcHJvbWlzZXMgYXJlIHVzZWQgdG8gdHJhY2sgbmF2aWdhdGlvbiBob29rIHVzYWdlIGluIFJlYWN0IERldlRvb2xzXG5leHBvcnQgdHlwZSBJbnN0cnVtZW50ZWRQcm9taXNlPFQ+ID0gUHJvbWlzZTxUPiAmIHtcbiAgc3RhdHVzOiAnZnVsZmlsbGVkJ1xuICB2YWx1ZTogVFxuICBkaXNwbGF5TmFtZTogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIE5hdmlnYXRpb25Qcm9taXNlcyA9IHtcbiAgcGF0aG5hbWU6IEluc3RydW1lbnRlZFByb21pc2U8c3RyaW5nPlxuICBzZWFyY2hQYXJhbXM6IEluc3RydW1lbnRlZFByb21pc2U8UmVhZG9ubHlVUkxTZWFyY2hQYXJhbXM+XG4gIHBhcmFtczogSW5zdHJ1bWVudGVkUHJvbWlzZTxQYXJhbXM+XG4gIC8vIExheW91dCBzZWdtZW50IGhvb2tzICh1cGRhdGVkIGF0IGVhY2ggbGF5b3V0IGJvdW5kYXJ5KVxuICBzZWxlY3RlZExheW91dFNlZ21lbnRQcm9taXNlcz86IE1hcDxcbiAgICBzdHJpbmcsXG4gICAgSW5zdHJ1bWVudGVkUHJvbWlzZTxzdHJpbmcgfCBudWxsPlxuICA+XG4gIHNlbGVjdGVkTGF5b3V0U2VnbWVudHNQcm9taXNlcz86IE1hcDxzdHJpbmcsIEluc3RydW1lbnRlZFByb21pc2U8c3RyaW5nW10+PlxufVxuXG5leHBvcnQgY29uc3QgTmF2aWdhdGlvblByb21pc2VzQ29udGV4dCA9XG4gIGNyZWF0ZUNvbnRleHQ8TmF2aWdhdGlvblByb21pc2VzIHwgbnVsbD4obnVsbClcblxuLy8gQ3JlYXRlcyBhbiBpbnN0cnVtZW50ZWQgcHJvbWlzZSBmb3IgU3VzcGVuc2UgRGV2VG9vbHNcbi8vIFRoZXNlIHByb21pc2VzIGFyZSBhbHdheXMgZnVsZmlsbGVkIGFuZCBleGlzdCBwdXJlbHkgZm9yXG4vLyB0cmFja2luZyBpbiBSZWFjdCdzIFN1c3BlbnNlIERldlRvb2xzLlxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURldlRvb2xzSW5zdHJ1bWVudGVkUHJvbWlzZTxUPihcbiAgZGlzcGxheU5hbWU6IHN0cmluZyxcbiAgdmFsdWU6IFRcbik6IEluc3RydW1lbnRlZFByb21pc2U8VD4ge1xuICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKSBhcyBJbnN0cnVtZW50ZWRQcm9taXNlPFQ+XG4gIHByb21pc2Uuc3RhdHVzID0gJ2Z1bGZpbGxlZCdcbiAgcHJvbWlzZS52YWx1ZSA9IHZhbHVlXG4gIHByb21pc2UuZGlzcGxheU5hbWUgPSBgJHtkaXNwbGF5TmFtZX0gKFNTUilgXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmV4cG9ydCB7IFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zIH1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgU2VhcmNoUGFyYW1zQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdTZWFyY2hQYXJhbXNDb250ZXh0J1xuICBQYXRobmFtZUNvbnRleHQuZGlzcGxheU5hbWUgPSAnUGF0aG5hbWVDb250ZXh0J1xuICBQYXRoUGFyYW1zQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdQYXRoUGFyYW1zQ29udGV4dCdcbiAgTmF2aWdhdGlvblByb21pc2VzQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdOYXZpZ2F0aW9uUHJvbWlzZXNDb250ZXh0J1xufVxuIl0sIm5hbWVzIjpbIk5hdmlnYXRpb25Qcm9taXNlc0NvbnRleHQiLCJQYXRoUGFyYW1zQ29udGV4dCIsIlBhdGhuYW1lQ29udGV4dCIsIlJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zIiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsImNyZWF0ZURldlRvb2xzSW5zdHJ1bWVudGVkUHJvbWlzZSIsImNyZWF0ZUNvbnRleHQiLCJkaXNwbGF5TmFtZSIsInZhbHVlIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic3RhdHVzIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\n"));

/***/ })

});